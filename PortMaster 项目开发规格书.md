# **PortMaster（端口大师）项目开发规格书 (最终版)**

你是一名资深 Windows C++/MFC 工程师，请严格按照以下完整规格，开发一个名为 **PortMaster（端口大师）** 的桌面应用程序，并按交付要求输出全部设计与源码。

### **0\. 平台与编译/编码要求**

* **操作系统兼容**：Windows 7 \~ Windows 11，支持 x86 与 x64。  
* **编译环境**：Visual Studio 2022 中文版，Toolset v143。  
* **目标产物**：单一 EXE 绿色免安装版本，静态链接运行库（/MT 或 /MTd）与静态链接 MFC。  
* **编码规范**：  
  * 源码、注释、资源、文档全部使用**简体中文**。  
  * 源码文件编码统一为 **UTF-8（带 BOM）**，必要处添加：  
    \#pragma execution\_character\_set("utf-8")

  * .rc 资源文件与字符串表同样使用 UTF-8（BOM）。  
* **配置存储**：优先尝试保存在程序同目录的 JSON 配置文件中。若程序目录不可写（如 Program Files），则自动回退到 %LOCALAPPDATA%\\PortMaster 目录。

### **0.1 自动编译脚本闭环**

* 项目根目录提供 autobuild.bat 脚本，用于自动化编译。  
* 脚本应支持传入参数，以编译不同的配置（如 Debug, Release）。  
* 编译完成后，脚本自动将生成的目标 EXE 文件及相关产物（如配置文件模板）复制到统一的 bin\\ 目录下。  
* 每次需要验证修改是否正确时，**自动调用该脚本**，并**读取编译输出日志**检查。  
* 必须将**所有错误和警告修正为 0**（Zero Errors & Zero Warnings）后，方可进入下一阶段开发。

### **1\. 项目名称与品牌**

* **项目名称**：PortMaster（端口大师）  
* **定位**：多端口（串口/LPT/USB 打印机/网络）数据读写与高可靠传输工具。  
* **品牌特征**：跨端口通信、高效可靠传输协议、单文件绿色版、Win7\~Win11 全兼容。

### **1.1 视觉资源（必须集成）**

1. **项目主图标（多分辨率 ICO）**  
   * 文件：PortMaster\_Icon.ico  
   * 用作应用主图标（MFC 工程 IDI\_MAIN\_ICON），包含 16、32、48、64、128、256 像素分辨率。  
2. **PNG 图标源文件**  
   * 文件：PortMaster\_Icon.png  
3. **启动画面（Splash Screen）**  
   * 文件：PortMaster\_Splash.png  
   * **显示逻辑**：程序启动时，在加载配置文件、初始化核心模块等任务执行期间居中显示。当主窗口初始化完成并准备显示时，启动画面随即关闭。**严禁使用固定时长的等待**。  
4. **集成要求**  
   * 所有资源文件需打包进 EXE（在 .rc 文件中声明 ICON、BITMAP 或 RCDATA 资源）。  
   * 启动画面必须在 Win7\~Win11 显示正常（避免使用仅 Win8+ API）。

### **2\. 功能要求**

#### **2.1 支持端口类型**

1. **串口 COM**  
   * API：CreateFile / SetCommState / OVERLAPPED I/O  
   * 支持参数配置（波特率、数据位、校验位、停止位等）。  
2. **并口 LPT（仅微软标准 API 路径）**  
   * API：OpenPrinter / StartDocPrinter / WritePrinter / EndDocPrinter（RAW 作业方式）。  
   * 提供打印机/队列状态查询作为“读”的替代。  
3. **USB 打印机**  
   * 同 LPT 实现方式（Winspool RAW）。  
4. **网络**  
   * TCP 客户端/服务端 \+ UDP。  
5. **本地回环**  
   * LoopbackTransport，用于协议自测。  
6. **设备自动发现**  
   * 程序应能自动枚举当前系统可用的 COM 端口和打印机队列（LPT/USB），并更新到端口选择下拉框中。  
   * UI 提供“刷新设备”按钮，供用户手动刷新。  
   * **（进阶）** 程序应能响应 WM\_DEVICECHANGE 消息，在检测到设备热插拔时，自动刷新端口列表。

#### **2.2 工作模式**

* **直通模式**：直接对端口进行数据读写（对 LPT 为“写 \+ 状态查询”）。  
* **可靠传输模式**：使用本项目自研协议（见第 3 节），可随时开/关，不影响直通。

### **3\. 高效可靠数据传输协议**

#### **3.1 帧格式（小端序）**

包头(0xAA55,2B) \+ 类型(1B) \+ 序号(2B) \+ 长度(2B) \+  
CRC32(4B, 多项式0xEDB88320, init 0xFFFFFFFF, final xor 0xFFFFFFFF, 覆盖“类型|序号|长度|数据”) \+  
数据(0..N) \+ 包尾(0x55AA,2B)

* **类型**: 0x01=START, 0x02=DATA, 0x03=END, 0x10=ACK, 0x11=NAK  
* **默认负载上限**: 1024 字节（可配置）

#### **3.2 START 元数据（在 START 帧的数据部分）**

* 结构：

proto\_ver(1B)=1, window\_size(1B), flags(1B), name\_len(2B), name(UTF-8), file\_size(8B,LE)\[, mtime(8B)\]

* **proto\_ver**: 协议版本号，用于未来扩展。  
* **window\_size**: 通信双方协商的滑动窗口大小（1-255），用于流量控制。  
* 接收端按源文件名保存（若重名则自动添加后缀），保存目录由用户指定。

#### **3.3 流程（基于滑动窗口）**

* **发送端**：START → 等 ACK → 在协商的**滑动窗口**内连续发送 DATA(N) 包 → 根据收到的 ACK/NAK 和超时情况，滑动窗口并重传丢包 → 所有数据发送完毕后发送 END → 等 ACK → 完成。  
* **接收端**：收到 START 回 ACK；DATA 序号\&CRC正确 → 保存并发送累积 ACK；若序号不连续则缓存乱序包；若CRC错误则丢弃；收到 END 回 ACK。

#### **3.4 错误处理**

* CRC 失败 → 丢弃数据包，等待发送方超时重传。  
* 超时 → 发送方重传窗口内未被确认的数据包。  
* 超过最大重试次数 → 传输失败，通知上层。

#### **3.5 流量控制与容错**

* 支持粘包/半包处理及失步重同步（通过扫描帧头 0xAA55）。  
* **流量控制**：采用**可配置的滑动窗口机制**（窗口大小 N，默认为8，可在 START 帧中协商），以平衡吞吐率和延迟。

#### **3.6 状态机**

* Sender：Idle → Starting → Sending → Ending → Done/Failed  
* Receiver：Idle → Ready → Receiving → Done/Failed

### **4\. 架构与代码组织**

#### **4.1 核心架构原则：异步消息驱动**

* **强制要求**：所有 I/O 操作（读写、连接、监听）和协议逻辑（组帧、校验、重传、状态机管理）**必须在后台工作线程（IOWorker）中执行**。  
* **UI 线程与工作线程的交互**：严格通过 **Windows 消息机制（PostMessage）** 进行。UI 线程向工作线程发送任务指令（如 WM\_USER\_START\_SEND），工作线程向 UI 线程回报进度、数据、状态和结果（如 WM\_USER\_UPDATE\_PROGRESS）。  
* **目标**：从架构上杜绝任何可能导致 UI 冻结的操作，保证界面的绝对流畅和高响应性。

#### **4.2 代码模块**

* **ITransport 接口**：Open / Close / Read / Write / IsOpen / Configure  
* **实现类**：SerialTransport, LptSpoolerTransport, TcpTransport, UdpTransport, LoopbackTransport。建议使用**工厂模式**根据用户选择创建对应的 Transport 实例。  
* **协议层**：ReliableChannel（负责实现滑动窗口、状态机和重传逻辑）  
* **工具类**：FrameCodec, CRC32, RingBuffer（支持自动扩展的环形缓冲区）  
* **I/O 层**：IOWorker（封装后台线程、OVERLAPPED I/O 和消息循环）  
* **MFC 对话框 UI**：  
  * 端口选择下拉框（支持设备自动发现与刷新）  
  * 参数配置面板  
  * 十六进制 / 文本双视图（输入与接收）  
  * 拖放文件发送  
  * 协议状态、滑动窗口状态可视化视图  
  * 日志窗口、进度条

### **5\. 配置与测试**

* **配置文件**：采用 JSON 格式，存储所有端口参数、协议参数（如默认窗口大小、超时时间）和UI状态。  
  * **JSON 库**：推荐使用业界成熟的 header-only 库 nlohmann/json，便于集成，不破坏单文件目标。  
  * **加载鲁棒性**：若配置文件读取失败（文件不存在、被破坏），程序应加载一套安全的默认配置启动，并向用户给出提示。  
  * **保存安全性**：保存配置时，采用“**写入临时文件 \-\> 删除旧文件 \-\> 重命名临时文件**”的安全策略，防止因意外中断导致配置丢失。  
* **内置测试向导**：  
  * **阶段 1**：本地连接测试（Loopback，发送“Hello PortMaster”验证协议正确性）  
  * **阶段 2**：串口设备通信测试  
    * **场景 A（设备通信）**：连接一个物理串口设备（如单片机、调制解调器等），进行大文件传输与干扰恢复测试。  
    * **场景 B（主机间通信）**：通过**空调制解调器连接（Null Modem）**（物理电缆或虚拟软件），在两台运行本工具的主机间进行双向数据传输和协议可靠性测试。

### **6\. 非功能性与边界**

* **依赖策略**：优先使用微软标准库与 Windows API。允许为实现关键功能（如JSON解析）而引入必要的、高质量的、可通过源码直接集成的第三方库。  
* **LPT/USB 打印机端口边界与依赖**：  
  * **API 路径**：对这些端口的控制严格遵守微软标准，仅通过 Winspool API 以 RAW 作业模式进行数据写入和状态查询，不涉及任何需要特殊权限的驱动层面直接 I/O 操作。  
  * **驱动依赖**：由于上述 API 路径基于 Windows 打印子系统，**使用这些端口的硬性前提是**：目标物理端口（如 LPT1 或特定 USB 设备）**必须已在操作系统中安装了有效的打印机驱动程序**。此驱动可以是设备专用驱动，也可以是 Windows 内置的 “Generic / Text Only”（仅文本）通用驱动。本工具的应用层功能无法绕过此驱动模型。  
* **Win7 兼容性**：避免使用 Win8+ API，或为之提供基于条件编译的兼容性回退实现。  
* **安全**：作为网络服务端进行监听时，必须有明确的 UI 操作和用户确认。

### **7\. 交付内容（按顺序）**

1. 总体设计说明（中文）+ ASCII 类图/组件图  
2. 协议规格表（含 START 元数据、滑动窗口协商机制）  
3. 发送端/接收端状态机图（ASCII）  
4. 关键 C++ 源码（含异步消息模型、IOWorker、ReliableChannel、资源加载与启动画面显示）  
5. .rc 资源文件（包含 PortMaster\_Icon.ico 与 PortMaster\_Splash.png）  
6. 配置保存/加载模块源码及示例 config.json  
7. 内置测试向导实现说明  
8. 构建指南（含资源添加、autobuild.bat 使用方法）  
9. 边界与风控清单（含驱动依赖说明）  
10. 后续扩展建议（如支持更多协议、动态调整窗口大小等）