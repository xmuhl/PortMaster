# 自动修复系统快速开始指南

## 🚀 5分钟快速体验

### 第一步：环境检查
```bash
# 检查Python版本（需要3.7+）
python --version

# 检查系统环境
dir autobuild_x86_debug.bat
dir build\Debug\PortMaster.exe
```

### 第二步：安装依赖
```bash
# 安装必需的Python库
pip install pillow pygetwindow pytesseract psutil

# 验证安装
python -c "import PIL, cv2, pytesseract, psutil; print('所有依赖已安装成功')"
```

### 第三步：快速测试
```bash
# 运行快速测试（1分钟内完成）
python quick_test_fix.py
```

**预期输出：**
```
✅ 成功检测到 1 个错误窗口
✅ 错误窗口截图已保存
✅ 快速测试成功完成
```

### 第四步：完整修复（可选）
```bash
# 运行完整自动修复（可能需要10-30分钟）
python autonomous_fix_controller.py
```

## 📋 系统要求检查清单

### ✅ 必需环境
- [ ] Windows 7/8/10/11 系统
- [ ] Python 3.7 或更高版本
- [ ] Visual Studio 2022 （用于编译）
- [ ] 至少 4GB 可用内存
- [ ] 至少 500MB 磁盘空间

### ✅ 项目文件检查
- [ ] `PortMaster.sln` - 解决方案文件
- [ ] `autobuild_x86_debug.bat` - 编译脚本
- [ ] `build\Debug\PortMaster.exe` - 目标程序
- [ ] `autonomous_fix_controller.py` - 主控制器
- [ ] `enhanced_error_capture.py` - 错误捕获模块

## 🔧 基本使用示例

### 示例1：快速错误检测
```bash
# 仅检测错误，不修复
python enhanced_error_capture.py
```

**适用场景：**
- 想要知道程序有什么错误
- 不想立即修复错误
- 收集错误信息用于分析

### 示例2：单次完整修复
```bash
# 运行一次完整的检测和修复流程
python quick_test_fix.py
```

**适用场景：**
- 快速验证修复功能
- 测试系统工作状态
- 简单错误修复

### 示例3：全自动迭代修复
```bash
# 持续修复直到问题解决
python autonomous_fix_controller.py
```

**适用场景：**
- 复杂错误需要多次修复
- 希望完全自动化处理
- 生产环境问题解决

## 🛠️ 常见问题解决

### Q1: 提示"找不到指定的文件"
**问题：** `'autobuild_x86_debug.bat' 不是内部或外部命令`

**解决方案：**
```bash
# 检查文件是否存在
dir autobuild_x86_debug.bat

# 如果不存在，检查是否有其他编译脚本
dir autobuild*.bat

# 使用完整路径运行
python -c "
import subprocess
import os
result = subprocess.run(['cmd.exe', '/c', os.path.join(os.getcwd(), 'autobuild_x86_debug.bat')], capture_output=True)
print('Return code:', result.returncode)
"
```

### Q2: OCR识别失败
**问题：** `pytesseract` 相关错误

**解决方案：**
```bash
# 重新安装pytesseract
pip uninstall pytesseract
pip install pytesseract

# 下载Tesseract OCR引擎
# 访问：https://github.com/UB-Mannheim/tesseract/wiki
# 下载并安装 Windows 版本

# 验证安装
tesseract --version
```

### Q3: 截图捕获失败
**问题：** `Image size exceeds limit` 错误

**解决方案：**
```python
# 在代码中调整图像大小限制
from PIL import Image
Image.MAX_IMAGE_PIXELS = 100000000  # 增加到100MB
```

### Q4: 权限不足错误
**问题：** 窗口检测或进程操作失败

**解决方案：**
```bash
# 以管理员身份运行命令提示符
# 然后再执行修复程序

# 或者在Python代码中添加权限检查
import ctypes
import os

def is_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

if not is_admin():
    print("请以管理员身份运行此程序")
```

## 📊 输出文件说明

### 自动生成的文件
运行系统后会自动创建以下文件：

```
auto_screenshots/
├── error_RUNTIME_ERROR_20250930_231951.png  # 错误窗口截图
└── ...

code_backups/
├── PortMasterDlg_20250930_231951.cpp        # 代码备份
└── ...

fix_results/
├── session_20250930_231951.json            # 修复结果
└── quick_test_20250930_231943.log          # 测试日志
```

### 如何查看结果

1. **查看截图文件**
   ```bash
   # 打开截图目录
   start auto_screenshots
   ```

2. **查看修复日志**
   ```bash
   # 查看最新日志
   type fix_results\*.log
   ```

3. **查看修复结果**
   ```bash
   # 查看JSON格式的修复结果
   type fix_results\*.json
   ```

## 🔍 进阶使用技巧

### 技巧1：自定义配置
```python
# 创建配置文件 config.py
CONFIG = {
    'max_iterations': 5,           # 最大修复次数
    'screenshot_delays': [3, 10],  # 截图时间点
    'enable_auto_compile': True,   # 是否自动编译
    'backup_enabled': True         # 是否创建备份
}
```

### 技巧2：批量处理
```bash
# 创建批处理文件 run_repair.bat
@echo off
echo 开始自动修复...
python autonomous_fix_controller.py
echo 修复完成，按任意键退出
pause
```

### 技巧3：定时任务
```python
# 创建定时修复脚本 scheduled_repair.py
import schedule
import time

def run_daily_repair():
    print("执行定时修复...")
    os.system("python autonomous_fix_controller.py")

# 每天凌晨2点执行
schedule.every().day.at("02:00").do(run_daily_repair)

while True:
    schedule.run_pending()
    time.sleep(3600)  # 每小时检查一次
```

## 📈 性能优化建议

### 1. 系统资源优化
- 关闭不必要的程序释放内存
- 确保有足够的磁盘空间
- 使用SSD提高I/O性能

### 2. 网络环境优化
- 确保网络连接稳定
- 如果下载依赖失败，使用国内镜像源
- 配置代理（如需要）

### 3. 开发环境优化
```bash
# 使用虚拟环境隔离依赖
python -m venv repair_env
repair_env\Scripts\activate
pip install -r requirements.txt

# 优化编译环境
set VSINSTALLDIR="C:\Program Files\Microsoft Visual Studio\2022\Community"
```

## 🆘 获取帮助

### 调试模式
```python
# 启用详细日志
import logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# 运行调试版本
python autonomous_fix_controller.py --debug
```

### 诊断工具
```bash
# 运行系统诊断
python -c "
import sys
import os
import platform

print('=== 系统诊断 ===')
print('Python版本:', sys.version)
print('操作系统:', platform.system(), platform.release())
print('工作目录:', os.getcwd())
print('PortMaster.exe存在:', os.path.exists('build\\Debug\\PortMaster.exe'))
print('编译脚本存在:', os.path.exists('autobuild_x86_debug.bat'))
"
```

### 联系支持
如果遇到无法解决的问题：

1. **收集诊断信息**
   ```bash
   python -c "
   import sys, os, platform, psutil
   print('=== 支持信息 ===')
   print('Python:', sys.version)
   print('OS:', platform.platform())
   print('Memory:', psutil.virtual_memory().percent, '%')
   print('Disk:', psutil.disk_usage('/').percent, '%')
   "
   ```

2. **收集错误日志**
   ```bash
   # 收集所有日志文件
   copy fix_results\*.log support_logs_%date%.log
   ```

3. **提供问题描述**
   - 详细的错误信息
   - 重现步骤
   - 系统环境信息

## 🎯 下一步学习

### 延伸阅读
1. **完整使用手册** - `自主智能自动化修复系统使用手册.md`
2. **技术实现详解** - `自动修复系统技术实现详解.md`
3. **系统文件清单** - `系统文件清单.md`

### 高级功能
- 自定义修复策略开发
- 集成到CI/CD流水线
- 批量项目修复
- 性能监控和报告

### 社区资源
- GitHub仓库（示例链接）
- 技术博客和教程
- 用户交流群组
- 问题反馈平台

---

## 🎉 恭喜！

您已经成功掌握了自动修复系统的基本使用方法！

**下一步建议：**
- 尝试修复实际项目中的错误
- 探索高级配置选项
- 阅读完整技术文档
- 参与社区讨论和贡献

**记住：** 这个系统设计为完全自主运行，您只需要启动它，剩下的工作都会自动完成！

---
*最后更新：2025-09-30 | 版本：1.0.0*