# PortMaster 项目修复详细任务计划

**创建日期**: 2025-10-01 22:49:01
**计划范围**: P0阻塞性问题修复 + P1重要问题修复
**预计工时**: 约103分钟（1.7小时）
**执行原则**: 先P0后P1，逐项验证，确保0 error 0 warning

---

## 任务执行概览

```
Phase 1: P0紧急修复（阻塞性问题，必须立即执行）
├─ 任务组A: 本地回路性能优化（第二次P0修复）
│  ├─ A1. 批量处理优化（LoopbackTransport.cpp）
│  ├─ A2. 消除线程休眠（LoopbackTransport.cpp）
│  ├─ A3. 扩大队列容量（LoopbackTransport.h）
│  ├─ A4. 编译验证（0 error 0 warning）
│  └─ A5. 生成P0二次修复报告
│
└─ 任务组B: AutoTest工具P0修复
   ├─ B1. 修复文件路径错误（main.cpp）
   ├─ B2. 添加直通模式测试函数（main.cpp）
   ├─ B3. 重构main()函数为双模式测试（main.cpp）
   ├─ B4. 编译验证（AutoTest.exe）
   └─ B5. 功能测试（两种模式均通过）

Phase 2: P1重要修复（建议执行，提升质量）
├─ C1. 添加日志文件保存（AutoTest/main.cpp）
├─ C2. 移除统计信息显示（AutoTest/main.cpp）
└─ C3. 编译验证

Phase 3: 版本控制与文档
├─ D1. 暂存所有变更（git add -A）
├─ D2. 生成提交信息并提交
├─ D3. 推送到远程仓库
└─ D4. 更新修订工作记录
```

---

## Phase 1: P0紧急修复

### 任务组A: 本地回路性能优化（第二次P0修复）

#### 任务A1: 批量处理优化

**目标**: 将工作线程处理能力从1000 pkt/s提升到100000+ pkt/s

**修改文件**: `Transport/LoopbackTransport.cpp`

**修改位置**: `ProcessSendQueue()` 函数（约第559-610行）

**修改前代码**:
```cpp
void LoopbackTransport::ProcessSendQueue()
{
    std::unique_lock<std::mutex> sendLock(m_sendQueueMutex);

    if (m_sendQueue.empty())
    {
        return;  // ← 仅处理1个包
    }

    LoopbackPacket packet = m_sendQueue.front();
    m_sendQueue.pop();
    sendLock.unlock();

    // 模拟传输延迟
    uint32_t delay = CalculateDelay();
    SimulateDelay(delay);

    // 检查是否模拟丢包
    if (packet.shouldLoss || ShouldSimulatePacketLoss())
    {
        // ... 丢包处理 ...
        return;
    }

    // 检查是否模拟错误
    if (packet.shouldError || ShouldSimulateError())
    {
        // ... 错误处理 ...
        return;
    }

    // 将数据包移到接收队列
    {
        std::lock_guard<std::mutex> receiveLock(m_receiveQueueMutex);
        m_receiveQueue.push(packet);
        m_receiveCondition.notify_one();
    }

    // 更新统计
    {
        std::lock_guard<std::mutex> lock(m_statsMutex);
        m_stats.successfulRounds++;
    }
}
```

**修改后代码**:
```cpp
void LoopbackTransport::ProcessSendQueue()
{
    const int BATCH_SIZE = 100;  // 【P0二次修复】每次处理100个包
    int processed = 0;

    while (processed < BATCH_SIZE)
    {
        std::unique_lock<std::mutex> sendLock(m_sendQueueMutex);

        if (m_sendQueue.empty())
        {
            break;  // 队列为空，退出批处理循环
        }

        LoopbackPacket packet = m_sendQueue.front();
        m_sendQueue.pop();
        sendLock.unlock();

        // 模拟传输延迟（已在第一次P0修复中设置为0ms）
        uint32_t delay = CalculateDelay();
        SimulateDelay(delay);

        // 检查是否模拟丢包
        if (packet.shouldLoss || ShouldSimulatePacketLoss())
        {
            // 记录丢包统计
            {
                std::lock_guard<std::mutex> lock(m_statsMutex);
                m_stats.simulatedLosses++;
                m_stats.failedRounds++;
            }
            processed++;
            continue;  // 继续处理下一个包
        }

        // 检查是否模拟错误
        if (packet.shouldError || ShouldSimulateError())
        {
            // 记录错误统计
            {
                std::lock_guard<std::mutex> lock(m_statsMutex);
                m_stats.simulatedErrors++;
                m_stats.failedRounds++;
            }
            processed++;
            continue;  // 继续处理下一个包
        }

        // 将数据包移到接收队列
        {
            std::lock_guard<std::mutex> receiveLock(m_receiveQueueMutex);
            m_receiveQueue.push(packet);
            m_receiveCondition.notify_one();
        }

        // 更新统计
        {
            std::lock_guard<std::mutex> lock(m_statsMutex);
            m_stats.successfulRounds++;
        }

        processed++;
    }
}
```

**关键修改点**:
1. 添加批处理循环：`while (processed < BATCH_SIZE)`
2. 每次循环处理1个包，累计处理100个包
3. 队列为空时提前退出循环
4. 保持原有的延迟模拟、丢包模拟、错误模拟逻辑

**预期效果**:
- 吞吐量提升: 1000 pkt/s → 100000 pkt/s（100倍）
- CPU利用率: 降低（减少锁竞争次数）
- 延迟: 略微增加（批处理导致），但可接受

**验证方法**:
- 编译成功且无警告
- 运行主程序测试大文件传输
- 检查日志中"transport busy"错误数量（应为0）

**预计时间**: 10分钟

---

#### 任务A2: 消除线程休眠

**目标**: 移除1ms休眠瓶颈，进一步提升响应速度

**修改文件**: `Transport/LoopbackTransport.cpp`

**修改位置**: `LoopbackWorkerThread()` 函数（约第521-556行）

**修改前代码**:
```cpp
void LoopbackTransport::LoopbackWorkerThread()
{
    LogOperation("工作线程", "回路工作线程已启动");

    while (!m_stopLoopback)
    {
        try
        {
            ProcessSendQueue();
            ProcessReceiveQueue();
            UpdateStatistics();

            // 短暂休眠，避免过度占用CPU
            std::this_thread::sleep_for(std::chrono::milliseconds(1));  // ← 移除此行
        }
        catch (const std::exception &e)
        {
            NotifyError(TransportError::ConnectionClosed, "工作线程异常: " + std::string(e.what()));
            break;
        }
    }

    LogOperation("工作线程", "回路工作线程已停止");
}
```

**修改后代码**:
```cpp
void LoopbackTransport::LoopbackWorkerThread()
{
    LogOperation("工作线程", "回路工作线程已启动");

    while (!m_stopLoopback)
    {
        try
        {
            ProcessSendQueue();
            ProcessReceiveQueue();
            UpdateStatistics();

            // 【P0二次修复】移除1ms休眠，改为yield让出CPU时间片
            // 批量处理优化后，单次循环处理足够多的数据包，无需强制休眠
            std::this_thread::yield();
        }
        catch (const std::exception &e)
        {
            NotifyError(TransportError::ConnectionClosed, "工作线程异常: " + std::string(e.what()));
            break;
        }
    }

    LogOperation("工作线程", "回路工作线程已停止");
}
```

**关键修改点**:
1. 移除: `std::this_thread::sleep_for(std::chrono::milliseconds(1))`
2. 添加: `std::this_thread::yield()`
3. 添加注释说明修改原因

**yield() vs sleep_for() vs 完全移除**:

| 方案 | CPU占用 | 响应速度 | 适用场景 |
|------|---------|----------|----------|
| sleep_for(1ms) | 低 | 慢（1ms延迟） | 原有实现 |
| yield() | 中 | 快 | **推荐方案** |
| 完全移除 | 高 | 极快 | 仅测试环境 |

**选择yield()的原因**:
- 不强制休眠，但主动让出CPU时间片
- 避免完全移除导致的100% CPU占用
- 在高负载时仍能给其他线程执行机会
- 符合工程最佳实践

**预期效果**:
- 响应速度: 1ms延迟 → 微秒级
- CPU占用: 可控（不会100%占用单核）
- 吞吐量: 进一步提升（消除累积延迟）

**验证方法**:
- 编译成功且无警告
- 运行主程序，观察CPU占用率（应在合理范围）
- 验证大文件传输正常完成

**预计时间**: 5分钟

---

#### 任务A3: 扩大队列容量

**目标**: 进一步增大缓冲区，应对极端突发流量

**修改文件**: `Transport/LoopbackTransport.h`

**修改位置**: `LoopbackConfig` 结构体（约第13-32行）

**修改前代码**:
```cpp
// 回路传输配置
struct LoopbackConfig : public TransportConfig
{
    uint32_t delayMs = 0;               // 【P0修复】移除模拟延迟，避免握手超时（原值10ms）
    uint32_t errorRate = 0;             // 错误率(0-100%)
    uint32_t packetLossRate = 0;        // 丢包率(0-100%)
    bool enableJitter = false;          // 启用抖动模拟
    uint32_t jitterMaxMs = 5;           // 最大抖动时间(ms)
    uint32_t maxQueueSize = 50000;      // 【P0修复】扩大队列容量支持大文件传输（原值10000）
    bool enableLogging = true;          // 启用详细日志

    LoopbackConfig()
    {
        portName = "LOOPBACK";
        readTimeout = 1000;
        writeTimeout = 1000;
        bufferSize = 4096;
        asyncMode = true;
    }
};
```

**修改后代码**:
```cpp
// 回路传输配置
struct LoopbackConfig : public TransportConfig
{
    uint32_t delayMs = 0;               // 【P0修复】移除模拟延迟，避免握手超时（原值10ms）
    uint32_t errorRate = 0;             // 错误率(0-100%)
    uint32_t packetLossRate = 0;        // 丢包率(0-100%)
    bool enableJitter = false;          // 启用抖动模拟
    uint32_t jitterMaxMs = 5;           // 最大抖动时间(ms)
    uint32_t maxQueueSize = 100000;     // 【P0二次修复】进一步扩大队列容量（50000→100000）
    bool enableLogging = true;          // 启用详细日志

    LoopbackConfig()
    {
        portName = "LOOPBACK";
        readTimeout = 1000;
        writeTimeout = 1000;
        bufferSize = 4096;
        asyncMode = true;
    }
};
```

**关键修改点**:
1. maxQueueSize: 50000 → 100000
2. 更新注释：说明这是第二次P0修复

**队列容量选择依据**:

| 文件大小 | 帧数量（1KB/帧） | 队列需求（×2安全系数） | 推荐容量 |
|---------|-----------------|----------------------|---------|
| 1MB | 1024 | 2048 | 10000 ✓ |
| 10MB | 10240 | 20480 | 50000 ✓ |
| 50MB | 51200 | 102400 | **100000** ← 当前目标 |
| 100MB | 102400 | 204800 | 需要进一步扩大 |

**内存占用估算**:
- 每个packet: 约1KB数据 + 结构体开销
- 100000个packet: 约100MB内存占用
- 对于现代系统（>=4GB内存）: 完全可接受

**预期效果**:
- 支持更大文件传输（50MB+）
- 突发流量缓冲能力提升
- "transport busy"错误进一步减少

**验证方法**:
- 编译成功且无警告
- 运行主程序测试超大文件（如果有）
- 观察队列深度统计（不应达到上限）

**预计时间**: 3分钟

---

#### 任务A4: 编译验证

**目标**: 确保本地回路性能优化后代码质量

**执行步骤**:
```bash
# 1. 切换到项目目录
cd /mnt/c/Users/huangl/Desktop/PortMaster

# 2. 清理旧的编译输出（可选）
# rm -rf build/Debug/*.obj

# 3. 执行编译
cmd.exe /c "autobuild_x86_debug.bat"

# 4. 检查编译结果
# 期望输出：
# ========================================
# Build Result: SUCCESS
# ========================================
# Errors:   0
# Warnings: 0
```

**成功标准**:
- ✅ Errors: 0
- ✅ Warnings: 0
- ✅ 生成文件: `build/Debug/PortMaster.exe`

**失败处理**:
- 如果出现编译错误：仔细检查代码修改，修复语法错误
- 如果出现警告：根据警告类型决定是否需要修复（C4819编码警告可忽略）

**预计时间**: 5分钟

---

#### 任务A5: 生成P0二次修复报告

**目标**: 记录第二次P0修复的技术细节和效果验证

**报告文件**: `本地回路性能优化P0二次修复报告-YYYYMMDD-HHMMSS.md`

**报告结构**:
```markdown
# 本地回路性能优化 P0二次修复报告

## 修复概述
- 修复时间: YYYY-MM-DD HH:MM:SS
- 修复目标: 消除活锁，实现大文件传输正常完成
- 修复方案: 批量处理 + 消除休眠 + 扩大队列

## 问题回顾
### 第一次P0修复后的残留问题
- 工作线程吞吐量: 1000 pkt/s
- 发送速度: 5000+ pkt/s
- 结果: 队列溢出，197次"transport busy"错误

## 修复方案详解
### 方案1: 批量处理优化
- 修改文件: LoopbackTransport.cpp
- 修改函数: ProcessSendQueue()
- 关键修改: 1个包/次 → 100个包/次
- 预期提升: 100倍吞吐量

### 方案2: 消除线程休眠
- 修改文件: LoopbackTransport.cpp
- 修改函数: LoopbackWorkerThread()
- 关键修改: sleep_for(1ms) → yield()
- 预期效果: 消除1ms累积延迟

### 方案3: 扩大队列容量
- 修改文件: LoopbackTransport.h
- 修改配置: maxQueueSize 50000 → 100000
- 预期效果: 支持更大文件传输

## 编译验证
- 编译结果: 0 error 0 warning
- 编译时间: XX秒
- 生成文件: build/Debug/PortMaster.exe

## 功能测试
### 测试场景: 本地回路 + 可靠模式 + 大文件
- 测试文件: test_input.pdf (1.1MB)
- 传输结果: 成功/失败
- "transport busy"错误数: XX次（期望0次）
- 传输时间: XX秒

## 技术总结
- 问题根源: 工作线程处理速度 << 发送速度
- 修复策略: 批量处理提升吞吐量 + 消除延迟瓶颈
- 最终效果: 活锁问题完全解决，大文件传输正常
```

**预计时间**: 不计入（与测试并行）

---

### 任务组B: AutoTest工具P0修复

#### 任务B1: 修复文件路径错误

**目标**: 解决文件无法打开的P0阻塞性问题

**修改文件**: `AutoTest/main.cpp`

**修改位置**: `main()` 函数开头（约第157-179行）

**修改前代码**:
```cpp
int main()
{
    cout << "======================================" << endl;
    cout << "Automated Reliable Transmission Test" << endl;
    cout << "======================================" << endl;
    cout << endl;

    // 测试配置 - 使用ASCII文件名避免编码问题
    wstring inputFileWide = L"test_input.pdf";
    string outputFile = "test_received.pdf";
    string tempFile = "test_temp.bin";
    string inputFileWin_display = "test_input.pdf";

    // 步骤1: 读取测试文件
    cout << "[STEP 1/8] Reading test file..." << endl;
    cout << "Input: " << inputFileWin_display << endl;

    vector<uint8_t> originalData;
    if (!ReadFileW(inputFileWide, originalData))
    {
        return 1;
    }
    cout << endl;
```

**修改后代码**:
```cpp
int main()
{
    cout << "======================================" << endl;
    cout << "Automated Reliable Transmission Test" << endl;
    cout << "======================================" << endl;
    cout << endl;

    // 【P0修复】获取程序所在目录，构建绝对路径
    wchar_t exePath[MAX_PATH];
    GetModuleFileNameW(NULL, exePath, MAX_PATH);
    wstring exeDir = exePath;
    exeDir = exeDir.substr(0, exeDir.find_last_of(L"\\"));

    // 测试配置 - 使用绝对路径避免路径错误
    wstring inputFileWide = exeDir + L"\\test_input.pdf";
    wstring outputFileWide = exeDir + L"\\test_received.pdf";
    wstring tempFileWide = exeDir + L"\\test_temp.bin";

    // 转换为窄字符串（用于非Unicode API）
    string outputFile = "test_received.pdf";
    string tempFile = "test_temp.bin";

    // 步骤1: 读取测试文件
    cout << "[STEP 1/8] Reading test file..." << endl;
    wcout << L"Input: " << inputFileWide << endl;  // 使用wcout输出宽字符串

    vector<uint8_t> originalData;
    if (!ReadFileW(inputFileWide, originalData))
    {
        return 1;
    }
    cout << endl;
```

**关键修改点**:
1. 添加 `GetModuleFileNameW()` 获取程序路径
2. 提取程序所在目录: `exeDir`
3. 构建绝对路径: `exeDir + L"\\test_input.pdf"`
4. 使用 `wcout` 输出宽字符串路径（避免显示错误）

**验证方法**:
- 编译 `AutoTest.exe` 成功
- 运行后输出路径正确（如: `C:\Users\huangl\Desktop\PortMaster\AutoTest\test_input.pdf`）
- 文件成功读取

**预计时间**: 10分钟

---

#### 任务B2: 添加直通模式测试函数

**目标**: 实现直通传输模式测试，补齐缺失的50%测试覆盖

**修改文件**: `AutoTest/main.cpp`

**修改位置**: 在 `main()` 函数之前添加新函数

**新增函数**:
```cpp
// 【P0修复】直通模式测试函数
bool TestPassthroughMode(const wstring& inputFile, const wstring& outputFile)
{
    cout << endl;
    cout << "======================================" << endl;
    cout << "TEST MODE: Passthrough (Direct)" << endl;
    cout << "======================================" << endl;
    cout << endl;

    // 步骤1: 读取测试文件
    cout << "[STEP 1/6] Reading test file..." << endl;
    wcout << L"Input: " << inputFile << endl;

    vector<uint8_t> originalData;
    if (!ReadFileW(inputFile, originalData))
    {
        cerr << "[ERROR] Failed to read input file" << endl;
        return false;
    }
    cout << "[OK] Read file: " << originalData.size() << " bytes" << endl;
    cout << endl;

    // 步骤2: 创建本地回路传输层
    cout << "[STEP 2/6] Creating Loopback transport..." << endl;

    auto transport = make_shared<LoopbackTransport>();
    TransportConfig transportConfig;

    if (transport->Open(transportConfig) != TransportError::Success)
    {
        cerr << "[ERROR] Failed to open transport" << endl;
        return false;
    }

    cout << "[OK] Loopback transport created" << endl;
    cout << endl;

    // 步骤3: 启动接收线程
    cout << "[STEP 3/6] Starting receive thread..." << endl;

    atomic<bool> recvStarted(false);
    atomic<bool> recvCompleted(false);
    atomic<bool> recvFailed(false);
    vector<uint8_t> receivedData;

    thread recvThread([&]() {
        recvStarted = true;
        cout << "[RECV] Receive thread started" << endl;

        size_t totalReceived = 0;
        const size_t expectedSize = originalData.size();

        while (totalReceived < expectedSize && !recvFailed)
        {
            uint8_t buffer[1024];
            size_t received = 0;

            // 直接调用传输层Receive（不经过ReliableChannel）
            TransportError err = transport->Read(buffer, sizeof(buffer), &received, 5000);

            if (err == TransportError::Success && received > 0)
            {
                receivedData.insert(receivedData.end(), buffer, buffer + received);
                totalReceived += received;

                // 进度显示
                static size_t last = 0;
                if (totalReceived - last >= 50000 || totalReceived == expectedSize)
                {
                    printf("[RECV] %zu / %zu (%.1f%%)\r",
                           totalReceived, expectedSize,
                           totalReceived * 100.0 / expectedSize);
                    last = totalReceived;
                    if (totalReceived == expectedSize) printf("\n");
                }
            }
            else if (err == TransportError::Timeout)
            {
                // 超时但继续等待
                continue;
            }
            else
            {
                cerr << "[RECV] Receive error: " << (int)err << endl;
                recvFailed = true;
                break;
            }
        }

        if (!recvFailed && totalReceived == expectedSize)
        {
            cout << "[RECV] Receive completed successfully" << endl;
            recvCompleted = true;
        }
    });

    // 等待接收线程启动
    while (!recvStarted)
    {
        this_thread::sleep_for(chrono::milliseconds(100));
    }
    cout << "[OK] Receive thread ready" << endl;
    cout << endl;

    // 步骤4: 发送文件数据
    cout << "[STEP 4/6] Sending file..." << endl;

    size_t sent = 0;
    const size_t chunkSize = 1024;

    while (sent < originalData.size())
    {
        size_t toSend = min(chunkSize, originalData.size() - sent);
        size_t written = 0;

        // 直接调用传输层Send（不经过ReliableChannel）
        TransportError err = transport->Write(originalData.data() + sent, toSend, &written);

        if (err != TransportError::Success || written != toSend)
        {
            cerr << "[ERROR] Send failed at offset " << sent << endl;
            recvFailed = true;
            recvThread.join();
            return false;
        }

        sent += written;

        // 进度显示
        static size_t last = 0;
        if (sent - last >= 50000 || sent == originalData.size())
        {
            printf("[SEND] %zu / %zu (%.1f%%)\r",
                   sent, originalData.size(),
                   sent * 100.0 / originalData.size());
            last = sent;
            if (sent == originalData.size()) printf("\n");
        }
    }

    cout << "[OK] Send completed" << endl;
    cout << endl;

    // 步骤5: 等待接收完成
    cout << "[STEP 5/6] Waiting for receive to complete..." << endl;

    recvThread.join();

    if (recvFailed || !recvCompleted)
    {
        cerr << "[ERROR] Receive failed or incomplete" << endl;
        return false;
    }

    cout << "[OK] Receive completed" << endl;
    cout << endl;

    // 步骤6: 验证文件
    cout << "[STEP 6/6] Verifying file..." << endl;

    cout << "Original size: " << originalData.size() << " bytes" << endl;
    cout << "Received size: " << receivedData.size() << " bytes" << endl;

    if (receivedData.size() != originalData.size())
    {
        cerr << "[FAIL] Size mismatch!" << endl;
        return false;
    }

    if (receivedData != originalData)
    {
        cerr << "[FAIL] Content mismatch!" << endl;
        return false;
    }

    cout << "[OK] File verified - perfect match" << endl;

    // 保存接收文件
    if (!WriteFileW(outputFile, receivedData))
    {
        cerr << "[ERROR] Failed to save received file" << endl;
        return false;
    }

    cout << endl;
    cout << "======================================" << endl;
    cout << "PASSTHROUGH TEST PASSED" << endl;
    cout << "======================================" << endl;

    // 清理
    transport->Close();

    return true;
}
```

**关键设计点**:
1. **直接调用传输层API**: `transport->Read()` 和 `transport->Write()`，不经过 `ReliableChannel`
2. **异步收发模型**: 接收线程 + 主线程发送，与主程序一致
3. **进度报告**: 与可靠模式测试保持一致的进度显示
4. **超时处理**: 接收超时5秒，但继续等待（避免误判）
5. **完整验证**: 大小验证 + 逐字节内容验证

**与可靠模式的关键区别**:
- 直通模式: 调用 `ITransport::Read/Write`
- 可靠模式: 调用 `ReliableChannel::SendFile/ReceiveFile`

**预计时间**: 20分钟

---

#### 任务B3: 重构main()函数为双模式测试

**目标**: 将现有可靠模式测试代码重构为独立函数，main()统筹两个测试

**修改文件**: `AutoTest/main.cpp`

**步骤1: 创建可靠模式测试函数**

将现有 `main()` 的第170-349行代码移动到新函数:

```cpp
// 【P0修复】可靠模式测试函数（重构现有代码）
bool TestReliableMode(const wstring& inputFile, const wstring& outputFile)
{
    cout << endl;
    cout << "======================================" << endl;
    cout << "TEST MODE: Reliable Transmission" << endl;
    cout << "======================================" << endl;
    cout << endl;

    // 步骤1: 读取测试文件
    cout << "[STEP 1/8] Reading test file..." << endl;
    wcout << L"Input: " << inputFile << endl;

    vector<uint8_t> originalData;
    if (!ReadFileW(inputFile, originalData))
    {
        return false;
    }
    cout << endl;

    // ... 后续步骤与现有main()代码完全相同 ...
    // （第182-342行代码完整复制，仅修改文件路径变量名）

    return true;
}
```

**步骤2: 重写main()函数**

```cpp
int main()
{
    cout << "======================================" << endl;
    cout << "PortMaster Automated Test Suite" << endl;
    cout << "Version: 2.0 (Dual-Mode Testing)" << endl;
    cout << "======================================" << endl;
    cout << endl;

    // 【P0修复】获取程序所在目录
    wchar_t exePath[MAX_PATH];
    GetModuleFileNameW(NULL, exePath, MAX_PATH);
    wstring exeDir = exePath;
    exeDir = exeDir.substr(0, exeDir.find_last_of(L"\\"));

    // 测试配置
    wstring inputFile = exeDir + L"\\test_input.pdf";
    wstring passthroughOutput = exeDir + L"\\test_passthrough.pdf";
    wstring reliableOutput = exeDir + L"\\test_reliable.pdf";

    // 测试统计
    int testsPassed = 0;
    int testsFailed = 0;

    // 测试1: 直通模式
    cout << "========================================" << endl;
    cout << "Running Test 1/2: Passthrough Mode" << endl;
    cout << "========================================" << endl;

    if (TestPassthroughMode(inputFile, passthroughOutput))
    {
        testsPassed++;
        cout << "[Result] Passthrough Mode: PASSED" << endl;
    }
    else
    {
        testsFailed++;
        cerr << "[Result] Passthrough Mode: FAILED" << endl;
    }

    // 短暂延迟（避免资源竞争）
    this_thread::sleep_for(chrono::milliseconds(500));

    // 测试2: 可靠模式
    cout << endl;
    cout << "========================================" << endl;
    cout << "Running Test 2/2: Reliable Mode" << endl;
    cout << "========================================" << endl;

    if (TestReliableMode(inputFile, reliableOutput))
    {
        testsPassed++;
        cout << "[Result] Reliable Mode: PASSED" << endl;
    }
    else
    {
        testsFailed++;
        cerr << "[Result] Reliable Mode: FAILED" << endl;
    }

    // 最终测试摘要
    cout << endl;
    cout << "======================================" << endl;
    cout << "TEST SUMMARY" << endl;
    cout << "======================================" << endl;
    cout << "Total tests:  2" << endl;
    cout << "Passed:       " << testsPassed << endl;
    cout << "Failed:       " << testsFailed << endl;
    cout << "Success rate: " << (testsPassed * 100 / 2) << "%" << endl;
    cout << "======================================" << endl;

    if (testsFailed > 0)
    {
        cout << endl;
        cout << "OVERALL RESULT: FAILED" << endl;
        cout << "Please check the error messages above." << endl;
        return 1;
    }
    else
    {
        cout << endl;
        cout << "OVERALL RESULT: ALL TESTS PASSED" << endl;
        cout << "Both passthrough and reliable modes are working correctly." << endl;
        return 0;
    }
}
```

**关键设计点**:
1. 统一的测试摘要输出
2. 清晰的测试结果显示
3. 返回值: 0=全部通过，1=存在失败
4. 两个测试之间添加500ms延迟（避免资源竞争）

**预计时间**: 15分钟

---

#### 任务B4: 编译验证（AutoTest）

**目标**: 确保AutoTest工具修改后编译成功

**执行步骤**:
```bash
# 1. 切换到AutoTest目录
cd /mnt/c/Users/huangl/Desktop/PortMaster/AutoTest

# 2. 执行编译脚本
cmd.exe /c "build.bat"

# 3. 检查编译结果
# 期望输出：
# ========================================
# Build Complete: AutoTest.exe
# ========================================
```

**成功标准**:
- ✅ 编译成功（无错误）
- ✅ 警告可接受（C4819编码警告）
- ✅ 生成文件: `AutoTest.exe`

**预计时间**: 5分钟

---

#### 任务B5: 功能测试（AutoTest）

**目标**: 验证两种模式测试均能正常通过

**执行步骤**:
```bash
# 1. 确保test_input.pdf存在
ls -lh test_input.pdf

# 2. 运行AutoTest.exe
./AutoTest.exe

# 3. 检查测试输出
# 期望输出：
# ========================================
# Running Test 1/2: Passthrough Mode
# ========================================
# ... 测试过程 ...
# PASSTHROUGH TEST PASSED
#
# ========================================
# Running Test 2/2: Reliable Mode
# ========================================
# ... 测试过程 ...
# RELIABLE TEST PASSED
#
# ========================================
# TEST SUMMARY
# ========================================
# Total tests:  2
# Passed:       2
# Failed:       0
# Success rate: 100%
# ========================================
# OVERALL RESULT: ALL TESTS PASSED

# 4. 验证生成的文件
ls -lh test_passthrough.pdf test_reliable.pdf

# 5. 比对文件完整性（可选）
diff test_input.pdf test_passthrough.pdf
diff test_input.pdf test_reliable.pdf
```

**成功标准**:
- ✅ 两个测试均通过
- ✅ 生成 `test_passthrough.pdf` 和 `test_reliable.pdf`
- ✅ 文件与 `test_input.pdf` 完全一致

**失败处理**:
- 如果直通模式失败：检查 `ITransport::Read/Write` 调用是否正确
- 如果可靠模式失败：参考第一次P0修复，检查握手和传输流程
- 如果文件不一致：检查数据验证逻辑

**预计时间**: 10分钟

---

## Phase 2: P1重要修复（可选）

### 任务C1: 添加日志文件保存

**目标**: 双重输出到控制台和日志文件，便于问题追溯

**修改文件**: `AutoTest/main.cpp`

**修改位置**: 文件头部（在全局变量区域）

**新增代码**:
```cpp
// 【P1修复】全局日志文件
ofstream g_logFile;

// 日志宏定义
#define LOG_INFO(msg) do { \
    cout << msg << endl; \
    if (g_logFile.is_open()) g_logFile << msg << endl; \
} while(0)

#define LOG_ERROR(msg) do { \
    cerr << msg << endl; \
    if (g_logFile.is_open()) g_logFile << "[ERROR] " << msg << endl; \
} while(0)
```

**修改main()函数**:
```cpp
int main()
{
    // 【P1修复】打开日志文件
    g_logFile.open("test_log.txt");
    if (!g_logFile.is_open())
    {
        cerr << "[WARNING] Failed to open log file, logging to console only" << endl;
    }

    // ... 原有测试代码 ...

    // 【P1修复】关闭日志文件
    if (g_logFile.is_open())
    {
        g_logFile.close();
    }

    return 0;
}
```

**使用方法**:
将所有 `cout` 替换为 `LOG_INFO`，将 `cerr` 替换为 `LOG_ERROR`。

**建议**: 由于替换工作量较大，可以仅在关键位置使用：
- 测试开始/结束
- 错误发生位置
- 测试摘要输出

**预计时间**: 10分钟

---

### 任务C2: 移除统计信息显示

**目标**: 符合用户"不添加额外功能"的要求

**修改文件**: `AutoTest/main.cpp`（可靠模式测试函数）

**修改位置**: 约第331-339行（重构后在TestReliableMode()函数内）

**修改前代码**:
```cpp
// 步骤9: 显示统计
cout << "[STEP 9/9] Statistics..." << endl;

ReliableStats stats = reliableChannel->GetStats();

cout << "Packets sent:         " << stats.packetsSent << endl;
cout << "Packets retransmitted:" << stats.packetsRetransmitted << endl;
cout << "Packets received:     " << stats.packetsReceived << endl;
cout << "Total errors:         " << stats.errors << endl;
cout << endl;
```

**修改后代码**:
```cpp
// 【P1修复】移除统计信息显示，符合用户"不添加额外功能"要求
// 如果需要调试，可临时取消注释
/*
cout << "[STEP 9/9] Statistics..." << endl;
ReliableStats stats = reliableChannel->GetStats();
cout << "Packets sent:         " << stats.packetsSent << endl;
cout << "Packets retransmitted:" << stats.packetsRetransmitted << endl;
cout << "Packets received:     " << stats.packetsReceived << endl;
cout << "Total errors:         " << stats.errors << endl;
cout << endl;
*/
```

**预计时间**: 2分钟

---

### 任务C3: 编译验证（P1修复后）

**执行步骤**: 同任务B4

**预计时间**: 3分钟

---

## Phase 3: 版本控制与文档

### 任务D1: 暂存所有变更

**执行命令**:
```bash
cd /mnt/c/Users/huangl/Desktop/PortMaster
git add -A
```

**验证**:
```bash
git status
# 应显示所有修改的文件：
# modified:   Transport/LoopbackTransport.h
# modified:   Transport/LoopbackTransport.cpp
# modified:   AutoTest/main.cpp
# new file:   本地回路性能优化P0二次修复报告-YYYYMMDD-HHMMSS.md
```

**预计时间**: 1分钟

---

### 任务D2: 生成提交信息并提交

**提交信息格式**:
```
fix: P0二次修复-本地回路性能优化+AutoTest双模式测试

【本地回路性能优化】
- 批量处理: ProcessSendQueue处理1个包→100个包，吞吐量提升100倍
- 消除休眠: LoopbackWorkerThread移除1ms休眠，改为yield()
- 扩大队列: maxQueueSize从50000扩大到100000

【AutoTest工具修复】
- 修复文件路径错误: 使用GetModuleFileName获取程序目录
- 添加直通模式测试: 新增TestPassthroughMode()函数
- 重构为双模式测试: main()统筹直通+可靠两个测试

【验证结果】
- 编译: 0 error 0 warning
- AutoTest: 2/2测试通过（直通模式+可靠模式）
- 本地回路: "transport busy"错误0次，大文件传输正常

【符合设计原则】
- KISS: 批量处理逻辑简洁明了
- DRY: 测试函数复用相同的文件验证逻辑
- SOLID-S: 测试函数单一职责，main()仅负责统筹
```

**执行命令**:
```bash
git commit -m "fix: P0二次修复-本地回路性能优化+AutoTest双模式测试

【本地回路性能优化】
- 批量处理: ProcessSendQueue处理1个包→100个包，吞吐量提升100倍
- 消除休眠: LoopbackWorkerThread移除1ms休眠，改为yield()
- 扩大队列: maxQueueSize从50000扩大到100000

【AutoTest工具修复】
- 修复文件路径错误: 使用GetModuleFileName获取程序目录
- 添加直通模式测试: 新增TestPassthroughMode()函数
- 重构为双模式测试: main()统筹直通+可靠两个测试

【验证结果】
- 编译: 0 error 0 warning
- AutoTest: 2/2测试通过（直通模式+可靠模式）
- 本地回路: \"transport busy\"错误0次，大文件传输正常

【符合设计原则】
- KISS: 批量处理逻辑简洁明了
- DRY: 测试函数复用相同的文件验证逻辑
- SOLID-S: 测试函数单一职责，main()仅负责统筹
"
```

**预计时间**: 3分钟

---

### 任务D3: 推送到远程仓库

**执行命令**:
```bash
# 推送到主要远程仓库
git push PortMaster HEAD

# 推送到备份远程仓库（如果配置）
git remote | grep -q backup && git push backup HEAD
```

**成功标准**:
- ✅ 推送成功，无冲突
- ✅ 远程仓库显示最新提交

**失败处理**:
- 如果有合并冲突：执行 `git pull --rebase` 后重新推送
- 如果远程仓库不可访问：检查网络连接和Git配置

**预计时间**: 2分钟

---

### 任务D4: 更新修订工作记录（可选）

**目标**: 在当前会话的修订记录中补充最终结果

**执行步骤**:
1. 打开修订记录文件（如果存在）
2. 在"修订执行记录"部分追加最终结果
3. 填写"技术总结"部分

**内容示例**:
```markdown
## 修订执行记录

### P0二次修复完成情况

**任务组A: 本地回路性能优化**
- ✅ A1. 批量处理优化 - 完成，吞吐量提升100倍
- ✅ A2. 消除线程休眠 - 完成，改为yield()
- ✅ A3. 扩大队列容量 - 完成，100000容量
- ✅ A4. 编译验证 - 通过，0 error 0 warning
- ✅ A5. 功能测试 - 通过，无"transport busy"错误

**任务组B: AutoTest工具修复**
- ✅ B1. 修复文件路径 - 完成，使用绝对路径
- ✅ B2. 添加直通模式 - 完成，TestPassthroughMode()函数
- ✅ B3. 重构main() - 完成，双模式测试框架
- ✅ B4. 编译验证 - 通过，AutoTest.exe生成成功
- ✅ B5. 功能测试 - 通过，2/2测试通过

## 技术总结

### 本地回路性能优化关键技术

1. **批量处理算法**
   - 原理: 减少锁竞争次数，提高单位时间处理包数量
   - 实现: while循环处理100个包
   - 效果: 吞吐量从1000 pkt/s提升到100000+ pkt/s

2. **线程休眠策略**
   - 原理: sleep_for(1ms)强制休眠导致累积延迟
   - 优化: 改为yield()主动让出CPU时间片
   - 效果: 响应速度显著提升，CPU占用可控

3. **队列容量设计**
   - 原理: 缓冲区大小直接影响突发流量承受能力
   - 扩容: 50000 → 100000（2倍）
   - 效果: 支持更大文件传输，降低溢出风险

### AutoTest工具架构重构要点

1. **文件路径管理**
   - 问题: 相对路径依赖当前工作目录
   - 解决: GetModuleFileName()获取程序目录
   - 优势: 跨环境移植性好，路径明确

2. **双模式测试框架**
   - 架构: main()统筹 → TestPassthroughMode() / TestReliableMode()
   - 优势: 单一职责，可扩展性强
   - 符合: SOLID-S原则、DRY原则

3. **测试覆盖率提升**
   - 修复前: 50%（仅可靠模式）
   - 修复后: 100%（直通+可靠模式）
   - 价值: 能够发现直通模式下的潜在bug

### 经验总结

1. **性能问题诊断方法**
   - 日志分析: 观察"transport busy"频率
   - 瓶颈定位: 对比发送速度与处理速度
   - 量化验证: 计算理论吞吐量并与实际对比

2. **测试工具设计原则**
   - 行为一致性: 与主程序保持一致的执行流程
   - 覆盖完整性: 测试所有用户可操作的模式
   - 独立可复现: 不依赖外部环境配置

3. **代码质量保证**
   - 编译零容忍: 0 error 0 warning强制要求
   - 功能完整验证: 端到端测试通过
   - 设计原则遵循: SOLID、KISS、DRY、YAGNI
```

**预计时间**: 不计入（可选任务）

---

## 任务执行检查清单

### Phase 1: P0紧急修复

**任务组A: 本地回路性能优化**
- [ ] A1. 批量处理优化（LoopbackTransport.cpp）
- [ ] A2. 消除线程休眠（LoopbackTransport.cpp）
- [ ] A3. 扩大队列容量（LoopbackTransport.h）
- [ ] A4. 编译验证（0 error 0 warning）
- [ ] A5. 生成P0二次修复报告

**任务组B: AutoTest工具P0修复**
- [ ] B1. 修复文件路径错误（main.cpp）
- [ ] B2. 添加直通模式测试函数（main.cpp）
- [ ] B3. 重构main()函数为双模式测试（main.cpp）
- [ ] B4. 编译验证（AutoTest.exe）
- [ ] B5. 功能测试（两种模式均通过）

### Phase 2: P1重要修复（可选）

- [ ] C1. 添加日志文件保存（AutoTest/main.cpp）
- [ ] C2. 移除统计信息显示（AutoTest/main.cpp）
- [ ] C3. 编译验证

### Phase 3: 版本控制与文档

- [ ] D1. 暂存所有变更（git add -A）
- [ ] D2. 生成提交信息并提交
- [ ] D3. 推送到远程仓库
- [ ] D4. 更新修订工作记录（可选）

---

## 完成标准

### 编译标准
- ✅ 主程序编译: 0 error 0 warning
- ✅ AutoTest编译: 0 error 0 warning（C4819编码警告可接受）

### 功能标准
- ✅ AutoTest双模式测试: 2/2通过
- ✅ 主程序大文件传输: 正常完成，无超时
- ✅ 本地回路性能: 无"transport busy"错误

### 质量标准
- ✅ 代码符合SOLID原则
- ✅ 代码符合KISS原则（简洁明了）
- ✅ 代码符合DRY原则（无重复逻辑）
- ✅ 文档完整（修复报告、提交信息、修订记录）

---

## 风险与应对

### 风险1: 批量处理导致延迟增加

**风险描述**: 批量处理100个包可能导致单个包的延迟增加

**影响评估**: 低（本地回路测试环境，延迟增加可接受）

**应对措施**:
- 监控实际传输时间
- 如果延迟过大，调整批量大小（100 → 50）

### 风险2: AutoTest直通模式测试失败

**风险描述**: 直通模式测试可能因为LoopbackTransport实现问题而失败

**影响评估**: 中（可能需要调整超时或重试逻辑）

**应对措施**:
- 增加接收超时时间（5秒 → 10秒）
- 添加调试日志输出
- 参考主程序的RawTransmissionTask实现

### 风险3: 编译警告增加

**风险描述**: 代码修改可能引入新的编译警告

**影响评估**: 低（不影响功能，但需要处理）

**应对措施**:
- 逐一检查警告类型
- C4819编码警告: 可接受
- 其他警告: 必须修复

---

## 附录

### 附录A: 相关文档索引

- `PortMaster综合审核报告-20251001-224901.md` - 完整审核结果
- `本地回路可靠传输宕机P0修复报告-20251001-125805.md` - 第一次P0修复
- `CLAUDE.md` - 项目架构说明

### 附录B: 关键函数签名

```cpp
// LoopbackTransport.cpp
void LoopbackTransport::ProcessSendQueue();
void LoopbackTransport::LoopbackWorkerThread();

// AutoTest/main.cpp
bool TestPassthroughMode(const wstring& inputFile, const wstring& outputFile);
bool TestReliableMode(const wstring& inputFile, const wstring& outputFile);
int main();
```

### 附录C: 测试数据

**测试文件**: `AutoTest/test_input.pdf`
- 大小: 1.1MB (1,153,433 字节)
- 类型: PDF文档
- 用途: 直通模式和可靠模式测试

**预期生成文件**:
- `AutoTest/test_passthrough.pdf` - 直通模式接收文件
- `AutoTest/test_reliable.pdf` - 可靠模式接收文件

**验证方法**:
```bash
# 文件大小验证
ls -lh AutoTest/test_*.pdf

# 内容完整性验证
diff AutoTest/test_input.pdf AutoTest/test_passthrough.pdf
diff AutoTest/test_input.pdf AutoTest/test_reliable.pdf
```

---

**计划结束**

**下一步**: 等待用户确认计划，获得批准后开始执行修复任务。
