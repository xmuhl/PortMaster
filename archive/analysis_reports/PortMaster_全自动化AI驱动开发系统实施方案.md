# PortMasterå…¨è‡ªåŠ¨åŒ–AIé©±åŠ¨å¼€å‘ç³»ç»Ÿå®æ–½æ–¹æ¡ˆ

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¥æœŸ**: 2025-10-02
**é€‚ç”¨é¡¹ç›®**: PortMasterï¼ˆç«¯å£å¤§å¸ˆï¼‰æ‰“å°æœºç ”å‘è¾…åŠ©å·¥å…·
**æ ¸å¿ƒç›®æ ‡**: å®ç°"è‡ªåŠ¨ç¼–å†™ä»£ç â†’è‡ªåŠ¨æµ‹è¯•éªŒè¯â†’è‡ªåŠ¨ä¿®è®¢â†’è‡ªåŠ¨æäº¤"çš„å…¨è‡ªåŠ¨è¿­ä»£å¼€å‘æµç¨‹

---

## ğŸ“‹ ç›®å½•

1. [ç³»ç»Ÿæ¶æ„è®¾è®¡](#1-ç³»ç»Ÿæ¶æ„è®¾è®¡)
2. [åˆ†å±‚è‡ªåŠ¨åŒ–æµ‹è¯•ç­–ç•¥](#2-åˆ†å±‚è‡ªåŠ¨åŒ–æµ‹è¯•ç­–ç•¥)
3. [æ™ºèƒ½è‡ªåŠ¨ä¿®å¤ç³»ç»Ÿ](#3-æ™ºèƒ½è‡ªåŠ¨ä¿®å¤ç³»ç»Ÿ)
4. [è´¨é‡ä¿è¯ä½“ç³»](#4-è´¨é‡ä¿è¯ä½“ç³»)
5. [å…·ä½“å®æ–½è®¡åˆ’](#5-å…·ä½“å®æ–½è®¡åˆ’)
6. [æ‰§è¡ŒæŒ‡å—](#6-æ‰§è¡ŒæŒ‡å—)
7. [é™„å½•ï¼šå·¥å…·æ¸…å•](#7-é™„å½•å·¥å…·æ¸…å•)

---

## 1. ç³»ç»Ÿæ¶æ„è®¾è®¡

### 1.1 å…­é˜¶æ®µå…¨è‡ªåŠ¨åŒ–å¼€å‘æµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  å…¨è‡ªåŠ¨åŒ–å¼€å‘æµç¨‹                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

é˜¶æ®µ1: éœ€æ±‚åˆ†æ           é˜¶æ®µ2: æ¶æ„è®¾è®¡           é˜¶æ®µ3: ä»£ç å®ç°
   â†“                        â†“                        â†“
[AIç†è§£éœ€æ±‚]            [AIè®¾è®¡æ–¹æ¡ˆ]             [AIç¼–å†™ä»£ç ]
- è§£æéœ€æ±‚æ–‡æ¡£          - æ¨¡å—åˆ’åˆ†               - ç”Ÿæˆæºç 
- è¯†åˆ«åŠŸèƒ½ç‚¹            - æ¥å£è®¾è®¡               - éµå¾ªè§„èŒƒ
- æå–æµ‹è¯•åœºæ™¯          - æ•°æ®æµè®¾è®¡             - ç¼–ç å®ç°
   â†“                        â†“                        â†“
[è¾“å‡º]                  [è¾“å‡º]                   [è¾“å‡º]
- åŠŸèƒ½éœ€æ±‚æ¸…å•          - æ¶æ„è®¾è®¡æ–‡æ¡£           - æºä»£ç æ–‡ä»¶
- æµ‹è¯•ç”¨ä¾‹è§„æ ¼          - æ¥å£å®šä¹‰               - å•å…ƒæµ‹è¯•ä»£ç 
   â†“                        â†“                        â†“

é˜¶æ®µ4: è‡ªåŠ¨æµ‹è¯•           é˜¶æ®µ5: è‡ªåŠ¨ä¿®å¤           é˜¶æ®µ6: ç‰ˆæœ¬æäº¤
   â†“                        â†“                        â†“
[AIè®¾è®¡å¹¶æ‰§è¡Œæµ‹è¯•]      [AIè¯†åˆ«å¹¶ä¿®å¤]           [AIç®¡ç†ç‰ˆæœ¬]
- å•å…ƒæµ‹è¯•              - é”™è¯¯è¯Šæ–­               - Gitæäº¤
- é›†æˆæµ‹è¯•              - è‡ªåŠ¨ä¿®å¤               - æ¨é€è¿œç¨‹
- ç³»ç»Ÿæµ‹è¯•              - éªŒè¯æµ‹è¯•               - æ ‡ç­¾ç®¡ç†
   â†“                        â†“                        â†“
[è´¨é‡é—¨æ§›]              [ä¿®å¤å¾ªç¯]               [å®Œæˆ]
- ç¼–è¯‘0é”™è¯¯0è­¦å‘Š        - æœ€å¤š3æ¬¡è‡ªåŠ¨ä¿®å¤        - ç‰ˆæœ¬å½’æ¡£
- æµ‹è¯•è¦†ç›–ç‡>90%        - å¤±è´¥â†’äººå·¥ä»‹å…¥          - ç”ŸæˆæŠ¥å‘Š
```

### 1.2 å„é˜¶æ®µè¯¦ç»†å®šä¹‰

#### é˜¶æ®µ1: éœ€æ±‚åˆ†æï¼ˆAIä¸»å¯¼ï¼‰

**è¾“å…¥**:
- ç”¨æˆ·éœ€æ±‚æè¿°ï¼ˆè‡ªç„¶è¯­è¨€æˆ–éœ€æ±‚æ–‡æ¡£ï¼‰
- ç°æœ‰é¡¹ç›®æ–‡æ¡£ï¼ˆCLAUDE.md, é¡¹ç›®å¼€å‘.mdï¼‰
- å†å²é—®é¢˜è®°å½•

**AIå¤„ç†æµç¨‹**:
1. ä½¿ç”¨NLPè§£æç”¨æˆ·éœ€æ±‚
2. æ˜ å°„åˆ°ç°æœ‰æ¶æ„æ¨¡å—
3. è¯†åˆ«æ–°åŠŸèƒ½ã€ä¿®æ”¹åŠŸèƒ½ã€Bugä¿®å¤
4. ç”Ÿæˆæµ‹è¯•åœºæ™¯æ¸…å•

**è¾“å‡º**:
- `éœ€æ±‚åˆ†ææŠ¥å‘Š.md`
- `åŠŸèƒ½éœ€æ±‚æ¸…å•.json`
- `æµ‹è¯•åœºæ™¯è§„æ ¼.json`

**æ£€æŸ¥ç‚¹**:
- âœ… éœ€æ±‚ç†è§£å‡†ç¡®æ€§è‡ªæ£€ï¼ˆAIä¸ç”¨æˆ·ç¡®è®¤ï¼‰
- âœ… æµ‹è¯•åœºæ™¯è¦†ç›–å®Œæ•´æ€§

#### é˜¶æ®µ2: æ¶æ„è®¾è®¡ï¼ˆAIä¸»å¯¼ï¼‰

**è¾“å…¥**:
- åŠŸèƒ½éœ€æ±‚æ¸…å•
- ç°æœ‰é¡¹ç›®æ¶æ„ï¼ˆTransport/Protocol/UIå±‚ï¼‰

**AIå¤„ç†æµç¨‹**:
1. åˆ†æç°æœ‰æ¶æ„é€‚é…æ€§
2. è®¾è®¡æ¨¡å—åˆ’åˆ†æ–¹æ¡ˆ
3. å®šä¹‰æ¥å£å’Œæ•°æ®æµ
4. è¯„ä¼°æ€§èƒ½å’Œå®‰å…¨æ€§å½±å“

**è¾“å‡º**:
- `æ¶æ„è®¾è®¡æ–‡æ¡£.md`ï¼ˆåŒ…å«ASCIIæ¶æ„å›¾ï¼‰
- `æ¥å£å®šä¹‰.h`ï¼ˆC++å¤´æ–‡ä»¶ï¼‰
- `æ•°æ®æµè®¾è®¡.json`

**æ£€æŸ¥ç‚¹**:
- âœ… SOLIDåŸåˆ™å®¡æŸ¥ï¼ˆä½¿ç”¨architect-reviewer agentï¼‰
- âœ… æ¶æ„å…¼å®¹æ€§éªŒè¯

#### é˜¶æ®µ3: ä»£ç å®ç°ï¼ˆAIä¸»å¯¼ï¼‰

**è¾“å…¥**:
- æ¶æ„è®¾è®¡æ–‡æ¡£
- æ¥å£å®šä¹‰

**AIå¤„ç†æµç¨‹**:
1. åŸºäºæ¶æ„ç”Ÿæˆæºä»£ç 
2. éµå¾ªç¼–ç è§„èŒƒï¼ˆUTF-8 BOMã€ä¸­æ–‡æ³¨é‡Šï¼‰
3. åŒæ­¥ç”Ÿæˆå•å…ƒæµ‹è¯•ä»£ç 
4. è‡ªåŠ¨ç”Ÿæˆé…ç½®æ–‡ä»¶

**è¾“å‡º**:
- æºä»£ç æ–‡ä»¶ï¼ˆ.cpp/.hï¼‰
- å•å…ƒæµ‹è¯•ä»£ç ï¼ˆ`*_test.cpp`ï¼‰
- é…ç½®æ–‡ä»¶æ›´æ–°

**æ£€æŸ¥ç‚¹**:
- âœ… ä»£ç é£æ ¼æ£€æŸ¥ï¼ˆä½¿ç”¨code-reviewer agentï¼‰
- âœ… ç¼–è¯‘éªŒè¯ï¼ˆautobuild_x86_debug.batï¼‰
- âœ… é™æ€åˆ†æï¼ˆC++ linterï¼‰

#### é˜¶æ®µ4: è‡ªåŠ¨æµ‹è¯•ï¼ˆAIè®¾è®¡å¹¶æ‰§è¡Œï¼‰

**æµ‹è¯•å±‚æ¬¡**:
```
å•å…ƒæµ‹è¯•ï¼ˆUnit Testsï¼‰
   â†“ æ¯ä¸ªå‡½æ•°/ç±»ç‹¬ç«‹æµ‹è¯•
é›†æˆæµ‹è¯•ï¼ˆIntegration Testsï¼‰
   â†“ æ¨¡å—é—´äº¤äº’æµ‹è¯•
ç³»ç»Ÿæµ‹è¯•ï¼ˆSystem Testsï¼‰
   â†“ ç«¯åˆ°ç«¯åŠŸèƒ½æµ‹è¯•
å›å½’æµ‹è¯•ï¼ˆRegression Testsï¼‰
   â†“ å…¨é‡é‡æµ‹éªŒè¯
```

**è¾“å…¥**:
- ç¼–è¯‘æˆåŠŸçš„å¯æ‰§è¡Œæ–‡ä»¶
- æµ‹è¯•åœºæ™¯è§„æ ¼

**AIå¤„ç†æµç¨‹**:
1. æ ¹æ®åŠŸèƒ½è‡ªåŠ¨ç”Ÿæˆæµ‹è¯•å·¥å…·
2. æ‰§è¡Œå¤šå±‚æ¬¡æµ‹è¯•
3. æ”¶é›†æµ‹è¯•ç»“æœå’Œæ—¥å¿—
4. åˆ†æå¤±è´¥åŸå› 

**è¾“å‡º**:
- æµ‹è¯•æŠ¥å‘Šï¼ˆ`æµ‹è¯•æŠ¥å‘Š_æ—¶é—´æˆ³.md`ï¼‰
- æµ‹è¯•æ—¥å¿—ï¼ˆ`test_logs/`ï¼‰
- è¦†ç›–ç‡æŠ¥å‘Šï¼ˆ`coverage_report.html`ï¼‰

**æ£€æŸ¥ç‚¹**:
- âœ… æ‰€æœ‰æµ‹è¯•ç”¨ä¾‹é€šè¿‡
- âœ… ä»£ç è¦†ç›–ç‡ â‰¥ 90%
- âœ… æ— å†…å­˜æ³„æ¼
- âœ… æ€§èƒ½æŒ‡æ ‡è¾¾æ ‡

#### é˜¶æ®µ5: è‡ªåŠ¨ä¿®å¤ï¼ˆAIè¯†åˆ«å¹¶ä¿®å¤ï¼‰

**è¾“å…¥**:
- æµ‹è¯•å¤±è´¥æŠ¥å‘Š
- é”™è¯¯æ—¥å¿—å’Œå †æ ˆä¿¡æ¯
- é”™è¯¯æˆªå›¾ï¼ˆå¦‚æœ‰ï¼‰

**AIå¤„ç†æµç¨‹**:
1. é”™è¯¯æ¨¡å¼è¯†åˆ«ï¼ˆåŸºäºé”™è¯¯ç±»å‹åº“ï¼‰
2. å®šä½é—®é¢˜ä»£ç ä½ç½®
3. åº”ç”¨ä¿®å¤ç­–ç•¥æ¨¡æ¿
4. é‡æ–°ç¼–è¯‘å’Œæµ‹è¯•

**ä¿®å¤ç­–ç•¥**:
- **ç¼–è¯‘é”™è¯¯**: è¯­æ³•ä¿®æ­£ã€å¤´æ–‡ä»¶è¡¥å…¨ã€é“¾æ¥é”™è¯¯ä¿®å¤
- **è¿è¡Œæ—¶é”™è¯¯**: ç©ºæŒ‡é’ˆæ£€æŸ¥ã€æ•°ç»„è¾¹ç•Œæ£€æŸ¥ã€å¼‚å¸¸å¤„ç†
- **é€»è¾‘é”™è¯¯**: çŠ¶æ€æœºä¿®æ­£ã€æ¡ä»¶åˆ¤æ–­ä¿®æ­£ã€ç®—æ³•ä¼˜åŒ–

**è¾“å‡º**:
- ä¿®å¤åçš„æºä»£ç 
- ä¿®å¤è®°å½•ï¼ˆ`ä¿®å¤æ—¥å¿—_æ—¶é—´æˆ³.md`ï¼‰

**æ£€æŸ¥ç‚¹**:
- âœ… ä¿®å¤åç¼–è¯‘æˆåŠŸ
- âœ… ä¿®å¤åæµ‹è¯•é€šè¿‡
- âœ… æœªå¼•å…¥æ–°é—®é¢˜ï¼ˆå›å½’æµ‹è¯•ï¼‰

**å¤±è´¥å‡çº§æœºåˆ¶**:
```
ä¿®å¤å°è¯•1 â”€â”€å¤±è´¥â”€â”€> ä¿®å¤å°è¯•2 â”€â”€å¤±è´¥â”€â”€> ä¿®å¤å°è¯•3 â”€â”€å¤±è´¥â”€â”€> äººå·¥ä»‹å…¥
    â†“æˆåŠŸ            â†“æˆåŠŸ            â†“æˆåŠŸ
  é‡æ–°æµ‹è¯•          é‡æ–°æµ‹è¯•          é‡æ–°æµ‹è¯•
```

#### é˜¶æ®µ6: ç‰ˆæœ¬æäº¤ï¼ˆAIç®¡ç†ç‰ˆæœ¬ï¼‰

**è¾“å…¥**:
- æ‰€æœ‰æµ‹è¯•é€šè¿‡çš„ä»£ç 
- æµ‹è¯•æŠ¥å‘Š

**AIå¤„ç†æµç¨‹**:
1. æ£€æŸ¥å˜æ›´æ–‡ä»¶ç±»å‹
2. ç”Ÿæˆæäº¤ä¿¡æ¯ï¼ˆconventional commitsï¼‰
3. æ‰§è¡ŒGitæ“ä½œ
4. æ¨é€åˆ°è¿œç¨‹ä»“åº“
5. ç”Ÿæˆç‰ˆæœ¬æ ‡ç­¾

**è¾“å‡º**:
- Git commitï¼ˆæ ¼å¼: `ç±»å‹: ç®€è¿°`ï¼‰
- è¿œç¨‹æ¨é€ç¡®è®¤
- ç‰ˆæœ¬æ ‡ç­¾ï¼ˆ`save-YYYYMMDD-HHMMSS`ï¼‰

**æ£€æŸ¥ç‚¹**:
- âœ… ä»£ç å˜æ›´å·²æš‚å­˜
- âœ… æäº¤ä¿¡æ¯è§„èŒƒ
- âœ… æ¨é€æˆåŠŸ
- âœ… æ–‡æ¡£åŒæ­¥æ›´æ–°

### 1.3 äººå·¥ä»‹å…¥è§¦å‘æ¡ä»¶

| è§¦å‘æ¡ä»¶ | æè¿° | å¤„ç†æ–¹å¼ |
|---------|------|---------|
| **éœ€æ±‚ä¸æ˜ç¡®** | AIæ— æ³•ç†è§£éœ€æ±‚æˆ–å­˜åœ¨æ­§ä¹‰ | è¯·æ±‚ç”¨æˆ·æ¾„æ¸… |
| **æ¶æ„å†²çª** | æ–°éœ€æ±‚ä¸ç°æœ‰æ¶æ„ä¸¥é‡å†²çª | æä¾›å¤šä¸ªæ–¹æ¡ˆä¾›ç”¨æˆ·é€‰æ‹© |
| **ç¼–è¯‘æŒç»­å¤±è´¥** | 3æ¬¡è‡ªåŠ¨ä¿®å¤åä»ç¼–è¯‘å¤±è´¥ | ç”Ÿæˆè¯¦ç»†è¯Šæ–­æŠ¥å‘Šï¼Œè¯·æ±‚äººå·¥ä»‹å…¥ |
| **æµ‹è¯•æ— æ³•é€šè¿‡** | 3æ¬¡ä¿®å¤åæµ‹è¯•ä»å¤±è´¥ | æä¾›å¤±è´¥åˆ†æå’Œå»ºè®®ä¿®å¤æ–¹æ¡ˆ |
| **çœŸå®ç¡¬ä»¶éœ€æ±‚** | éœ€è¦çœŸå®æ‰“å°æœºè®¾å¤‡æµ‹è¯• | ç”Ÿæˆæµ‹è¯•æ­¥éª¤æ–‡æ¡£ï¼Œé€šçŸ¥æµ‹è¯•äººå‘˜ |
| **æ€§èƒ½ä¸¥é‡é™çº§** | ä¿®æ”¹å¯¼è‡´æ€§èƒ½ä¸‹é™>20% | æä¾›æ€§èƒ½åˆ†ææŠ¥å‘Šï¼Œè¯·æ±‚è¯„å®¡ |
| **å®‰å…¨é£é™©** | æ£€æµ‹åˆ°æ½œåœ¨å®‰å…¨é—®é¢˜ | ç«‹å³åœæ­¢å¹¶æŠ¥å‘Š |

---

## 2. åˆ†å±‚è‡ªåŠ¨åŒ–æµ‹è¯•ç­–ç•¥

### 2.1 å•å…ƒæµ‹è¯•ï¼ˆUnit Testingï¼‰

**ç›®æ ‡**: éªŒè¯æ¯ä¸ªåŠŸèƒ½æ¨¡å—çš„ç‹¬ç«‹æ­£ç¡®æ€§

#### 2.1.1 Transportå±‚å•å…ƒæµ‹è¯•å·¥å…·

**æµ‹è¯•å¯¹è±¡**:
- `SerialTransport`ï¼ˆä¸²å£ï¼‰
- `ParallelTransport`ï¼ˆå¹¶å£ï¼‰
- `UsbPrintTransport`ï¼ˆUSBæ‰“å°ï¼‰
- `NetworkPrintTransport`ï¼ˆç½‘ç»œæ‰“å°ï¼‰
- `LoopbackTransport`ï¼ˆå›è·¯æµ‹è¯•ï¼‰

**æµ‹è¯•å·¥å…·è®¾è®¡**:
```cpp
// TransportUnitTest.exe
// åŠŸèƒ½ï¼šç‹¬ç«‹æµ‹è¯•æ¯ä¸ªTransportå®ç°

æµ‹è¯•é¡¹ç›®ï¼š
1. Open/Closeæ“ä½œæµ‹è¯•
   - æ­£å¸¸æ‰“å¼€/å…³é—­
   - é‡å¤æ‰“å¼€æµ‹è¯•
   - æ— æ•ˆå‚æ•°æµ‹è¯•

2. Read/Writeæ“ä½œæµ‹è¯•
   - å°æ•°æ®åŒ…ï¼ˆ<256Bï¼‰
   - å¤§æ•°æ®åŒ…ï¼ˆ>1MBï¼‰
   - è¾¹ç•Œæ¡ä»¶æµ‹è¯•

3. çŠ¶æ€ç®¡ç†æµ‹è¯•
   - çŠ¶æ€è½¬æ¢éªŒè¯
   - å¼‚å¸¸çŠ¶æ€æ¢å¤

4. é”™è¯¯å¤„ç†æµ‹è¯•
   - è¶…æ—¶å¤„ç†
   - æ–­çº¿é‡è¿
   - èµ„æºé‡Šæ”¾
```

**è‡ªåŠ¨åŒ–æµ‹è¯•è„šæœ¬**:
```python
# transport_auto_test.py
# è‡ªåŠ¨è¿è¡Œæ‰€æœ‰Transportå•å…ƒæµ‹è¯•

def test_serial_transport():
    """æµ‹è¯•ä¸²å£ä¼ è¾“"""
    # ä½¿ç”¨è™šæ‹Ÿä¸²å£å¯¹ï¼ˆcom0comï¼‰
    # è‡ªåŠ¨é…ç½®æµ‹è¯•ç¯å¢ƒ
    # æ‰§è¡Œæµ‹è¯•å¹¶æ”¶é›†ç»“æœ

def test_loopback_transport():
    """æµ‹è¯•å›è·¯ä¼ è¾“"""
    # æ— éœ€å¤–éƒ¨è®¾å¤‡
    # è‡ªåŠ¨æ‰§è¡Œå¹¶éªŒè¯

def test_network_transport():
    """æµ‹è¯•ç½‘ç»œä¼ è¾“"""
    # å¯åŠ¨æœ¬åœ°TCPæœåŠ¡å™¨
    # æ¨¡æ‹Ÿæ‰“å°æœºå“åº”
    # æ‰§è¡Œæµ‹è¯•å¹¶éªŒè¯
```

#### 2.1.2 Protocolå±‚å•å…ƒæµ‹è¯•å·¥å…·

**æµ‹è¯•å¯¹è±¡**:
- `ReliableChannel`ï¼ˆå¯é ä¼ è¾“é€šé“ï¼‰
- `FrameCodec`ï¼ˆå¸§ç¼–è§£ç å™¨ï¼‰
- `CRC32`ï¼ˆæ ¡éªŒç®—æ³•ï¼‰

**æµ‹è¯•å·¥å…·è®¾è®¡**:
```cpp
// ProtocolUnitTest.exe
// åŠŸèƒ½ï¼šç‹¬ç«‹æµ‹è¯•åè®®å±‚å®ç°

æµ‹è¯•é¡¹ç›®ï¼š
1. CRC32ç®—æ³•éªŒè¯
   - å·²çŸ¥æ•°æ®æ ¡éªŒ
   - è¾¹ç•Œæ¡ä»¶æµ‹è¯•

2. FrameCodecç¼–è§£ç æµ‹è¯•
   - START/DATA/END/ACK/NAKå¸§
   - ç²˜åŒ…/åŠåŒ…å¤„ç†
   - å¤±æ­¥é‡åŒæ­¥

3. ReliableChannelå¯é æ€§æµ‹è¯•
   - æ­£å¸¸ä¼ è¾“æµç¨‹
   - ä¸¢åŒ…é‡ä¼ 
   - ä¹±åºå¤„ç†
   - è¶…æ—¶æ¢å¤
   - æ»‘åŠ¨çª—å£æµ‹è¯•
```

**è‡ªåŠ¨åŒ–æµ‹è¯•è„šæœ¬**:
```python
# protocol_auto_test.py

def test_frame_codec():
    """æµ‹è¯•å¸§ç¼–è§£ç """
    # ç”Ÿæˆå„ç±»æµ‹è¯•å¸§
    # éªŒè¯ç¼–ç æ­£ç¡®æ€§
    # éªŒè¯è§£ç æ­£ç¡®æ€§
    # æµ‹è¯•å¼‚å¸¸å¸§å¤„ç†

def test_reliable_channel():
    """æµ‹è¯•å¯é ä¼ è¾“"""
    # ä½¿ç”¨LoopbackTransport
    # æ¨¡æ‹Ÿå„ç§ç½‘ç»œæ¡ä»¶
    # éªŒè¯å¯é æ€§ä¿è¯
```

#### 2.1.3 UIå±‚å•å…ƒæµ‹è¯•å·¥å…·

**æµ‹è¯•å¯¹è±¡**:
- `UIStateManager`ï¼ˆUIçŠ¶æ€ç®¡ç†ï¼‰
- `ButtonStateManager`ï¼ˆæŒ‰é’®çŠ¶æ€ç®¡ç†ï¼‰
- `TransmissionStateManager`ï¼ˆä¼ è¾“çŠ¶æ€ç®¡ç†ï¼‰

**æµ‹è¯•å·¥å…·è®¾è®¡**:
```cpp
// UIUnitTest.exe
// åŠŸèƒ½ï¼šç‹¬ç«‹æµ‹è¯•UIçŠ¶æ€ç®¡ç†é€»è¾‘

æµ‹è¯•é¡¹ç›®ï¼š
1. çŠ¶æ€è½¬æ¢è¡¨éªŒè¯
   - æ‰€æœ‰åˆæ³•è½¬æ¢
   - æ‰€æœ‰éæ³•è½¬æ¢æ‹¦æˆª

2. æŒ‰é’®çŠ¶æ€åŒæ­¥æµ‹è¯•
   - è¿æ¥/æ–­å¼€æŒ‰é’®
   - å‘é€/æš‚åœ/åœæ­¢æŒ‰é’®
   - æ–‡ä»¶/æ¸…ç©º/ä¿å­˜æŒ‰é’®

3. æ˜¾ç¤ºæ ¼å¼åˆ‡æ¢æµ‹è¯•
   - åå…­è¿›åˆ¶/æ–‡æœ¬åˆ‡æ¢
   - å‘é€/æ¥æ”¶çª—å£åŒæ­¥
```

**è‡ªåŠ¨åŒ–æµ‹è¯•è„šæœ¬**:
```python
# ui_auto_test.py
# ä½¿ç”¨UI Automationæ¡†æ¶æµ‹è¯•

def test_button_states():
    """æµ‹è¯•æŒ‰é’®çŠ¶æ€ç®¡ç†"""
    # æ¨¡æ‹Ÿå„ç§æ“ä½œåºåˆ—
    # éªŒè¯æŒ‰é’®çŠ¶æ€æ­£ç¡®æ€§

def test_state_transitions():
    """æµ‹è¯•çŠ¶æ€è½¬æ¢"""
    # éå†æ‰€æœ‰çŠ¶æ€è½¬æ¢
    # éªŒè¯è½¬æ¢é€»è¾‘æ­£ç¡®æ€§
```

### 2.2 é›†æˆæµ‹è¯•ï¼ˆIntegration Testingï¼‰

**ç›®æ ‡**: éªŒè¯æ¨¡å—é—´äº¤äº’çš„æ­£ç¡®æ€§

#### 2.2.1 Transport + Protocol é›†æˆæµ‹è¯•

**æµ‹è¯•åœºæ™¯**:
```
SerialTransport + ReliableChannel
   â†’ ä¸²å£å¯é ä¼ è¾“å®Œæ•´æµç¨‹æµ‹è¯•

LoopbackTransport + ReliableChannel
   â†’ æœ¬åœ°å›è·¯å¯é ä¼ è¾“æµ‹è¯•ï¼ˆå½“å‰AutoTestï¼‰

NetworkPrintTransport + DirectMode
   â†’ ç½‘ç»œç›´é€šä¼ è¾“æµ‹è¯•
```

**è‡ªåŠ¨åŒ–æµ‹è¯•å·¥å…·**: `IntegrationTest.exe`

**æµ‹è¯•æµç¨‹**:
```python
# integration_auto_test.py

def test_transport_protocol_integration():
    """é›†æˆæµ‹è¯•ï¼šä¼ è¾“å±‚+åè®®å±‚"""

    # æµ‹è¯•1: Loopback + Reliable
    result1 = test_loopback_reliable_transfer()

    # æµ‹è¯•2: Serial + Reliable (è™šæ‹Ÿä¸²å£)
    result2 = test_serial_reliable_transfer()

    # æµ‹è¯•3: Network + Direct
    result3 = test_network_direct_transfer()

    # æ±‡æ€»ç»“æœ
    generate_integration_report([result1, result2, result3])
```

#### 2.2.2 Protocol + UI é›†æˆæµ‹è¯•

**æµ‹è¯•åœºæ™¯**:
- å¯é æ¨¡å¼åˆ‡æ¢ â†’ ReliableChannelçŠ¶æ€åŒæ­¥
- ä¼ è¾“è¿›åº¦æ›´æ–° â†’ UIè¿›åº¦æ¡æ˜¾ç¤º
- é”™è¯¯å¤„ç† â†’ UIé”™è¯¯æç¤º

**è‡ªåŠ¨åŒ–æµ‹è¯•å·¥å…·**: `ProtocolUITest.exe`

### 2.3 ç³»ç»Ÿæµ‹è¯•ï¼ˆSystem Testingï¼‰

**ç›®æ ‡**: éªŒè¯å®Œæ•´åŠŸèƒ½æµç¨‹çš„ç«¯åˆ°ç«¯æ­£ç¡®æ€§

#### 2.3.1 å®Œæ•´ä¼ è¾“æµç¨‹æµ‹è¯•

**æµ‹è¯•åœºæ™¯æ¸…å•**:
```
åœºæ™¯1: ä¸²å£ç›´é€šæ¨¡å¼æ–‡ä»¶ä¼ è¾“
   1. é€‰æ‹©ä¸²å£
   2. é…ç½®å‚æ•°ï¼ˆæ³¢ç‰¹ç‡/æ•°æ®ä½/æ ¡éªŒä½/åœæ­¢ä½ï¼‰
   3. è¿æ¥ç«¯å£
   4. åŠ è½½æ–‡ä»¶
   5. å‘é€æ•°æ®
   6. éªŒè¯æ¥æ”¶
   7. ä¿å­˜æ–‡ä»¶
   8. æ–­å¼€è¿æ¥

åœºæ™¯2: å›è·¯å¯é æ¨¡å¼æ–‡ä»¶ä¼ è¾“
   1. é€‰æ‹©å›è·¯æµ‹è¯•ç«¯å£
   2. å¯ç”¨å¯é ä¼ è¾“æ¨¡å¼
   3. è¿æ¥ç«¯å£
   4. æ‹–æ”¾æ–‡ä»¶
   5. å‘é€æ•°æ®ï¼ˆè‡ªåŠ¨ACK/NAK/é‡ä¼ ï¼‰
   6. éªŒè¯æ¥æ”¶å®Œæ•´æ€§
   7. å¯¹æ¯”åŸæ–‡ä»¶
   8. æ–­å¼€è¿æ¥

åœºæ™¯3: ç½‘ç»œæ‰“å°RAW 9100ä¼ è¾“
   1. é€‰æ‹©ç½‘ç»œæ‰“å°ç«¯å£
   2. é…ç½®IPå’Œç«¯å£
   3. è¿æ¥æ‰“å°æœåŠ¡å™¨
   4. å‘é€æ‰“å°æ•°æ®
   5. æ¥æ”¶çŠ¶æ€å“åº”
   6. æ–­å¼€è¿æ¥

åœºæ™¯4: æš‚åœ/ç»§ç»­/ä¸­æ–­æ“ä½œ
   1. å¼€å§‹å¤§æ–‡ä»¶ä¼ è¾“
   2. ä¸­é€”æš‚åœ
   3. éªŒè¯æ–­ç‚¹ä¿ç•™
   4. ç»§ç»­ä¼ è¾“
   5. éªŒè¯ä»æ–­ç‚¹æ¢å¤
   6. æµ‹è¯•ä¸­æ–­æ“ä½œ
```

**è‡ªåŠ¨åŒ–æµ‹è¯•å·¥å…·**: `SystemTest.exe`

**æµ‹è¯•è„šæœ¬**:
```python
# system_auto_test.py
# ç«¯åˆ°ç«¯ç³»ç»Ÿæµ‹è¯•

def test_e2e_loopback_reliable():
    """ç«¯åˆ°ç«¯æµ‹è¯•ï¼šå›è·¯å¯é ä¼ è¾“"""

    # æ­¥éª¤1: å¯åŠ¨PortMaster
    app = start_portmaster()

    # æ­¥éª¤2: UIè‡ªåŠ¨åŒ–æ“ä½œ
    select_loopback_port(app)
    enable_reliable_mode(app)
    connect_port(app)

    # æ­¥éª¤3: å‘é€æµ‹è¯•æ–‡ä»¶
    test_file = generate_test_file(size=5*1024*1024)  # 5MB
    drag_drop_file(app, test_file)
    click_send_button(app)

    # æ­¥éª¤4: ç­‰å¾…ä¼ è¾“å®Œæˆ
    wait_for_completion(app, timeout=60)

    # æ­¥éª¤5: éªŒè¯æ¥æ”¶æ–‡ä»¶
    received_file = get_received_file(app)
    assert files_are_identical(test_file, received_file)

    # æ­¥éª¤6: æ¸…ç†
    disconnect_port(app)
    close_app(app)

    return "PASS"
```

### 2.4 å›å½’æµ‹è¯•ï¼ˆRegression Testingï¼‰

**ç›®æ ‡**: ç¡®ä¿ä»£ç ä¿®æ”¹ä¸å¼•å…¥æ–°é—®é¢˜

**æµ‹è¯•ç­–ç•¥**:
1. **è‡ªåŠ¨è§¦å‘**: æ¯æ¬¡ä»£ç æäº¤å‰è‡ªåŠ¨è¿è¡Œ
2. **å…¨é‡æµ‹è¯•**: è¿è¡Œæ‰€æœ‰å•å…ƒ/é›†æˆ/ç³»ç»Ÿæµ‹è¯•
3. **æ€§èƒ½å¯¹æ¯”**: å¯¹æ¯”ä¿®æ”¹å‰åçš„æ€§èƒ½æŒ‡æ ‡
4. **å…¼å®¹æ€§éªŒè¯**: éªŒè¯æ—§åŠŸèƒ½ä»æ­£å¸¸å·¥ä½œ

**è‡ªåŠ¨åŒ–è„šæœ¬**:
```python
# regression_auto_test.py
# å›å½’æµ‹è¯•è‡ªåŠ¨åŒ–

def run_full_regression():
    """è¿è¡Œå®Œæ•´å›å½’æµ‹è¯•å¥—ä»¶"""

    results = []

    # 1. å•å…ƒæµ‹è¯•
    results.append(run_transport_unit_tests())
    results.append(run_protocol_unit_tests())
    results.append(run_ui_unit_tests())

    # 2. é›†æˆæµ‹è¯•
    results.append(run_integration_tests())

    # 3. ç³»ç»Ÿæµ‹è¯•
    results.append(run_system_tests())

    # 4. æ€§èƒ½æµ‹è¯•
    results.append(run_performance_tests())

    # 5. ç”ŸæˆæŠ¥å‘Š
    generate_regression_report(results)

    # 6. åˆ¤æ–­é€šè¿‡/å¤±è´¥
    if all(r["status"] == "PASS" for r in results):
        return "REGRESSION_PASS"
    else:
        return "REGRESSION_FAIL"
```

### 2.5 æµ‹è¯•æ•°æ®ç®¡ç†

**æµ‹è¯•æ–‡ä»¶ç”Ÿæˆ**:
```python
# test_data_generator.py
# è‡ªåŠ¨ç”Ÿæˆå„ç±»æµ‹è¯•æ–‡ä»¶

def generate_test_files():
    """ç”Ÿæˆæµ‹è¯•æ•°æ®é›†"""

    test_files = {
        # å°æ–‡ä»¶ï¼ˆ<1KBï¼‰
        "small_text.txt": generate_random_text(size=500),
        "small_binary.bin": generate_random_bytes(size=800),

        # ä¸­ç­‰æ–‡ä»¶ï¼ˆ1KB-1MBï¼‰
        "medium_pdf.pdf": generate_pdf_file(size=100*1024),
        "medium_image.png": generate_png_image(width=800, height=600),

        # å¤§æ–‡ä»¶ï¼ˆ>1MBï¼‰
        "large_document.pdf": generate_pdf_file(size=5*1024*1024),
        "large_binary.dat": generate_random_bytes(size=10*1024*1024),

        # ç‰¹æ®Šæ–‡ä»¶
        "unicode_filename_æµ‹è¯•æ–‡ä»¶.txt": generate_random_text(size=1024),
        "zero_byte.bin": b"",
        "single_byte.bin": b"\x00",
    }

    # ä¿å­˜åˆ°æµ‹è¯•æ•°æ®ç›®å½•
    for filename, content in test_files.items():
        save_test_file(filename, content)
```

---

## 3. æ™ºèƒ½è‡ªåŠ¨ä¿®å¤ç³»ç»Ÿ

### 3.1 é”™è¯¯æ¨¡å¼è¯†åˆ«åº“

**é”™è¯¯åˆ†ç±»ä½“ç³»**:
```
ç¼–è¯‘é”™è¯¯ï¼ˆCompilation Errorsï¼‰
â”œâ”€â”€ è¯­æ³•é”™è¯¯ï¼ˆSyntax Errorsï¼‰
â”‚   â”œâ”€â”€ ç¼ºå°‘åˆ†å·
â”‚   â”œâ”€â”€ æ‹¬å·ä¸åŒ¹é…
â”‚   â””â”€â”€ ç±»å‹ä¸åŒ¹é…
â”œâ”€â”€ é“¾æ¥é”™è¯¯ï¼ˆLinker Errorsï¼‰
â”‚   â”œâ”€â”€ æœªå®šä¹‰å¼•ç”¨
â”‚   â”œâ”€â”€ é‡å¤å®šä¹‰
â”‚   â””â”€â”€ åº“æ–‡ä»¶ç¼ºå¤±
â””â”€â”€ é¢„å¤„ç†é”™è¯¯ï¼ˆPreprocessor Errorsï¼‰
    â”œâ”€â”€ å¤´æ–‡ä»¶æœªæ‰¾åˆ°
    â””â”€â”€ å®å®šä¹‰å†²çª

è¿è¡Œæ—¶é”™è¯¯ï¼ˆRuntime Errorsï¼‰
â”œâ”€â”€ å†…å­˜é”™è¯¯ï¼ˆMemory Errorsï¼‰
â”‚   â”œâ”€â”€ ç©ºæŒ‡é’ˆè®¿é—®
â”‚   â”œâ”€â”€ æ•°ç»„è¶Šç•Œ
â”‚   â”œâ”€â”€ å†…å­˜æ³„æ¼
â”‚   â””â”€â”€ é‡æŒ‡é’ˆ
â”œâ”€â”€ æ–­è¨€å¤±è´¥ï¼ˆAssertion Failuresï¼‰
â”‚   â”œâ”€â”€ MFCè°ƒè¯•æ–­è¨€
â”‚   â”œâ”€â”€ è‡ªå®šä¹‰æ–­è¨€
â”‚   â””â”€â”€ ç³»ç»Ÿæ–­è¨€
â””â”€â”€ å¼‚å¸¸é”™è¯¯ï¼ˆException Errorsï¼‰
    â”œâ”€â”€ è®¿é—®è¿ä¾‹
    â”œâ”€â”€ é™¤é›¶é”™è¯¯
    â””â”€â”€ èµ„æºè€—å°½

é€»è¾‘é”™è¯¯ï¼ˆLogic Errorsï¼‰
â”œâ”€â”€ çŠ¶æ€æœºé”™è¯¯
â”‚   â”œâ”€â”€ éæ³•çŠ¶æ€è½¬æ¢
â”‚   â”œâ”€â”€ çŠ¶æ€ä¸ä¸€è‡´
â”‚   â””â”€â”€ æ­»é”/æ´»é”
â”œâ”€â”€ æ•°æ®å¤„ç†é”™è¯¯
â”‚   â”œâ”€â”€ æ•°æ®æˆªæ–­
â”‚   â”œâ”€â”€ ç²¾åº¦ä¸¢å¤±
â”‚   â””â”€â”€ ç¼–ç é”™è¯¯
â””â”€â”€ ä¸šåŠ¡é€»è¾‘é”™è¯¯
    â”œâ”€â”€ åŠŸèƒ½ä¸ç¬¦åˆé¢„æœŸ
    â”œâ”€â”€ è¾¹ç•Œæ¡ä»¶æœªå¤„ç†
    â””â”€â”€ å¼‚å¸¸æµç¨‹ç¼ºå¤±
```

### 3.2 ä¿®å¤ç­–ç•¥æ¨¡æ¿åº“

#### 3.2.1 ç¼–è¯‘é”™è¯¯ä¿®å¤ç­–ç•¥

**ç­–ç•¥1: ç¼ºå°‘å¤´æ–‡ä»¶**
```python
class MissingHeaderFix:
    """ä¿®å¤ç¼ºå°‘å¤´æ–‡ä»¶é”™è¯¯"""

    def detect(self, error_message):
        patterns = [
            r"fatal error C1083: æ— æ³•æ‰“å¼€åŒ…æ‹¬æ–‡ä»¶: \"(.+)\"",
            r"'(.+)': æœªå®šä¹‰æ ‡è¯†ç¬¦",
        ]
        for pattern in patterns:
            match = re.search(pattern, error_message)
            if match:
                return match.group(1)
        return None

    def fix(self, source_file, missing_header):
        """æ·»åŠ ç¼ºå¤±çš„å¤´æ–‡ä»¶"""

        # 1. æœç´¢é¡¹ç›®ä¸­çš„å¤´æ–‡ä»¶ä½ç½®
        header_path = find_header_in_project(missing_header)

        # 2. è¯»å–æºæ–‡ä»¶
        with open(source_file, 'r', encoding='utf-8') as f:
            lines = f.readlines()

        # 3. åœ¨åˆé€‚ä½ç½®æ’å…¥#include
        include_line = f'#include "{missing_header}"\n'

        # æŸ¥æ‰¾æœ€åä¸€ä¸ª#includeä½ç½®
        last_include_idx = 0
        for i, line in enumerate(lines):
            if line.strip().startswith('#include'):
                last_include_idx = i

        # æ’å…¥æ–°çš„#include
        lines.insert(last_include_idx + 1, include_line)

        # 4. ä¿å­˜æ–‡ä»¶
        with open(source_file, 'w', encoding='utf-8') as f:
            f.writelines(lines)

        return f"å·²æ·»åŠ å¤´æ–‡ä»¶: {include_line.strip()}"
```

**ç­–ç•¥2: æœªå®šä¹‰å¼•ç”¨**
```python
class UndefinedReferenceFix:
    """ä¿®å¤æœªå®šä¹‰å¼•ç”¨é”™è¯¯"""

    def detect(self, error_message):
        pattern = r"error LNK2019: æ— æ³•è§£æçš„å¤–éƒ¨ç¬¦å· (.+)"
        match = re.search(pattern, error_message)
        if match:
            return match.group(1)
        return None

    def fix(self, undefined_symbol):
        """ä¿®å¤æœªå®šä¹‰çš„ç¬¦å·"""

        # 1. æœç´¢ç¬¦å·å®šä¹‰ä½ç½®
        definition_file = search_symbol_definition(undefined_symbol)

        if definition_file:
            # 2. æ£€æŸ¥æ˜¯å¦å·²æ·»åŠ åˆ°é¡¹ç›®
            if not is_file_in_project(definition_file):
                # æ·»åŠ åˆ°é¡¹ç›®
                add_file_to_project(definition_file)
                return f"å·²å°† {definition_file} æ·»åŠ åˆ°é¡¹ç›®"
        else:
            # 3. å¯èƒ½éœ€è¦å®ç°è¯¥å‡½æ•°
            return f"éœ€è¦å®ç°å‡½æ•°: {undefined_symbol}"
```

#### 3.2.2 è¿è¡Œæ—¶é”™è¯¯ä¿®å¤ç­–ç•¥

**ç­–ç•¥3: ç©ºæŒ‡é’ˆè®¿é—®ä¿®å¤**
```python
class NullPointerFix:
    """ä¿®å¤ç©ºæŒ‡é’ˆè®¿é—®é”™è¯¯"""

    def detect(self, error_info):
        """æ£€æµ‹ç©ºæŒ‡é’ˆé”™è¯¯"""
        patterns = [
            r"Debug Assertion Failed.*Expression: (.+) != nullptr",
            r"Access violation reading location 0x00000000",
            r"Unhandled exception.*access violation",
        ]
        # ... æ¨¡å¼åŒ¹é…é€»è¾‘

    def fix(self, source_file, line_number, pointer_variable):
        """æ·»åŠ ç©ºæŒ‡é’ˆæ£€æŸ¥"""

        # 1. è¯»å–æºæ–‡ä»¶
        with open(source_file, 'r', encoding='utf-8') as f:
            lines = f.readlines()

        # 2. åœ¨æŒ‡é’ˆä½¿ç”¨å‰æ·»åŠ æ£€æŸ¥
        check_code = f"""
    // ã€è‡ªåŠ¨ä¿®å¤ã€‘æ·»åŠ ç©ºæŒ‡é’ˆæ£€æŸ¥
    if ({pointer_variable} == nullptr) {{
        AfxMessageBox(_T("{pointer_variable} æœªåˆå§‹åŒ–"));
        return;
    }}
"""

        # 3. æ’å…¥æ£€æŸ¥ä»£ç 
        lines.insert(line_number - 1, check_code)

        # 4. ä¿å­˜æ–‡ä»¶
        with open(source_file, 'w', encoding='utf-8') as f:
            f.writelines(lines)

        return f"å·²åœ¨ {source_file}:{line_number} æ·»åŠ ç©ºæŒ‡é’ˆæ£€æŸ¥"
```

**ç­–ç•¥4: æ•°ç»„è¶Šç•Œä¿®å¤**
```python
class ArrayBoundsFix:
    """ä¿®å¤æ•°ç»„è¶Šç•Œé”™è¯¯"""

    def detect(self, error_info):
        """æ£€æµ‹æ•°ç»„è¶Šç•Œ"""
        patterns = [
            r"vector subscript out of range",
            r"array index \d+ is out of bounds",
        ]
        # ... æ£€æµ‹é€»è¾‘

    def fix(self, source_file, line_number, array_access):
        """æ·»åŠ è¾¹ç•Œæ£€æŸ¥"""

        # åˆ†ææ•°ç»„è®¿é—®è¡¨è¾¾å¼
        array_name, index_expr = parse_array_access(array_access)

        # ç”Ÿæˆè¾¹ç•Œæ£€æŸ¥ä»£ç 
        check_code = f"""
    // ã€è‡ªåŠ¨ä¿®å¤ã€‘æ·»åŠ æ•°ç»„è¾¹ç•Œæ£€æŸ¥
    if ({index_expr} < 0 || {index_expr} >= {array_name}.size()) {{
        WriteLog("æ•°ç»„è®¿é—®è¶Šç•Œ");
        return;
    }}
"""

        # æ’å…¥æ£€æŸ¥ä»£ç 
        insert_code_at_line(source_file, line_number - 1, check_code)

        return f"å·²æ·»åŠ æ•°ç»„è¾¹ç•Œæ£€æŸ¥: {array_access}"
```

#### 3.2.3 é€»è¾‘é”™è¯¯ä¿®å¤ç­–ç•¥

**ç­–ç•¥5: çŠ¶æ€è½¬æ¢é”™è¯¯ä¿®å¤**
```python
class StateTransitionFix:
    """ä¿®å¤çŠ¶æ€è½¬æ¢é”™è¯¯"""

    def detect(self, error_log):
        """æ£€æµ‹çŠ¶æ€è½¬æ¢é”™è¯¯"""
        pattern = r"æ— æ•ˆçŠ¶æ€è½¬æ¢: (\w+) -> (\w+)"
        match = re.search(pattern, error_log)
        if match:
            return (match.group(1), match.group(2))
        return None

    def fix(self, from_state, to_state):
        """ä¿®å¤çŠ¶æ€è½¬æ¢è¡¨"""

        # 1. è¯»å–çŠ¶æ€è½¬æ¢è¡¨å®šä¹‰
        state_table_file = "src/TransmissionStateManager.cpp"

        # 2. åˆ†æè½¬æ¢æ˜¯å¦åº”è¯¥åˆæ³•
        if should_allow_transition(from_state, to_state):
            # 3. æ›´æ–°çŠ¶æ€è½¬æ¢è¡¨
            update_transition_table(state_table_file, from_state, to_state, allow=True)
            return f"å·²å…è®¸çŠ¶æ€è½¬æ¢: {from_state} -> {to_state}"
        else:
            # 4. ä¿®æ”¹è°ƒç”¨ä»£ç ï¼Œä½¿ç”¨æ­£ç¡®çš„è½¬æ¢åºåˆ—
            fix_transition_sequence(from_state, to_state)
            return f"å·²ä¿®æ­£çŠ¶æ€è½¬æ¢åºåˆ—"
```

### 3.3 ä¿®å¤éªŒè¯å¾ªç¯

**ä¿®å¤æµç¨‹**:
```python
# auto_fix_and_verify.py
# è‡ªåŠ¨ä¿®å¤ä¸éªŒè¯å¾ªç¯

def auto_fix_and_verify(error_report, max_attempts=3):
    """è‡ªåŠ¨ä¿®å¤å¹¶éªŒè¯"""

    for attempt in range(1, max_attempts + 1):
        print(f"[ä¿®å¤å°è¯• {attempt}/{max_attempts}]")

        # æ­¥éª¤1: åˆ†æé”™è¯¯
        error_type = classify_error(error_report)
        print(f"é”™è¯¯ç±»å‹: {error_type}")

        # æ­¥éª¤2: é€‰æ‹©ä¿®å¤ç­–ç•¥
        fix_strategy = select_fix_strategy(error_type, error_report)
        print(f"ä¿®å¤ç­–ç•¥: {fix_strategy.__class__.__name__}")

        # æ­¥éª¤3: åº”ç”¨ä¿®å¤
        fix_result = fix_strategy.fix(error_report)
        print(f"ä¿®å¤æ“ä½œ: {fix_result}")

        # æ­¥éª¤4: é‡æ–°ç¼–è¯‘
        build_result = rebuild_project()
        if build_result["status"] != "SUCCESS":
            print(f"ç¼–è¯‘å¤±è´¥: {build_result['error']}")
            error_report = build_result["error"]
            continue

        print("ç¼–è¯‘æˆåŠŸï¼")

        # æ­¥éª¤5: é‡æ–°æµ‹è¯•
        test_result = run_tests()
        if test_result["status"] != "PASS":
            print(f"æµ‹è¯•å¤±è´¥: {test_result['failures']}")
            error_report = test_result["failures"][0]
            continue

        print("æµ‹è¯•é€šè¿‡ï¼")

        # æ­¥éª¤6: å›å½’æµ‹è¯•
        regression_result = run_regression_tests()
        if regression_result["status"] != "PASS":
            print(f"å›å½’æµ‹è¯•å¤±è´¥: å¼•å…¥äº†æ–°é—®é¢˜")
            # å›é€€ä¿®æ”¹
            revert_last_fix()
            error_report = regression_result["failures"][0]
            continue

        print("å›å½’æµ‹è¯•é€šè¿‡ï¼ä¿®å¤æˆåŠŸï¼")
        return {
            "status": "SUCCESS",
            "attempts": attempt,
            "fix": fix_result
        }

    # è¾¾åˆ°æœ€å¤§å°è¯•æ¬¡æ•°
    print(f"[å¤±è´¥] {max_attempts}æ¬¡ä¿®å¤å°è¯•å‡å¤±è´¥ï¼Œéœ€è¦äººå·¥ä»‹å…¥")
    return {
        "status": "FAILED",
        "attempts": max_attempts,
        "last_error": error_report
    }
```

### 3.4 ä¿®å¤ç­–ç•¥ä¼˜å…ˆçº§

**ä¼˜å…ˆçº§æ’åº**:
```
é«˜ä¼˜å…ˆçº§ï¼ˆç«‹å³ä¿®å¤ï¼‰
â”œâ”€â”€ ç¼–è¯‘é˜»æ–­é”™è¯¯ï¼ˆæ— æ³•ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ï¼‰
â”œâ”€â”€ ç¨‹åºå¯åŠ¨å´©æºƒï¼ˆæ— æ³•è¿è¡Œï¼‰
â””â”€â”€ ä¸¥é‡å†…å­˜é”™è¯¯ï¼ˆå¯èƒ½æŸåæ•°æ®ï¼‰

ä¸­ä¼˜å…ˆçº§ï¼ˆå°½å¿«ä¿®å¤ï¼‰
â”œâ”€â”€ åŠŸèƒ½æ€§é”™è¯¯ï¼ˆéƒ¨åˆ†åŠŸèƒ½ä¸å¯ç”¨ï¼‰
â”œâ”€â”€ æ€§èƒ½é—®é¢˜ï¼ˆå“åº”æ—¶é—´>é¢„æœŸ2å€ï¼‰
â””â”€â”€ å…¼å®¹æ€§é—®é¢˜ï¼ˆæŸäº›ç¯å¢ƒä¸‹å¤±è´¥ï¼‰

ä½ä¼˜å…ˆçº§ï¼ˆå¯å»¶åä¿®å¤ï¼‰
â”œâ”€â”€ UIæ˜¾ç¤ºé—®é¢˜ï¼ˆä¸å½±å“åŠŸèƒ½ï¼‰
â”œâ”€â”€ æ—¥å¿—ä¿¡æ¯ä¸å®Œæ•´
â””â”€â”€ ä»£ç é£æ ¼é—®é¢˜
```

**ä¿®å¤ç­–ç•¥é€‰æ‹©ç®—æ³•**:
```python
def select_fix_strategy(error_type, error_details):
    """æ ¹æ®é”™è¯¯ç±»å‹å’Œè¯¦æƒ…é€‰æ‹©æœ€ä½³ä¿®å¤ç­–ç•¥"""

    # ç­–ç•¥è¯„åˆ†ç³»ç»Ÿ
    strategies = []

    # 1. åŸºäºé”™è¯¯ç±»å‹çš„ç­–ç•¥åŒ¹é…
    for strategy_class in available_strategies:
        if strategy_class.can_handle(error_type):
            confidence = strategy_class.calculate_confidence(error_details)
            strategies.append({
                "strategy": strategy_class,
                "confidence": confidence,
                "priority": strategy_class.priority
            })

    # 2. æŒ‰ç½®ä¿¡åº¦å’Œä¼˜å…ˆçº§æ’åº
    strategies.sort(key=lambda x: (x["confidence"], x["priority"]), reverse=True)

    # 3. è¿”å›æœ€ä½³ç­–ç•¥
    if strategies:
        best_strategy = strategies[0]["strategy"]
        print(f"é€‰æ‹©ç­–ç•¥: {best_strategy.__name__} (ç½®ä¿¡åº¦: {strategies[0]['confidence']:.2%})")
        return best_strategy()
    else:
        return GenericFix()  # é€šç”¨ä¿®å¤ç­–ç•¥
```

---

## 4. è´¨é‡ä¿è¯ä½“ç³»

### 4.1 ä»£ç è´¨é‡æ£€æŸ¥

#### 4.1.1 ç¼–è¯‘è´¨é‡å¼ºåˆ¶è¦æ±‚

**é›¶é”™è¯¯é›¶è­¦å‘Šç­–ç•¥**:
```bash
# autobuild_x86_debug.bat
# ç¼–è¯‘è„šæœ¬å¼ºåˆ¶è¦æ±‚

msbuild PortMaster.sln ^
    /p:Configuration=Debug ^
    /p:Platform=Win32 ^
    /p:TreatWarningsAsErrors=true ^
    /maxcpucount ^
    /fileLogger ^
    /flp:logfile=msbuild_debug.log;verbosity=normal

# æ£€æŸ¥ç¼–è¯‘ç»“æœ
findstr /C:"0 Error(s)" msbuild_debug.log
if %ERRORLEVEL% NEQ 0 (
    echo [ERROR] ç¼–è¯‘å­˜åœ¨é”™è¯¯ï¼Œæ‹’ç»ç»§ç»­
    exit /b 1
)

findstr /C:"0 Warning(s)" msbuild_debug.log
if %ERRORLEVEL% NEQ 0 (
    echo [ERROR] ç¼–è¯‘å­˜åœ¨è­¦å‘Šï¼Œæ‹’ç»ç»§ç»­
    exit /b 1
)

echo [OK] ç¼–è¯‘æˆåŠŸï¼š0 error, 0 warning
```

#### 4.1.2 é™æ€ä»£ç åˆ†æ

**ä½¿ç”¨å·¥å…·**:
- **cppcheck**: C++é™æ€åˆ†æå™¨
- **clang-tidy**: LLVMä»£ç æ£€æŸ¥å·¥å…·
- **Visual Studio Code Analysis**: VSå†…ç½®åˆ†æå™¨

**è‡ªåŠ¨åŒ–åˆ†æè„šæœ¬**:
```python
# static_analysis.py
# é™æ€ä»£ç åˆ†æè‡ªåŠ¨åŒ–

def run_static_analysis():
    """è¿è¡Œé™æ€ä»£ç åˆ†æ"""

    results = []

    # 1. cppcheckåˆ†æ
    print("[1/3] è¿è¡Œcppcheck...")
    cppcheck_result = subprocess.run([
        "cppcheck",
        "--enable=all",
        "--inconclusive",
        "--xml",
        "--xml-version=2",
        "src/",
        "Protocol/",
        "Transport/"
    ], capture_output=True, text=True)

    results.append(parse_cppcheck_output(cppcheck_result.stdout))

    # 2. clang-tidyåˆ†æ
    print("[2/3] è¿è¡Œclang-tidy...")
    clang_result = run_clang_tidy(["src/*.cpp", "Protocol/*.cpp", "Transport/*.cpp"])
    results.append(clang_result)

    # 3. Visual Studioåˆ†æ
    print("[3/3] è¿è¡ŒVSä»£ç åˆ†æ...")
    vs_result = run_vs_code_analysis("PortMaster.sln")
    results.append(vs_result)

    # 4. æ±‡æ€»æŠ¥å‘Š
    generate_static_analysis_report(results)

    # 5. åˆ¤æ–­æ˜¯å¦é€šè¿‡
    total_issues = sum(r["issue_count"] for r in results)
    if total_issues > 0:
        print(f"[WARNING] å‘ç° {total_issues} ä¸ªé™æ€åˆ†æé—®é¢˜")
        return "FAIL"
    else:
        print("[OK] é™æ€åˆ†æé€šè¿‡")
        return "PASS"
```

### 4.2 ä»£ç å®¡æŸ¥è‡ªåŠ¨åŒ–

**ä½¿ç”¨Specialized Agents**:

#### 4.2.1 æ¶æ„å®¡æŸ¥ï¼ˆarchitect-reviewer agentï¼‰

**å®¡æŸ¥å†…å®¹**:
- SOLIDåŸåˆ™éµå¾ªæƒ…å†µ
- æ¨¡å—è¾¹ç•Œæ¸…æ™°åº¦
- ä¾èµ–å…³ç³»åˆç†æ€§
- æ¥å£è®¾è®¡ä¸€è‡´æ€§

**è§¦å‘æ—¶æœº**:
- æ–°å¢æ¨¡å—æˆ–ç±»
- ä¿®æ”¹æ ¸å¿ƒæ¥å£
- é‡æ„ä»£ç ç»“æ„

**è‡ªåŠ¨åŒ–è°ƒç”¨**:
```python
# code_review_automation.py

async def architecture_review(changed_files):
    """æ¶æ„å®¡æŸ¥"""

    # ä½¿ç”¨architect-reviewer agent
    review_prompt = f"""
è¯·å®¡æŸ¥ä»¥ä¸‹ä»£ç å˜æ›´çš„æ¶æ„è®¾è®¡ï¼š

å˜æ›´æ–‡ä»¶ï¼š
{format_file_list(changed_files)}

å®¡æŸ¥è¦ç‚¹ï¼š
1. æ˜¯å¦éµå¾ªSOLIDåŸåˆ™
2. æ¨¡å—èŒè´£æ˜¯å¦å•ä¸€
3. ä¾èµ–å…³ç³»æ˜¯å¦åˆç†
4. æ¥å£è®¾è®¡æ˜¯å¦ä¸€è‡´

è¯·æä¾›è¯¦ç»†çš„å®¡æŸ¥æ„è§å’Œæ”¹è¿›å»ºè®®ã€‚
"""

    agent_result = await call_agent("architect-reviewer", review_prompt)

    # è§£æå®¡æŸ¥ç»“æœ
    review = parse_review_result(agent_result)

    if review["issues"]:
        print(f"[æ¶æ„å®¡æŸ¥] å‘ç° {len(review['issues'])} ä¸ªé—®é¢˜ï¼š")
        for issue in review["issues"]:
            print(f"  - {issue['severity']}: {issue['description']}")
        return "FAIL"
    else:
        print("[æ¶æ„å®¡æŸ¥] é€šè¿‡")
        return "PASS"
```

#### 4.2.2 ä»£ç è´¨é‡å®¡æŸ¥ï¼ˆcode-reviewer agentï¼‰

**å®¡æŸ¥å†…å®¹**:
- ä»£ç é£æ ¼ä¸€è‡´æ€§
- å‘½åè§„èŒƒ
- æ³¨é‡Šå®Œæ•´æ€§
- é”™è¯¯å¤„ç†å……åˆ†æ€§
- èµ„æºç®¡ç†æ­£ç¡®æ€§

**è§¦å‘æ—¶æœº**:
- æ¯æ¬¡ä»£ç æäº¤å‰

**è‡ªåŠ¨åŒ–è°ƒç”¨**:
```python
async def code_quality_review(changed_files):
    """ä»£ç è´¨é‡å®¡æŸ¥"""

    review_prompt = f"""
è¯·å®¡æŸ¥ä»¥ä¸‹ä»£ç çš„è´¨é‡ï¼š

å˜æ›´æ–‡ä»¶ï¼š
{format_file_list(changed_files)}

å®¡æŸ¥æ ‡å‡†ï¼š
1. ç¼–ç è§„èŒƒï¼šUTF-8 BOM, ä¸­æ–‡æ³¨é‡Š
2. å‘½åè§„èŒƒï¼šæ¸…æ™°ã€ä¸€è‡´
3. é”™è¯¯å¤„ç†ï¼šå®Œæ•´ã€åˆç†
4. èµ„æºç®¡ç†ï¼šæ— æ³„æ¼
5. ä»£ç å¤æ‚åº¦ï¼šå¯ç»´æŠ¤

è¯·æä¾›å…·ä½“çš„æ”¹è¿›å»ºè®®ã€‚
"""

    agent_result = await call_agent("code-reviewer", review_prompt)

    review = parse_review_result(agent_result)

    if review["critical_issues"]:
        print("[ä»£ç å®¡æŸ¥] å‘ç°ä¸¥é‡é—®é¢˜ï¼Œå¿…é¡»ä¿®å¤")
        return "FAIL"
    elif review["suggestions"]:
        print(f"[ä»£ç å®¡æŸ¥] æœ‰ {len(review['suggestions'])} æ¡æ”¹è¿›å»ºè®®")
        return "PASS_WITH_SUGGESTIONS"
    else:
        print("[ä»£ç å®¡æŸ¥] é€šè¿‡")
        return "PASS"
```

### 4.3 æµ‹è¯•è¦†ç›–ç‡è¦æ±‚

**ç›®æ ‡è¦†ç›–ç‡**: â‰¥ 90%

**è¦†ç›–ç‡ç±»å‹**:
- **è¡Œè¦†ç›–ç‡ï¼ˆLine Coverageï¼‰**: â‰¥ 90%
- **åˆ†æ”¯è¦†ç›–ç‡ï¼ˆBranch Coverageï¼‰**: â‰¥ 85%
- **å‡½æ•°è¦†ç›–ç‡ï¼ˆFunction Coverageï¼‰**: â‰¥ 95%

**è¦†ç›–ç‡æµ‹é‡å·¥å…·**: OpenCppCoverage

**è‡ªåŠ¨åŒ–æµ‹é‡è„šæœ¬**:
```python
# coverage_measurement.py

def measure_code_coverage():
    """æµ‹é‡ä»£ç è¦†ç›–ç‡"""

    # 1. è¿è¡Œæµ‹è¯•å¹¶æ”¶é›†è¦†ç›–ç‡æ•°æ®
    subprocess.run([
        "OpenCppCoverage.exe",
        "--sources", "src",
        "--sources", "Protocol",
        "--sources", "Transport",
        "--export_type", "html:coverage_report",
        "--export_type", "cobertura:coverage.xml",
        "--",
        "AutoTest\\AutoTest.exe"
    ])

    # 2. è§£æè¦†ç›–ç‡æŠ¥å‘Š
    coverage_data = parse_coverage_xml("coverage.xml")

    # 3. æ£€æŸ¥æ˜¯å¦è¾¾æ ‡
    line_coverage = coverage_data["line_rate"] * 100
    branch_coverage = coverage_data["branch_rate"] * 100

    print(f"è¡Œè¦†ç›–ç‡: {line_coverage:.2f}%")
    print(f"åˆ†æ”¯è¦†ç›–ç‡: {branch_coverage:.2f}%")

    if line_coverage < 90:
        print(f"[FAIL] è¡Œè¦†ç›–ç‡ä¸è¶³90% (å½“å‰: {line_coverage:.2f}%)")
        return "FAIL"

    if branch_coverage < 85:
        print(f"[FAIL] åˆ†æ”¯è¦†ç›–ç‡ä¸è¶³85% (å½“å‰: {branch_coverage:.2f}%)")
        return "FAIL"

    print("[OK] è¦†ç›–ç‡è¾¾æ ‡")
    return "PASS"
```

### 4.4 æ€§èƒ½åŸºå‡†æµ‹è¯•

**æ€§èƒ½æŒ‡æ ‡**:
```
ä¼ è¾“æ€§èƒ½ï¼š
- ä¸²å£ååé‡: â‰¥ 115200 bps
- ç½‘ç»œååé‡: â‰¥ 10 MB/s
- å¯é ä¼ è¾“å¼€é”€: â‰¤ 15%

å“åº”æ€§èƒ½ï¼š
- UIå“åº”æ—¶é—´: â‰¤ 100ms
- è¿æ¥å»ºç«‹æ—¶é—´: â‰¤ 1s
- æ•°æ®æ˜¾ç¤ºåˆ·æ–°: â‰¥ 30 FPS

å†…å­˜æ€§èƒ½ï¼š
- å†…å­˜å ç”¨: â‰¤ 100 MB
- æ— å†…å­˜æ³„æ¼
```

**æ€§èƒ½æµ‹è¯•å·¥å…·**:
```cpp
// PerformanceBenchmark.exe
// æ€§èƒ½åŸºå‡†æµ‹è¯•å·¥å…·

void benchmark_transmission_throughput() {
    // æµ‹è¯•ä¼ è¾“ååé‡
    const size_t test_size = 10 * 1024 * 1024;  // 10MB
    auto start = std::chrono::high_resolution_clock::now();

    // æ‰§è¡Œä¼ è¾“
    transmit_data(test_data, test_size);

    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

    double throughput = (test_size / 1024.0 / 1024.0) / (duration.count() / 1000.0);

    std::cout << "ååé‡: " << throughput << " MB/s" << std::endl;

    // éªŒè¯æ˜¯å¦è¾¾æ ‡
    assert(throughput >= 10.0);
}
```

**æ€§èƒ½å›å½’æ£€æµ‹**:
```python
# performance_regression_check.py

def check_performance_regression():
    """æ£€æŸ¥æ€§èƒ½å›å½’"""

    # 1. è¿è¡ŒåŸºå‡†æµ‹è¯•
    current_metrics = run_performance_benchmark()

    # 2. åŠ è½½å†å²åŸºå‡†
    baseline_metrics = load_baseline_metrics()

    # 3. å¯¹æ¯”æ€§èƒ½
    for metric_name, current_value in current_metrics.items():
        baseline_value = baseline_metrics.get(metric_name)

        if baseline_value:
            degradation = (baseline_value - current_value) / baseline_value * 100

            if degradation > 20:  # æ€§èƒ½ä¸‹é™è¶…è¿‡20%
                print(f"[REGRESSION] {metric_name} æ€§èƒ½ä¸‹é™ {degradation:.2f}%")
                print(f"  åŸºå‡†å€¼: {baseline_value}")
                print(f"  å½“å‰å€¼: {current_value}")
                return "FAIL"
            elif degradation > 5:
                print(f"[WARNING] {metric_name} æ€§èƒ½ä¸‹é™ {degradation:.2f}%")

    print("[OK] æ— æ€§èƒ½å›å½’")
    return "PASS"
```

### 4.5 æ–‡æ¡£åŒæ­¥éªŒè¯

**æ–‡æ¡£ä¸€è‡´æ€§æ£€æŸ¥**:
```python
# doc_sync_check.py

def check_documentation_sync():
    """æ£€æŸ¥æ–‡æ¡£åŒæ­¥"""

    issues = []

    # 1. æ£€æŸ¥ä»£ç å˜æ›´æ˜¯å¦åŒæ­¥åˆ°æ–‡æ¡£
    changed_files = get_git_changed_files()

    for file in changed_files:
        if file.endswith(('.cpp', '.h')):
            # æ£€æŸ¥æ˜¯å¦æœ‰å¯¹åº”çš„æ–‡æ¡£æ›´æ–°
            doc_files = find_related_docs(file)

            for doc_file in doc_files:
                if not is_file_modified(doc_file):
                    issues.append(f"ä»£ç æ–‡ä»¶ {file} å·²ä¿®æ”¹ï¼Œä½†æ–‡æ¡£ {doc_file} æœªæ›´æ–°")

    # 2. æ£€æŸ¥æ¥å£å˜æ›´æ˜¯å¦æ›´æ–°APIæ–‡æ¡£
    api_changes = detect_api_changes(changed_files)
    if api_changes:
        api_doc = "docs/APIæ–‡æ¡£.md"
        if not is_file_modified(api_doc):
            issues.append(f"APIæ¥å£å·²å˜æ›´ï¼Œä½† {api_doc} æœªæ›´æ–°")

    # 3. æ£€æŸ¥CLAUDE.mdæ˜¯å¦éœ€è¦æ›´æ–°
    if has_workflow_changes(changed_files):
        if not is_file_modified("CLAUDE.md"):
            issues.append("å·¥ä½œæµç¨‹å·²å˜æ›´ï¼Œä½† CLAUDE.md æœªæ›´æ–°")

    # 4. æŠ¥å‘Šç»“æœ
    if issues:
        print("[æ–‡æ¡£åŒæ­¥æ£€æŸ¥] å‘ç°ä»¥ä¸‹é—®é¢˜ï¼š")
        for issue in issues:
            print(f"  - {issue}")
        return "FAIL"
    else:
        print("[æ–‡æ¡£åŒæ­¥æ£€æŸ¥] é€šè¿‡")
        return "PASS"
```

---

## 5. å…·ä½“å®æ–½è®¡åˆ’

### 5.1 æ”¹è¿›AutoTestå·¥å…·

**å½“å‰çŠ¶æ€åˆ†æ**:
- âœ… å·²å®ç°ï¼šå¯é ä¼ è¾“åè®®åŸºæœ¬æµ‹è¯•
- âŒ ç¼ºå¤±ï¼šUIäº¤äº’æµ‹è¯•ã€çŠ¶æ€æœºæµ‹è¯•ã€é”™è¯¯æ¢å¤æµ‹è¯•

**æ”¹è¿›è®¡åˆ’**:

#### 5.1.1 å¢å¼ºå¯é ä¼ è¾“æµ‹è¯•

**æ–°å¢æµ‹è¯•åœºæ™¯**:
```cpp
// AutoTest/advanced_reliable_tests.cpp

// æµ‹è¯•1: ä¸¢åŒ…æ¢å¤æµ‹è¯•
void test_packet_loss_recovery() {
    // é…ç½®LoopbackTransportæ¨¡æ‹Ÿä¸¢åŒ…
    loopback->SetPacketLossRate(0.1);  // 10%ä¸¢åŒ…ç‡

    // å‘é€æµ‹è¯•æ–‡ä»¶
    reliableChannel->SendFile("test_input.pdf");

    // éªŒè¯ï¼šå°½ç®¡æœ‰ä¸¢åŒ…ï¼Œæ–‡ä»¶ä»å®Œæ•´æ¥æ”¶
    assert(verify_file_integrity());
}

// æµ‹è¯•2: ä¹±åºæ•°æ®åŒ…æµ‹è¯•
void test_out_of_order_packets() {
    // é…ç½®LoopbackTransportæ¨¡æ‹Ÿä¹±åº
    loopback->EnablePacketReordering(true);

    // å‘é€æµ‹è¯•æ–‡ä»¶
    reliableChannel->SendFile("test_input.pdf");

    // éªŒè¯ï¼šä¹±åºæ•°æ®åŒ…è¢«æ­£ç¡®é‡æ’
    assert(verify_file_integrity());
}

// æµ‹è¯•3: è¶…æ—¶é‡ä¼ æµ‹è¯•
void test_timeout_retransmission() {
    // é…ç½®é•¿å»¶è¿Ÿ
    loopback->SetDelay(5000);  // 5ç§’å»¶è¿Ÿ

    // è®¾ç½®è¾ƒçŸ­çš„è¶…æ—¶
    reliableConfig.timeout = 2000;  // 2ç§’è¶…æ—¶

    // å‘é€æ•°æ®
    reliableChannel->SendFile("test_input.pdf");

    // éªŒè¯ï¼šè¶…æ—¶åè‡ªåŠ¨é‡ä¼ 
    assert(get_retransmission_count() > 0);
    assert(verify_file_integrity());
}

// æµ‹è¯•4: çª—å£å¤§å°å½±å“æµ‹è¯•
void test_window_size_impact() {
    std::vector<int> window_sizes = {1, 4, 8, 16, 32};

    for (int size : window_sizes) {
        reliableConfig.windowSize = size;

        auto start = std::chrono::high_resolution_clock::now();
        reliableChannel->SendFile("test_input.pdf");
        auto end = std::chrono::high_resolution_clock::now();

        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

        std::cout << "çª—å£å¤§å°: " << size
                  << ", è€—æ—¶: " << duration.count() << "ms" << std::endl;
    }
}
```

#### 5.1.2 æ·»åŠ UIçŠ¶æ€æœºæµ‹è¯•

**æ–°å¢æµ‹è¯•å·¥å…·**: `UIStateMachineTest.exe`

```cpp
// AutoTest/ui_state_machine_test.cpp

// æµ‹è¯•çŠ¶æ€è½¬æ¢è¡¨çš„å®Œæ•´æ€§
void test_state_transition_table() {
    TransmissionStateManager stateManager;

    // éå†æ‰€æœ‰çŠ¶æ€
    std::vector<TransmissionUIState> states = {
        TransmissionUIState::Idle,
        TransmissionUIState::Connecting,
        TransmissionUIState::Connected,
        TransmissionUIState::Initializing,
        TransmissionUIState::Transmitting,
        TransmissionUIState::Paused,
        TransmissionUIState::Completed,
        TransmissionUIState::Failed,
        TransmissionUIState::Disconnecting
    };

    // æµ‹è¯•æ‰€æœ‰åˆæ³•è½¬æ¢
    for (auto fromState : states) {
        for (auto toState : states) {
            stateManager.SetCurrentState(fromState);
            bool result = stateManager.RequestStateTransition(toState, "æµ‹è¯•");

            bool expected = is_valid_transition(fromState, toState);

            if (result != expected) {
                std::cerr << "çŠ¶æ€è½¬æ¢è¡¨é”™è¯¯: "
                          << state_to_string(fromState) << " -> "
                          << state_to_string(toState)
                          << ", é¢„æœŸ: " << expected
                          << ", å®é™…: " << result << std::endl;

                assert(false);
            }
        }
    }

    std::cout << "[OK] çŠ¶æ€è½¬æ¢è¡¨éªŒè¯é€šè¿‡" << std::endl;
}

// æµ‹è¯•æŒ‰é’®çŠ¶æ€åŒæ­¥
void test_button_state_sync() {
    ButtonStateManager buttonManager;
    TransmissionStateManager stateManager;

    // æµ‹è¯•åœºæ™¯ï¼šä»ç©ºé—²åˆ°ä¼ è¾“ä¸­
    stateManager.RequestStateTransition(TransmissionUIState::Idle, "åˆå§‹åŒ–");
    buttonManager.UpdateButtonStates(TransmissionUIState::Idle);

    // éªŒè¯ç©ºé—²çŠ¶æ€æŒ‰é’®
    assert(buttonManager.GetButtonState(ButtonID::Connect) == ButtonState::Enabled);
    assert(buttonManager.GetButtonState(ButtonID::Send) == ButtonState::Disabled);

    // åˆ‡æ¢åˆ°å·²è¿æ¥
    stateManager.RequestStateTransition(TransmissionUIState::Connected, "è¿æ¥æˆåŠŸ");
    buttonManager.UpdateButtonStates(TransmissionUIState::Connected);

    // éªŒè¯å·²è¿æ¥çŠ¶æ€æŒ‰é’®
    assert(buttonManager.GetButtonState(ButtonID::Disconnect) == ButtonState::Enabled);
    assert(buttonManager.GetButtonState(ButtonID::Send) == ButtonState::Enabled);

    // åˆ‡æ¢åˆ°ä¼ è¾“ä¸­
    stateManager.RequestStateTransition(TransmissionUIState::Transmitting, "å¼€å§‹ä¼ è¾“");
    buttonManager.UpdateButtonStates(TransmissionUIState::Transmitting);

    // éªŒè¯ä¼ è¾“ä¸­çŠ¶æ€æŒ‰é’®
    assert(buttonManager.GetButtonState(ButtonID::Send) == ButtonState::Disabled);
    assert(buttonManager.GetButtonState(ButtonID::Pause) == ButtonState::Enabled);
    assert(buttonManager.GetButtonState(ButtonID::Stop) == ButtonState::Enabled);

    std::cout << "[OK] æŒ‰é’®çŠ¶æ€åŒæ­¥æµ‹è¯•é€šè¿‡" << std::endl;
}
```

#### 5.1.3 æ·»åŠ é”™è¯¯æ¢å¤æµ‹è¯•

**æ–°å¢æµ‹è¯•åœºæ™¯**:
```cpp
// AutoTest/error_recovery_test.cpp

// æµ‹è¯•ä¼ è¾“ä¸­æ–­æ¢å¤
void test_transmission_interruption_recovery() {
    // å¼€å§‹ä¼ è¾“
    reliableChannel->SendFile("large_file.dat");

    // ä¸­é€”æ–­å¼€è¿æ¥
    std::this_thread::sleep_for(std::chrono::seconds(2));
    transport->Close();

    // ç­‰å¾…ä¸€æ®µæ—¶é—´
    std::this_thread::sleep_for(std::chrono::seconds(1));

    // é‡æ–°è¿æ¥
    transport->Open(config);

    // å°è¯•æ¢å¤ä¼ è¾“
    bool resumed = reliableChannel->ResumeTrans mission();

    // éªŒè¯æ–­ç‚¹ç»­ä¼ 
    assert(resumed);
    assert(verify_file_integrity());
}

// æµ‹è¯•CRCæ ¡éªŒå¤±è´¥æ¢å¤
void test_crc_failure_recovery() {
    // é…ç½®ä¼ è¾“å±‚æ¨¡æ‹Ÿæ•°æ®æŸå
    loopback->SetDataCorruptionRate(0.05);  // 5%æ•°æ®æŸåç‡

    // å‘é€æµ‹è¯•æ–‡ä»¶
    reliableChannel->SendFile("test_input.pdf");

    // éªŒè¯ï¼šå°½ç®¡æœ‰æ•°æ®æŸåï¼Œé€šè¿‡NAKå’Œé‡ä¼ ä»èƒ½å®Œæ•´æ¥æ”¶
    assert(get_nak_count() > 0);
    assert(verify_file_integrity());
}
```

### 5.2 å®Œå–„autonomous_fix_controller

**å½“å‰é—®é¢˜åˆ†æ**:
- âŒ ä¿®å¤ç­–ç•¥æœ‰é™ï¼Œåªæœ‰åŸºæœ¬çš„é”™è¯¯æ£€æµ‹
- âŒ é”™è¯¯å®šä½ä¸å‡†ç¡®
- âŒ ä¿®å¤éªŒè¯ä¸å……åˆ†

**æ”¹è¿›è®¡åˆ’**:

#### 5.2.1 å¢å¼ºé”™è¯¯è¯Šæ–­èƒ½åŠ›

**æ–°å¢é”™è¯¯åˆ†ææ¨¡å—**:
```python
# enhanced_error_diagnosis.py

class EnhancedErrorDiagnosis:
    """å¢å¼ºçš„é”™è¯¯è¯Šæ–­ç³»ç»Ÿ"""

    def __init__(self):
        self.error_patterns = self._load_error_patterns()
        self.fix_history = self._load_fix_history()

    def diagnose_error(self, error_info):
        """æ·±åº¦è¯Šæ–­é”™è¯¯"""

        diagnosis = {
            "error_type": None,
            "root_cause": None,
            "affected_files": [],
            "suggested_fixes": [],
            "confidence": 0.0
        }

        # 1. é”™è¯¯ç±»å‹åˆ†ç±»
        diagnosis["error_type"] = self._classify_error_type(error_info)

        # 2. æ ¹æœ¬åŸå› åˆ†æ
        diagnosis["root_cause"] = self._analyze_root_cause(error_info)

        # 3. å½±å“èŒƒå›´åˆ†æ
        diagnosis["affected_files"] = self._find_affected_files(error_info)

        # 4. åŸºäºå†å²çš„ä¿®å¤å»ºè®®
        diagnosis["suggested_fixes"] = self._suggest_fixes_from_history(
            diagnosis["error_type"],
            diagnosis["root_cause"]
        )

        # 5. è®¡ç®—è¯Šæ–­ç½®ä¿¡åº¦
        diagnosis["confidence"] = self._calculate_confidence(diagnosis)

        return diagnosis

    def _analyze_root_cause(self, error_info):
        """åˆ†ææ ¹æœ¬åŸå› """

        # ç¼–è¯‘é”™è¯¯æ ¹å› åˆ†æ
        if "error C2065" in error_info:  # æœªå£°æ˜çš„æ ‡è¯†ç¬¦
            # æœç´¢æ ‡è¯†ç¬¦å®šä¹‰
            identifier = extract_identifier(error_info)
            definition = search_definition(identifier)

            if definition:
                return f"æ ‡è¯†ç¬¦ {identifier} å·²å®šä¹‰åœ¨ {definition['file']}, ä½†ç¼ºå°‘å¤´æ–‡ä»¶åŒ…å«"
            else:
                return f"æ ‡è¯†ç¬¦ {identifier} æœªå®šä¹‰ï¼Œéœ€è¦å®ç°æˆ–å¯¼å…¥"

        # è¿è¡Œæ—¶é”™è¯¯æ ¹å› åˆ†æ
        elif "Access violation" in error_info:
            # åˆ†æè°ƒç”¨å †æ ˆ
            stack_trace = extract_stack_trace(error_info)
            problem_line = analyze_stack_trace(stack_trace)

            return f"ç©ºæŒ‡é’ˆè®¿é—®ï¼Œä½ç½®: {problem_line['file']}:{problem_line['line']}"

        # é€»è¾‘é”™è¯¯æ ¹å› åˆ†æ
        elif "æ— æ•ˆçŠ¶æ€è½¬æ¢" in error_info:
            # æå–çŠ¶æ€ä¿¡æ¯
            from_state, to_state = extract_states(error_info)

            # åˆ†æçŠ¶æ€è½¬æ¢è·¯å¾„
            valid_path = find_valid_transition_path(from_state, to_state)

            if valid_path:
                return f"çŠ¶æ€è½¬æ¢ {from_state}->{to_state} éæ³•ï¼Œåº”ä½¿ç”¨è·¯å¾„: {valid_path}"
            else:
                return f"çŠ¶æ€è½¬æ¢è¡¨é…ç½®é”™è¯¯ï¼Œç¼ºå°‘ {from_state}->{to_state} çš„è·¯å¾„"

        return "æœªçŸ¥åŸå› "

    def _suggest_fixes_from_history(self, error_type, root_cause):
        """åŸºäºå†å²è®°å½•å»ºè®®ä¿®å¤æ–¹æ¡ˆ"""

        # æœç´¢ç›¸ä¼¼çš„å†å²é”™è¯¯
        similar_errors = self.fix_history.search_similar(error_type, root_cause)

        fixes = []
        for historical_error in similar_errors:
            if historical_error["fix_success"]:
                fixes.append({
                    "fix_method": historical_error["fix_method"],
                    "success_rate": historical_error["success_rate"],
                    "description": historical_error["description"]
                })

        # æŒ‰æˆåŠŸç‡æ’åº
        fixes.sort(key=lambda x: x["success_rate"], reverse=True)

        return fixes
```

#### 5.2.2 æ·»åŠ æ›´å¤šä¿®å¤ç­–ç•¥

**æ–°å¢ä¿®å¤ç­–ç•¥**:
```python
# additional_fix_strategies.py

class StateTransitionFix:
    """çŠ¶æ€è½¬æ¢é”™è¯¯ä¿®å¤ç­–ç•¥"""

    def can_handle(self, error_type):
        return "çŠ¶æ€è½¬æ¢" in error_type or "StateTransition" in error_type

    def fix(self, error_details):
        """ä¿®å¤çŠ¶æ€è½¬æ¢é”™è¯¯"""

        # æå–çŠ¶æ€ä¿¡æ¯
        from_state = error_details.get("from_state")
        to_state = error_details.get("to_state")
        file_path = error_details.get("file_path", "src/TransmissionStateManager.cpp")

        # è¯»å–çŠ¶æ€è½¬æ¢è¡¨
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # æŸ¥æ‰¾çŠ¶æ€è½¬æ¢è¡¨å®šä¹‰
        table_pattern = r'const bool TransmissionStateManager::m_transitionTable\[\]\[TRANSITION_TABLE_SIZE\] = \{([^}]+)\}'
        match = re.search(table_pattern, content)

        if match:
            table_str = match.group(1)

            # è§£æè½¬æ¢è¡¨
            rows = [row.strip() for row in table_str.split('},')]

            # è®¡ç®—éœ€è¦ä¿®æ”¹çš„ä½ç½®
            from_index = get_state_index(from_state)
            to_index = get_state_index(to_state)

            # ä¿®æ”¹è½¬æ¢è¡¨
            row_parts = rows[from_index].strip('{ }').split(',')
            row_parts[to_index] = 'true'

            rows[from_index] = '    {' + ', '.join(row_parts) + '}'

            # é‡æ–°ç»„è£…
            new_table_str = ',\n'.join(rows)
            new_content = content.replace(match.group(1), new_table_str)

            # å†™å›æ–‡ä»¶
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(new_content)

            return f"å·²å…è®¸çŠ¶æ€è½¬æ¢: {from_state} -> {to_state}"

        return "ä¿®å¤å¤±è´¥ï¼šæœªæ‰¾åˆ°çŠ¶æ€è½¬æ¢è¡¨"

class UIControlAccessFix:
    """UIæ§ä»¶è®¿é—®é”™è¯¯ä¿®å¤ç­–ç•¥"""

    def can_handle(self, error_type):
        return "æ§ä»¶" in error_type or "DDX" in error_type

    def fix(self, error_details):
        """ä¿®å¤æ§ä»¶è®¿é—®é”™è¯¯"""

        control_name = error_details.get("control_name")
        file_path = error_details.get("file_path")

        # è¯»å–æ–‡ä»¶
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()

        # æŸ¥æ‰¾æ§ä»¶è®¿é—®ä½ç½®
        for i, line in enumerate(lines):
            if control_name in line and '->' in line:
                # åœ¨è®¿é—®å‰æ·»åŠ æ£€æŸ¥
                indent = len(line) - len(line.lstrip())
                check_code = ' ' * indent + f'if ({control_name}.GetSafeHwnd()) {{\n'
                close_brace = ' ' * indent + '}\n'

                # æ’å…¥æ£€æŸ¥ä»£ç 
                lines.insert(i, check_code)
                lines.insert(i + 2, close_brace)

                # å†™å›æ–‡ä»¶
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.writelines(lines)

                return f"å·²ä¸ºæ§ä»¶ {control_name} æ·»åŠ å®‰å…¨æ£€æŸ¥"

        return "ä¿®å¤å¤±è´¥ï¼šæœªæ‰¾åˆ°æ§ä»¶è®¿é—®ä»£ç "
```

### 5.3 åˆ›å»ºåŠŸèƒ½æ¨¡å—æµ‹è¯•å·¥å…·

**ç›®æ ‡**: ä¸ºæ¯ä¸ªä¸»è¦åŠŸèƒ½æ¨¡å—åˆ›å»ºç‹¬ç«‹çš„è‡ªåŠ¨åŒ–æµ‹è¯•å·¥å…·

#### 5.3.1 ä¸²å£åŠŸèƒ½æµ‹è¯•å·¥å…·

**å·¥å…·åç§°**: `SerialPortTest.exe`

**åŠŸèƒ½**:
- è‡ªåŠ¨æ£€æµ‹å¯ç”¨ä¸²å£
- æµ‹è¯•ä¸åŒæ³¢ç‰¹ç‡é…ç½®
- æµ‹è¯•æµæ§é…ç½®
- æµ‹è¯•æ•°æ®æ”¶å‘æ­£ç¡®æ€§

**å®ç°**:
```cpp
// TestTools/SerialPortTest/main.cpp

int main() {
    std::cout << "ä¸²å£åŠŸèƒ½è‡ªåŠ¨åŒ–æµ‹è¯•å·¥å…·" << std::endl;

    // 1. æšä¸¾å¯ç”¨ä¸²å£
    auto available_ports = enumerate_serial_ports();
    std::cout << "å‘ç° " << available_ports.size() << " ä¸ªä¸²å£" << std::endl;

    // 2. åˆ›å»ºè™šæ‹Ÿä¸²å£å¯¹ï¼ˆä½¿ç”¨com0comï¼‰
    auto virtual_ports = create_virtual_serial_pair();

    if (!virtual_ports.first.empty()) {
        // 3. æµ‹è¯•å‘é€ç«¯
        SerialTransport sender;
        TransportConfig sender_config;
        sender_config.portName = virtual_ports.first;
        sender_config.baudRate = 115200;

        // 4. æµ‹è¯•æ¥æ”¶ç«¯
        SerialTransport receiver;
        TransportConfig receiver_config;
        receiver_config.portName = virtual_ports.second;
        receiver_config.baudRate = 115200;

        // 5. æ‰“å¼€ç«¯å£
        sender.Open(sender_config);
        receiver.Open(receiver_config);

        // 6. æµ‹è¯•æ•°æ®ä¼ è¾“
        std::vector<uint8_t> test_data = generate_test_data(1024);
        sender.Write(test_data.data(), test_data.size());

        // 7. æ¥æ”¶éªŒè¯
        std::vector<uint8_t> received_data(1024);
        size_t received = receiver.Read(received_data.data(), 1024);

        // 8. éªŒè¯ç»“æœ
        assert(received == 1024);
        assert(test_data == received_data);

        std::cout << "[OK] ä¸²å£åŠŸèƒ½æµ‹è¯•é€šè¿‡" << std::endl;
    }

    return 0;
}
```

#### 5.3.2 å¯é ä¼ è¾“åè®®æµ‹è¯•å·¥å…·

**å·¥å…·åç§°**: `ReliableProtocolTest.exe`ï¼ˆå¢å¼ºç‰ˆAutoTestï¼‰

**æ–°å¢åŠŸèƒ½**:
- å‹åŠ›æµ‹è¯•ï¼ˆå¤§é‡å°æ–‡ä»¶ï¼‰
- ç¨³å®šæ€§æµ‹è¯•ï¼ˆé•¿æ—¶é—´è¿è¡Œï¼‰
- æ€§èƒ½æµ‹è¯•ï¼ˆååé‡/å»¶è¿Ÿï¼‰
- è¾¹ç•Œæ¡ä»¶æµ‹è¯•

**å®ç°**:
```cpp
// TestTools/ReliableProtocolTest/stress_test.cpp

void stress_test_small_files() {
    """å‹åŠ›æµ‹è¯•ï¼šå¤§é‡å°æ–‡ä»¶ä¼ è¾“"""

    const int file_count = 1000;
    const int file_size = 1024;  // 1KB

    std::cout << "å‹åŠ›æµ‹è¯•ï¼šä¼ è¾“ " << file_count << " ä¸ªå°æ–‡ä»¶" << std::endl;

    int success_count = 0;
    int failure_count = 0;

    for (int i = 0; i < file_count; i++) {
        // ç”Ÿæˆæµ‹è¯•æ–‡ä»¶
        std::vector<uint8_t> test_data = generate_random_data(file_size);

        // ä¼ è¾“
        bool result = reliable_channel->SendData(test_data);

        if (result) {
            success_count++;
        } else {
            failure_count++;
        }

        if ((i + 1) % 100 == 0) {
            std::cout << "è¿›åº¦: " << (i + 1) << "/" << file_count << std::endl;
        }
    }

    std::cout << "æˆåŠŸ: " << success_count << ", å¤±è´¥: " << failure_count << std::endl;

    assert(failure_count == 0);
}

void stability_test_long_running() {
    """ç¨³å®šæ€§æµ‹è¯•ï¼šé•¿æ—¶é—´è¿è¡Œ"""

    const int duration_minutes = 60;  // è¿è¡Œ1å°æ—¶
    const int interval_seconds = 10;

    std::cout << "ç¨³å®šæ€§æµ‹è¯•ï¼šæŒç»­è¿è¡Œ " << duration_minutes << " åˆ†é’Ÿ" << std::endl;

    auto start_time = std::chrono::steady_clock::now();
    auto end_time = start_time + std::chrono::minutes(duration_minutes);

    int iteration = 0;

    while (std::chrono::steady_clock::now() < end_time) {
        // æ‰§è¡Œä¸€æ¬¡ä¼ è¾“
        std::vector<uint8_t> test_data = generate_random_data(10240);  // 10KB
        bool result = reliable_channel->SendData(test_data);

        if (!result) {
            std::cerr << "ç¬¬ " << iteration << " æ¬¡ä¼ è¾“å¤±è´¥" << std::endl;
            assert(false);
        }

        iteration++;

        // ç­‰å¾…é—´éš”
        std::this_thread::sleep_for(std::chrono::seconds(interval_seconds));
    }

    std::cout << "ç¨³å®šæ€§æµ‹è¯•å®Œæˆï¼Œå…±æ‰§è¡Œ " << iteration << " æ¬¡ä¼ è¾“" << std::endl;
}
```

### 5.4 å»ºç«‹CI/CDè‡ªåŠ¨åŒ–æµç¨‹

**ç›®æ ‡**: å»ºç«‹æŒç»­é›†æˆ/æŒç»­éƒ¨ç½²æµç¨‹ï¼Œå®ç°ä»£ç æäº¤åè‡ªåŠ¨ç¼–è¯‘ã€æµ‹è¯•ã€éƒ¨ç½²

#### 5.4.1 CI/CDæµç¨‹è®¾è®¡

```
ä»£ç æäº¤
   â†“
[è§¦å‘CI]
   â†“
1. ç¯å¢ƒæ£€æŸ¥
   - æ£€æŸ¥Visual Studio
   - æ£€æŸ¥ä¾èµ–åº“
   - æ¸…ç†æ—§æ„å»º
   â†“
2. é™æ€åˆ†æ
   - cppcheck
   - clang-tidy
   - VSä»£ç åˆ†æ
   â†“
3. ç¼–è¯‘æ„å»º
   - Debugç‰ˆæœ¬
   - Releaseç‰ˆæœ¬
   - 0 error 0 warning
   â†“
4. å•å…ƒæµ‹è¯•
   - Transportå±‚æµ‹è¯•
   - Protocolå±‚æµ‹è¯•
   - UIå±‚æµ‹è¯•
   â†“
5. é›†æˆæµ‹è¯•
   - æ¨¡å—é›†æˆæµ‹è¯•
   - ç«¯åˆ°ç«¯æµ‹è¯•
   â†“
6. ç³»ç»Ÿæµ‹è¯•
   - åŠŸèƒ½å®Œæ•´æ€§æµ‹è¯•
   - æ€§èƒ½æµ‹è¯•
   - å…¼å®¹æ€§æµ‹è¯•
   â†“
7. ä»£ç å®¡æŸ¥
   - architect-reviewer
   - code-reviewer
   â†“
8. è¦†ç›–ç‡æ£€æŸ¥
   - æµ‹é‡è¦†ç›–ç‡
   - éªŒè¯â‰¥90%
   â†“
9. ç‰ˆæœ¬éƒ¨ç½²
   - ç”Ÿæˆå®‰è£…åŒ…
   - åˆ›å»ºç‰ˆæœ¬æ ‡ç­¾
   - æ¨é€åˆ°ä»“åº“
   â†“
[å®Œæˆ]
```

#### 5.4.2 CI/CDè„šæœ¬å®ç°

**ä¸»æ§è„šæœ¬**: `ci_cd_pipeline.py`

```python
# ci_cd_pipeline.py
# CI/CDä¸»æ§è„šæœ¬

import subprocess
import sys
import json
from datetime import datetime

class CICDPipeline:
    def __init__(self):
        self.pipeline_start_time = datetime.now()
        self.results = {
            "stages": [],
            "overall_status": "UNKNOWN"
        }

    def run_pipeline(self):
        """è¿è¡Œå®Œæ•´çš„CI/CDæµç¨‹"""

        print("=" * 60)
        print("PortMaster CI/CD Pipeline")
        print("=" * 60)
        print()

        # é˜¶æ®µ1: ç¯å¢ƒæ£€æŸ¥
        if not self.stage_environment_check():
            return self.fail_pipeline("ç¯å¢ƒæ£€æŸ¥å¤±è´¥")

        # é˜¶æ®µ2: é™æ€åˆ†æ
        if not self.stage_static_analysis():
            return self.fail_pipeline("é™æ€åˆ†æå¤±è´¥")

        # é˜¶æ®µ3: ç¼–è¯‘æ„å»º
        if not self.stage_build():
            return self.fail_pipeline("ç¼–è¯‘æ„å»ºå¤±è´¥")

        # é˜¶æ®µ4: å•å…ƒæµ‹è¯•
        if not self.stage_unit_tests():
            return self.fail_pipeline("å•å…ƒæµ‹è¯•å¤±è´¥")

        # é˜¶æ®µ5: é›†æˆæµ‹è¯•
        if not self.stage_integration_tests():
            return self.fail_pipeline("é›†æˆæµ‹è¯•å¤±è´¥")

        # é˜¶æ®µ6: ç³»ç»Ÿæµ‹è¯•
        if not self.stage_system_tests():
            return self.fail_pipeline("ç³»ç»Ÿæµ‹è¯•å¤±è´¥")

        # é˜¶æ®µ7: ä»£ç å®¡æŸ¥
        if not self.stage_code_review():
            return self.fail_pipeline("ä»£ç å®¡æŸ¥å¤±è´¥")

        # é˜¶æ®µ8: è¦†ç›–ç‡æ£€æŸ¥
        if not self.stage_coverage_check():
            return self.fail_pipeline("è¦†ç›–ç‡ä¸è¾¾æ ‡")

        # é˜¶æ®µ9: ç‰ˆæœ¬éƒ¨ç½²
        if not self.stage_deployment():
            return self.fail_pipeline("ç‰ˆæœ¬éƒ¨ç½²å¤±è´¥")

        # æµç¨‹æˆåŠŸ
        return self.success_pipeline()

    def stage_environment_check(self):
        """é˜¶æ®µ1: ç¯å¢ƒæ£€æŸ¥"""
        print("[Stage 1/9] ç¯å¢ƒæ£€æŸ¥")

        stage_result = {
            "name": "environment_check",
            "status": "UNKNOWN",
            "checks": []
        }

        # æ£€æŸ¥Visual Studio
        vs_check = check_visual_studio()
        stage_result["checks"].append(vs_check)

        # æ£€æŸ¥ä¾èµ–åº“
        deps_check = check_dependencies()
        stage_result["checks"].append(deps_check)

        # æ¸…ç†æ—§æ„å»º
        clean_result = clean_old_builds()
        stage_result["checks"].append(clean_result)

        # åˆ¤æ–­ç»“æœ
        if all(c["status"] == "PASS" for c in stage_result["checks"]):
            stage_result["status"] = "PASS"
            print("[OK] ç¯å¢ƒæ£€æŸ¥é€šè¿‡\n")
            self.results["stages"].append(stage_result)
            return True
        else:
            stage_result["status"] = "FAIL"
            print("[FAIL] ç¯å¢ƒæ£€æŸ¥å¤±è´¥\n")
            self.results["stages"].append(stage_result)
            return False

    def stage_static_analysis(self):
        """é˜¶æ®µ2: é™æ€åˆ†æ"""
        print("[Stage 2/9] é™æ€ä»£ç åˆ†æ")

        # è¿è¡Œé™æ€åˆ†æ
        result = subprocess.run(
            ["python", "static_analysis.py"],
            capture_output=True,
            text=True
        )

        if result.returncode == 0:
            print("[OK] é™æ€åˆ†æé€šè¿‡\n")
            self.results["stages"].append({
                "name": "static_analysis",
                "status": "PASS"
            })
            return True
        else:
            print(f"[FAIL] é™æ€åˆ†æå¤±è´¥: {result.stderr}\n")
            self.results["stages"].append({
                "name": "static_analysis",
                "status": "FAIL",
                "error": result.stderr
            })
            return False

    def stage_build(self):
        """é˜¶æ®µ3: ç¼–è¯‘æ„å»º"""
        print("[Stage 3/9] ç¼–è¯‘æ„å»º")

        # ç¼–è¯‘Debugç‰ˆæœ¬
        result = subprocess.run(
            ["cmd.exe", "/c", "autobuild_x86_debug.bat"],
            capture_output=True,
            text=True
        )

        if result.returncode == 0:
            # éªŒè¯0 error 0 warning
            with open("msbuild_debug.log", 'r', encoding='utf-8') as f:
                log_content = f.read()

            if "0 Error(s)" in log_content and "0 Warning(s)" in log_content:
                print("[OK] ç¼–è¯‘æˆåŠŸ: 0 error, 0 warning\n")
                self.results["stages"].append({
                    "name": "build",
                    "status": "PASS"
                })
                return True

        print(f"[FAIL] ç¼–è¯‘å¤±è´¥\n")
        self.results["stages"].append({
            "name": "build",
            "status": "FAIL"
        })
        return False

    def stage_unit_tests(self):
        """é˜¶æ®µ4: å•å…ƒæµ‹è¯•"""
        print("[Stage 4/9] å•å…ƒæµ‹è¯•")

        test_tools = [
            "TransportUnitTest.exe",
            "ProtocolUnitTest.exe",
            "UIUnitTest.exe"
        ]

        all_passed = True

        for tool in test_tools:
            result = subprocess.run(
                [f"TestTools\\{tool}"],
                capture_output=True,
                text=True
            )

            if result.returncode != 0:
                print(f"[FAIL] {tool} å¤±è´¥")
                all_passed = False
            else:
                print(f"[OK] {tool} é€šè¿‡")

        if all_passed:
            print("[OK] å•å…ƒæµ‹è¯•å…¨éƒ¨é€šè¿‡\n")
            self.results["stages"].append({
                "name": "unit_tests",
                "status": "PASS"
            })
            return True
        else:
            print("[FAIL] å•å…ƒæµ‹è¯•å¤±è´¥\n")
            self.results["stages"].append({
                "name": "unit_tests",
                "status": "FAIL"
            })
            return False

    def stage_integration_tests(self):
        """é˜¶æ®µ5: é›†æˆæµ‹è¯•"""
        print("[Stage 5/9] é›†æˆæµ‹è¯•")

        result = subprocess.run(
            ["TestTools\\IntegrationTest.exe"],
            capture_output=True,
            text=True
        )

        if result.returncode == 0:
            print("[OK] é›†æˆæµ‹è¯•é€šè¿‡\n")
            self.results["stages"].append({
                "name": "integration_tests",
                "status": "PASS"
            })
            return True
        else:
            print("[FAIL] é›†æˆæµ‹è¯•å¤±è´¥\n")
            self.results["stages"].append({
                "name": "integration_tests",
                "status": "FAIL"
            })
            return False

    def stage_system_tests(self):
        """é˜¶æ®µ6: ç³»ç»Ÿæµ‹è¯•"""
        print("[Stage 6/9] ç³»ç»Ÿæµ‹è¯•")

        result = subprocess.run(
            ["python", "system_auto_test.py"],
            capture_output=True,
            text=True
        )

        if result.returncode == 0:
            print("[OK] ç³»ç»Ÿæµ‹è¯•é€šè¿‡\n")
            self.results["stages"].append({
                "name": "system_tests",
                "status": "PASS"
            })
            return True
        else:
            print("[FAIL] ç³»ç»Ÿæµ‹è¯•å¤±è´¥\n")
            self.results["stages"].append({
                "name": "system_tests",
                "status": "FAIL"
            })
            return False

    def stage_code_review(self):
        """é˜¶æ®µ7: ä»£ç å®¡æŸ¥"""
        print("[Stage 7/9] ä»£ç å®¡æŸ¥")

        # è·å–å˜æ›´æ–‡ä»¶
        changed_files = get_git_changed_files()

        # è°ƒç”¨å®¡æŸ¥agentsï¼ˆè¿™é‡Œç®€åŒ–ä¸ºæ¨¡æ‹Ÿï¼‰
        review_result = perform_code_review(changed_files)

        if review_result["status"] == "PASS":
            print("[OK] ä»£ç å®¡æŸ¥é€šè¿‡\n")
            self.results["stages"].append({
                "name": "code_review",
                "status": "PASS"
            })
            return True
        else:
            print(f"[FAIL] ä»£ç å®¡æŸ¥å¤±è´¥: {review_result['issues']}\n")
            self.results["stages"].append({
                "name": "code_review",
                "status": "FAIL",
                "issues": review_result["issues"]
            })
            return False

    def stage_coverage_check(self):
        """é˜¶æ®µ8: è¦†ç›–ç‡æ£€æŸ¥"""
        print("[Stage 8/9] ä»£ç è¦†ç›–ç‡æ£€æŸ¥")

        result = subprocess.run(
            ["python", "coverage_measurement.py"],
            capture_output=True,
            text=True
        )

        if result.returncode == 0:
            print("[OK] è¦†ç›–ç‡è¾¾æ ‡\n")
            self.results["stages"].append({
                "name": "coverage_check",
                "status": "PASS"
            })
            return True
        else:
            print("[FAIL] è¦†ç›–ç‡ä¸è¾¾æ ‡\n")
            self.results["stages"].append({
                "name": "coverage_check",
                "status": "FAIL"
            })
            return False

    def stage_deployment(self):
        """é˜¶æ®µ9: ç‰ˆæœ¬éƒ¨ç½²"""
        print("[Stage 9/9] ç‰ˆæœ¬éƒ¨ç½²")

        # ç”Ÿæˆç‰ˆæœ¬å·
        version = generate_version_number()

        # åˆ›å»ºGitæ ‡ç­¾
        subprocess.run(["git", "tag", f"v{version}"])

        # æ¨é€åˆ°è¿œç¨‹
        subprocess.run(["git", "push", "--tags"])

        print(f"[OK] ç‰ˆæœ¬ v{version} éƒ¨ç½²æˆåŠŸ\n")
        self.results["stages"].append({
            "name": "deployment",
            "status": "PASS",
            "version": version
        })
        return True

    def success_pipeline(self):
        """æµç¨‹æˆåŠŸ"""
        self.results["overall_status"] = "SUCCESS"

        duration = (datetime.now() - self.pipeline_start_time).total_seconds()

        print("=" * 60)
        print(f"CI/CD Pipeline æˆåŠŸå®Œæˆï¼è€—æ—¶: {duration:.2f}ç§’")
        print("=" * 60)

        # ä¿å­˜ç»“æœ
        with open(f"ci_cd_result_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json", 'w') as f:
            json.dump(self.results, f, indent=2)

        return 0

    def fail_pipeline(self, reason):
        """æµç¨‹å¤±è´¥"""
        self.results["overall_status"] = "FAILED"
        self.results["failure_reason"] = reason

        print("=" * 60)
        print(f"CI/CD Pipeline å¤±è´¥: {reason}")
        print("=" * 60)

        # ä¿å­˜ç»“æœ
        with open(f"ci_cd_result_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json", 'w') as f:
            json.dump(self.results, f, indent=2)

        return 1

if __name__ == "__main__":
    pipeline = CICDPipeline()
    sys.exit(pipeline.run_pipeline())
```

---

## 6. æ‰§è¡ŒæŒ‡å—

### 6.1 å¼€å‘è€…ä½¿ç”¨æ‰‹å†Œ

#### 6.1.1 å¯åŠ¨è‡ªåŠ¨åŒ–å¼€å‘æµç¨‹

**å‘½ä»¤è¡Œå¯åŠ¨**:
```bash
# å®Œæ•´è‡ªåŠ¨åŒ–æµç¨‹
python auto_dev_workflow.py --mode full --requirement "éœ€æ±‚æè¿°"

# ä»…æµ‹è¯•æµç¨‹
python auto_dev_workflow.py --mode test-only

# ä»…ä¿®å¤æµç¨‹
python auto_dev_workflow.py --mode fix-only --error-log "error.log"
```

**é…ç½®æ–‡ä»¶**: `auto_dev_config.json`
```json
{
  "workflow": {
    "max_iterations": 20,
    "max_fix_attempts": 3,
    "enable_auto_commit": true,
    "enable_performance_check": true
  },
  "testing": {
    "coverage_threshold": 90,
    "performance_regression_threshold": 20,
    "enable_stress_testing": false
  },
  "quality": {
    "enable_static_analysis": true,
    "enable_code_review": true,
    "enforce_zero_warnings": true
  },
  "notifications": {
    "enable_email": false,
    "enable_slack": false,
    "notify_on_failure": true,
    "notify_on_success": false
  }
}
```

#### 6.1.2 ç›‘æ§è‡ªåŠ¨åŒ–è¿›åº¦

**å®æ—¶æ—¥å¿—æŸ¥çœ‹**:
```bash
# æŸ¥çœ‹ä¸»æµç¨‹æ—¥å¿—
tail -f auto_dev_workflow.log

# æŸ¥çœ‹æµ‹è¯•æ—¥å¿—
tail -f test_execution.log

# æŸ¥çœ‹ä¿®å¤æ—¥å¿—
tail -f auto_fix.log
```

**è¿›åº¦å¯è§†åŒ–ç•Œé¢**ï¼ˆå¯é€‰ï¼‰:
```python
# progress_dashboard.py
# Webç•Œé¢æŸ¥çœ‹è¿›åº¦

from flask import Flask, render_template, jsonify

app = Flask(__name__)

@app.route('/')
def dashboard():
    return render_template('dashboard.html')

@app.route('/api/progress')
def get_progress():
    # è¯»å–å½“å‰è¿›åº¦
    progress = read_current_progress()
    return jsonify(progress)

if __name__ == '__main__':
    app.run(port=8080)
```

#### 6.1.3 äººå·¥ä»‹å…¥å¤„ç†

**è§¦å‘äººå·¥ä»‹å…¥çš„æƒ…å†µ**:
```python
# manual_intervention.py
# äººå·¥ä»‹å…¥å¤„ç†

def handle_manual_intervention(intervention_type, details):
    """å¤„ç†äººå·¥ä»‹å…¥"""

    if intervention_type == "REQUIREMENT_CLARIFICATION":
        # éœ€æ±‚æ¾„æ¸…
        print(f"éœ€è¦æ¾„æ¸…éœ€æ±‚: {details['question']}")
        user_input = input("è¯·æä¾›æ¾„æ¸…: ")
        return {"clarification": user_input}

    elif intervention_type == "FIX_FAILED":
        # è‡ªåŠ¨ä¿®å¤å¤±è´¥
        print(f"è‡ªåŠ¨ä¿®å¤å¤±è´¥: {details['error']}")
        print(f"å°è¯•æ¬¡æ•°: {details['attempts']}")
        print(f"å»ºè®®ä¿®å¤æ–¹æ¡ˆ: {details['suggestions']}")

        choice = input("é€‰æ‹©æ“ä½œ: (1)æ‰‹åŠ¨ä¿®å¤ (2)è·³è¿‡ (3)ç»ˆæ­¢: ")

        if choice == "1":
            # ç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨ä¿®å¤
            input("è¯·æ‰‹åŠ¨ä¿®å¤åæŒ‰Enterç»§ç»­...")
            return {"action": "retry"}
        elif choice == "2":
            return {"action": "skip"}
        else:
            return {"action": "abort"}

    elif intervention_type == "HARDWARE_TEST_NEEDED":
        # éœ€è¦ç¡¬ä»¶æµ‹è¯•
        print("éœ€è¦çœŸå®ç¡¬ä»¶æµ‹è¯•:")
        print(f"æµ‹è¯•æ­¥éª¤: {details['test_steps']}")
        print(f"æ‰€éœ€è®¾å¤‡: {details['required_devices']}")

        input("è¯·å‡†å¤‡ç¡¬ä»¶ç¯å¢ƒåæŒ‰Enterå¼€å§‹æµ‹è¯•...")

        # æ‰§è¡Œç¡¬ä»¶æµ‹è¯•
        test_result = execute_hardware_test(details)

        return {"test_result": test_result}
```

### 6.2 æµ‹è¯•å·¥å…·å¼€å‘è§„èŒƒ

#### 6.2.1 æµ‹è¯•å·¥å…·æ ‡å‡†ç»“æ„

**ç›®å½•ç»“æ„**:
```
TestTools/
â”œâ”€â”€ TransportUnitTest/
â”‚   â”œâ”€â”€ main.cpp
â”‚   â”œâ”€â”€ serial_test.cpp
â”‚   â”œâ”€â”€ loopback_test.cpp
â”‚   â”œâ”€â”€ network_test.cpp
â”‚   â””â”€â”€ CMakeLists.txt
â”œâ”€â”€ ProtocolUnitTest/
â”‚   â”œâ”€â”€ main.cpp
â”‚   â”œâ”€â”€ crc32_test.cpp
â”‚   â”œâ”€â”€ frame_codec_test.cpp
â”‚   â”œâ”€â”€ reliable_channel_test.cpp
â”‚   â””â”€â”€ CMakeLists.txt
â”œâ”€â”€ UIUnitTest/
â”‚   â”œâ”€â”€ main.cpp
â”‚   â”œâ”€â”€ state_machine_test.cpp
â”‚   â”œâ”€â”€ button_state_test.cpp
â”‚   â””â”€â”€ CMakeLists.txt
â”œâ”€â”€ IntegrationTest/
â”‚   â”œâ”€â”€ main.cpp
â”‚   â”œâ”€â”€ transport_protocol_test.cpp
â”‚   â””â”€â”€ CMakeLists.txt
â””â”€â”€ SystemTest/
    â”œâ”€â”€ main.cpp
    â”œâ”€â”€ e2e_test.cpp
    â””â”€â”€ CMakeLists.txt
```

**æµ‹è¯•å·¥å…·æ¨¡æ¿**:
```cpp
// test_tool_template.cpp
// æµ‹è¯•å·¥å…·æ ‡å‡†æ¨¡æ¿

#include <iostream>
#include <vector>
#include <string>
#include <cassert>

// æµ‹è¯•ç»“æœç»“æ„
struct TestResult {
    std::string test_name;
    bool passed;
    std::string error_message;
};

// æµ‹è¯•å¥—ä»¶åŸºç±»
class TestSuite {
public:
    virtual ~TestSuite() = default;

    virtual void SetUp() {
        // æµ‹è¯•å‰å‡†å¤‡
    }

    virtual void TearDown() {
        // æµ‹è¯•åæ¸…ç†
    }

    virtual std::vector<TestResult> RunTests() = 0;

protected:
    void AssertTrue(bool condition, const std::string& message) {
        if (!condition) {
            throw std::runtime_error(message);
        }
    }

    void AssertEqual(int expected, int actual, const std::string& context) {
        if (expected != actual) {
            throw std::runtime_error(
                context + ": expected " + std::to_string(expected) +
                ", got " + std::to_string(actual)
            );
        }
    }
};

// å…·ä½“æµ‹è¯•å¥—ä»¶ç¤ºä¾‹
class MyTestSuite : public TestSuite {
public:
    std::vector<TestResult> RunTests() override {
        std::vector<TestResult> results;

        // æµ‹è¯•1
        results.push_back(RunTest("Test1", [this]() {
            this->Test1();
        }));

        // æµ‹è¯•2
        results.push_back(RunTest("Test2", [this]() {
            this->Test2();
        }));

        return results;
    }

private:
    void Test1() {
        // æµ‹è¯•é€»è¾‘
        AssertTrue(true, "Test1 should pass");
    }

    void Test2() {
        // æµ‹è¯•é€»è¾‘
        AssertEqual(5, 2 + 3, "Math test");
    }

    TestResult RunTest(const std::string& name, std::function<void()> test_func) {
        TestResult result;
        result.test_name = name;

        try {
            SetUp();
            test_func();
            TearDown();

            result.passed = true;
            std::cout << "[PASS] " << name << std::endl;
        }
        catch (const std::exception& e) {
            result.passed = false;
            result.error_message = e.what();
            std::cout << "[FAIL] " << name << ": " << e.what() << std::endl;
        }

        return result;
    }
};

// ä¸»å‡½æ•°
int main() {
    MyTestSuite suite;

    auto results = suite.RunTests();

    int passed = 0;
    int failed = 0;

    for (const auto& result : results) {
        if (result.passed) {
            passed++;
        } else {
            failed++;
        }
    }

    std::cout << "\n==== æµ‹è¯•æ€»ç»“ ====" << std::endl;
    std::cout << "é€šè¿‡: " << passed << std::endl;
    std::cout << "å¤±è´¥: " << failed << std::endl;

    return (failed > 0) ? 1 : 0;
}
```

#### 6.2.2 æµ‹è¯•æ•°æ®ç”Ÿæˆè§„èŒƒ

**æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨**:
```python
# test_data_generator.py
# æ ‡å‡†æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨

import os
import random
import hashlib

class TestDataGenerator:
    """æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨"""

    def __init__(self, output_dir="test_data"):
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)

    def generate_text_file(self, size_bytes, filename=None):
        """ç”Ÿæˆéšæœºæ–‡æœ¬æ–‡ä»¶"""
        if filename is None:
            filename = f"text_{size_bytes}B.txt"

        filepath = os.path.join(self.output_dir, filename)

        with open(filepath, 'w', encoding='utf-8') as f:
            # ç”Ÿæˆéšæœºæ–‡æœ¬
            chars_needed = size_bytes
            while chars_needed > 0:
                line = self._random_text_line(min(chars_needed, 80))
                f.write(line + '\n')
                chars_needed -= len(line) + 1

        return filepath

    def generate_binary_file(self, size_bytes, filename=None):
        """ç”ŸæˆéšæœºäºŒè¿›åˆ¶æ–‡ä»¶"""
        if filename is None:
            filename = f"binary_{size_bytes}B.bin"

        filepath = os.path.join(self.output_dir, filename)

        with open(filepath, 'wb') as f:
            f.write(os.urandom(size_bytes))

        return filepath

    def generate_pdf_file(self, size_bytes, filename=None):
        """ç”ŸæˆPDFæ–‡ä»¶ï¼ˆç®€åŒ–ç‰ˆï¼‰"""
        if filename is None:
            filename = f"document_{size_bytes}B.pdf"

        filepath = os.path.join(self.output_dir, filename)

        # ä½¿ç”¨reportlabç”ŸæˆPDF
        from reportlab.pdfgen import canvas
        from reportlab.lib.pagesizes import letter

        c = canvas.Canvas(filepath, pagesize=letter)

        # æ·»åŠ å†…å®¹ç›´åˆ°è¾¾åˆ°æ‰€éœ€å¤§å°
        page_count = 0
        while os.path.getsize(filepath) < size_bytes:
            c.drawString(100, 700 - (page_count % 20) * 30,
                        self._random_text_line(50))

            if page_count % 20 == 19:
                c.showPage()

            page_count += 1

        c.save()

        return filepath

    def generate_test_suite(self):
        """ç”Ÿæˆå®Œæ•´æµ‹è¯•æ•°æ®é›†"""
        test_files = []

        # å°æ–‡ä»¶ï¼ˆ<1KBï¼‰
        test_files.append(self.generate_text_file(100, "tiny_text.txt"))
        test_files.append(self.generate_binary_file(500, "small_binary.bin"))

        # ä¸­ç­‰æ–‡ä»¶ï¼ˆ1KB-1MBï¼‰
        test_files.append(self.generate_text_file(10*1024, "medium_text.txt"))
        test_files.append(self.generate_binary_file(100*1024, "medium_binary.bin"))

        # å¤§æ–‡ä»¶ï¼ˆ>1MBï¼‰
        test_files.append(self.generate_binary_file(5*1024*1024, "large_binary.dat"))
        test_files.append(self.generate_pdf_file(2*1024*1024, "large_document.pdf"))

        # ç‰¹æ®Šæ–‡ä»¶
        test_files.append(self.generate_binary_file(0, "empty.bin"))
        test_files.append(self.generate_binary_file(1, "single_byte.bin"))

        # åŒ…å«ä¸­æ–‡çš„æ–‡ä»¶å
        test_files.append(self.generate_text_file(1024, "æµ‹è¯•æ–‡ä»¶_ä¸­æ–‡åç§°.txt"))

        return test_files

    def _random_text_line(self, length):
        """ç”Ÿæˆéšæœºæ–‡æœ¬è¡Œ"""
        import string
        return ''.join(random.choices(
            string.ascii_letters + string.digits + string.punctuation + ' ',
            k=length
        ))

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    generator = TestDataGenerator()
    files = generator.generate_test_suite()

    print("ç”Ÿæˆçš„æµ‹è¯•æ–‡ä»¶:")
    for f in files:
        size = os.path.getsize(f)
        print(f"  {f} ({size} bytes)")
```

### 6.3 è‡ªåŠ¨åŒ–ç³»ç»Ÿç»´æŠ¤æŒ‡å—

#### 6.3.1 é”™è¯¯æ¨¡å¼åº“ç»´æŠ¤

**æ·»åŠ æ–°çš„é”™è¯¯æ¨¡å¼**:
```python
# error_patterns_db.py
# é”™è¯¯æ¨¡å¼æ•°æ®åº“

class ErrorPatternsDB:
    def __init__(self, db_file="error_patterns.json"):
        self.db_file = db_file
        self.patterns = self._load_patterns()

    def add_pattern(self, error_type, pattern_info):
        """æ·»åŠ æ–°çš„é”™è¯¯æ¨¡å¼"""

        new_pattern = {
            "error_type": error_type,
            "pattern": pattern_info["pattern"],
            "symptoms": pattern_info["symptoms"],
            "root_cause": pattern_info["root_cause"],
            "fix_strategy": pattern_info["fix_strategy"],
            "success_rate": 0.0,
            "usage_count": 0,
            "added_date": datetime.now().isoformat()
        }

        if error_type not in self.patterns:
            self.patterns[error_type] = []

        self.patterns[error_type].append(new_pattern)

        self._save_patterns()

    def update_pattern_success_rate(self, error_type, pattern_id, success):
        """æ›´æ–°é”™è¯¯æ¨¡å¼çš„æˆåŠŸç‡"""

        pattern = self.patterns[error_type][pattern_id]

        # æ›´æ–°æˆåŠŸç‡ï¼ˆç§»åŠ¨å¹³å‡ï¼‰
        old_rate = pattern["success_rate"]
        old_count = pattern["usage_count"]

        new_count = old_count + 1
        new_rate = (old_rate * old_count + (1.0 if success else 0.0)) / new_count

        pattern["success_rate"] = new_rate
        pattern["usage_count"] = new_count

        self._save_patterns()

    def get_best_pattern(self, error_type):
        """è·å–æˆåŠŸç‡æœ€é«˜çš„é”™è¯¯æ¨¡å¼"""

        if error_type not in self.patterns:
            return None

        patterns = self.patterns[error_type]

        # æŒ‰æˆåŠŸç‡æ’åº
        sorted_patterns = sorted(
            patterns,
            key=lambda p: p["success_rate"],
            reverse=True
        )

        return sorted_patterns[0] if sorted_patterns else None
```

#### 6.3.2 ä¿®å¤ç­–ç•¥åº“ç»´æŠ¤

**æ·»åŠ æ–°çš„ä¿®å¤ç­–ç•¥**:
```python
# fix_strategies_registry.py
# ä¿®å¤ç­–ç•¥æ³¨å†Œä¸­å¿ƒ

class FixStrategyRegistry:
    _strategies = {}

    @classmethod
    def register(cls, error_type):
        """æ³¨å†Œä¿®å¤ç­–ç•¥è£…é¥°å™¨"""
        def decorator(strategy_class):
            cls._strategies[error_type] = strategy_class
            return strategy_class
        return decorator

    @classmethod
    def get_strategy(cls, error_type):
        """è·å–ä¿®å¤ç­–ç•¥"""
        return cls._strategies.get(error_type)

    @classmethod
    def list_strategies(cls):
        """åˆ—å‡ºæ‰€æœ‰ç­–ç•¥"""
        return list(cls._strategies.keys())

# ä½¿ç”¨ç¤ºä¾‹
@FixStrategyRegistry.register("MISSING_HEADER")
class MissingHeaderFixStrategy:
    def can_handle(self, error):
        return "æ— æ³•æ‰“å¼€åŒ…æ‹¬æ–‡ä»¶" in error

    def fix(self, error_details):
        # ä¿®å¤é€»è¾‘
        pass

@FixStrategyRegistry.register("NULL_POINTER")
class NullPointerFixStrategy:
    def can_handle(self, error):
        return "Access violation" in error or "nullptr" in error

    def fix(self, error_details):
        # ä¿®å¤é€»è¾‘
        pass
```

### 6.4 æ•…éšœæ’æŸ¥æ‰‹å†Œ

#### 6.4.1 å¸¸è§é—®é¢˜åŠè§£å†³æ–¹æ¡ˆ

**é—®é¢˜1: è‡ªåŠ¨åŒ–æµç¨‹å¡æ­»**

**ç—‡çŠ¶**:
- æµç¨‹è¿è¡Œè¶…è¿‡é¢„æœŸæ—¶é—´
- æ— æ–°æ—¥å¿—è¾“å‡º

**æ’æŸ¥æ­¥éª¤**:
```bash
# 1. æ£€æŸ¥è¿›ç¨‹çŠ¶æ€
tasklist | findstr "PortMaster"
tasklist | findstr "AutoTest"

# 2. æŸ¥çœ‹æœ€åçš„æ—¥å¿—
tail -n 50 auto_dev_workflow.log

# 3. æ£€æŸ¥èµ„æºå ç”¨
wmic process where name="PortMaster.exe" get ProcessId,WorkingSetSize,UserModeTime

# 4. å¼ºåˆ¶ç»ˆæ­¢å¹¶é‡å¯
taskkill /F /IM PortMaster.exe
python auto_dev_workflow.py --mode resume --from-checkpoint
```

**é—®é¢˜2: æµ‹è¯•éšæœºå¤±è´¥**

**ç—‡çŠ¶**:
- åŒæ ·çš„æµ‹è¯•æœ‰æ—¶é€šè¿‡æœ‰æ—¶å¤±è´¥
- å¤±è´¥åŸå› ä¸ä¸€è‡´

**æ’æŸ¥æ­¥éª¤**:
```python
# debug_random_failures.py

def debug_random_failures(test_name, iterations=100):
    """è°ƒè¯•éšæœºå¤±è´¥çš„æµ‹è¯•"""

    failures = []

    for i in range(iterations):
        result = run_test(test_name)

        if not result["passed"]:
            failures.append({
                "iteration": i,
                "error": result["error"],
                "timestamp": datetime.now()
            })

    # åˆ†æå¤±è´¥æ¨¡å¼
    if failures:
        print(f"å¤±è´¥ç‡: {len(failures)}/{iterations} ({len(failures)/iterations*100:.2f}%)")

        # åˆ†ç±»å¤±è´¥åŸå› 
        error_types = {}
        for f in failures:
            error_type = classify_error(f["error"])
            if error_type not in error_types:
                error_types[error_type] = []
            error_types[error_type].append(f)

        # æŠ¥å‘Š
        print("\nå¤±è´¥åŸå› åˆ†ç±»:")
        for error_type, instances in error_types.items():
            print(f"  {error_type}: {len(instances)}æ¬¡")
            print(f"    ç¤ºä¾‹: {instances[0]['error']}")
    else:
        print(f"æµ‹è¯•ç¨³å®šï¼Œ{iterations}æ¬¡è¿è¡Œå…¨éƒ¨é€šè¿‡")
```

**é—®é¢˜3: è‡ªåŠ¨ä¿®å¤è¿›å…¥æ­»å¾ªç¯**

**ç—‡çŠ¶**:
- ä¿®å¤å°è¯•æ¬¡æ•°è¶…è¿‡é™åˆ¶
- ä¿®å¤ç›¸åŒé”™è¯¯å¤šæ¬¡

**è§£å†³æ–¹æ¡ˆ**:
```python
# break_fix_loop.py

def detect_fix_loop(fix_history):
    """æ£€æµ‹ä¿®å¤æ­»å¾ªç¯"""

    # æ£€æŸ¥æœ€è¿‘çš„ä¿®å¤å†å²
    recent_fixes = fix_history[-10:]

    # æå–é”™è¯¯ç‰¹å¾
    error_signatures = [
        extract_error_signature(f["error"])
        for f in recent_fixes
    ]

    # æ£€æµ‹é‡å¤
    from collections import Counter
    signature_counts = Counter(error_signatures)

    for signature, count in signature_counts.items():
        if count >= 3:
            print(f"[WARNING] æ£€æµ‹åˆ°ä¿®å¤æ­»å¾ªç¯: {signature} å‡ºç° {count} æ¬¡")

            # åˆ†æä¸ºä»€ä¹ˆä¿®å¤å¤±è´¥
            failed_fixes = [
                f for f in recent_fixes
                if extract_error_signature(f["error"]) == signature
            ]

            print("ä¿®å¤å°è¯•å†å²:")
            for f in failed_fixes:
                print(f"  - ç­–ç•¥: {f['strategy']}, ç»“æœ: {f['result']}")

            # å»ºè®®
            print("\nå»ºè®®æ“ä½œ:")
            print("  1. æ£€æŸ¥ä¿®å¤ç­–ç•¥æ˜¯å¦æ­£ç¡®")
            print("  2. å¯èƒ½éœ€è¦äººå·¥ä»‹å…¥ä¿®å¤")
            print("  3. æ›´æ–°é”™è¯¯æ¨¡å¼åº“")

            return True

    return False
```

#### 6.4.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

**ä¼˜åŒ–1: å¹¶è¡ŒåŒ–æµ‹è¯•æ‰§è¡Œ**
```python
# parallel_test_execution.py

from concurrent.futures import ThreadPoolExecutor, as_completed

def run_tests_in_parallel(test_suites, max_workers=4):
    """å¹¶è¡Œè¿è¡Œæµ‹è¯•å¥—ä»¶"""

    results = []

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        # æäº¤æ‰€æœ‰æµ‹è¯•
        future_to_test = {
            executor.submit(run_test_suite, suite): suite
            for suite in test_suites
        }

        # æ”¶é›†ç»“æœ
        for future in as_completed(future_to_test):
            suite = future_to_test[future]
            try:
                result = future.result()
                results.append(result)
                print(f"[OK] {suite} å®Œæˆ")
            except Exception as e:
                print(f"[FAIL] {suite} å¼‚å¸¸: {e}")
                results.append({"suite": suite, "error": str(e)})

    return results
```

**ä¼˜åŒ–2: å¢é‡ç¼–è¯‘**
```bash
# incremental_build.bat
# å¢é‡ç¼–è¯‘è„šæœ¬

@echo off

REM æ£€æŸ¥æ˜¯å¦æœ‰å˜æ›´
git diff --quiet
if %ERRORLEVEL% EQU 0 (
    echo æ— ä»£ç å˜æ›´ï¼Œè·³è¿‡ç¼–è¯‘
    exit /b 0
)

REM è·å–å˜æ›´æ–‡ä»¶
git diff --name-only > changed_files.txt

REM åªç¼–è¯‘å˜æ›´çš„é¡¹ç›®
findstr /C:".cpp" changed_files.txt > NUL
if %ERRORLEVEL% EQU 0 (
    echo æ£€æµ‹åˆ°æºç å˜æ›´ï¼Œæ‰§è¡Œå¢é‡ç¼–è¯‘
    msbuild PortMaster.sln /t:Rebuild /p:Configuration=Debug /p:Platform=Win32
) else (
    echo ä»…èµ„æºæ–‡ä»¶å˜æ›´ï¼Œå¿«é€Ÿç¼–è¯‘
    msbuild PortMaster.sln /t:Build /p:Configuration=Debug /p:Platform=Win32
)
```

---

## 7. é™„å½•ï¼šå·¥å…·æ¸…å•

### 7.1 æ ¸å¿ƒè‡ªåŠ¨åŒ–å·¥å…·

| å·¥å…·åç§° | åŠŸèƒ½ | è¯­è¨€ | çŠ¶æ€ |
|---------|------|------|------|
| auto_dev_workflow.py | ä¸»æ§è‡ªåŠ¨åŒ–å¼€å‘æµç¨‹ | Python | â­• å¾…å¼€å‘ |
| autonomous_fix_controller.py | è‡ªåŠ¨ä¿®å¤æ§åˆ¶å™¨ | Python | âœ… å·²æœ‰ï¼ˆéœ€å¢å¼ºï¼‰ |
| enhanced_error_capture.py | é”™è¯¯æ•è·ç³»ç»Ÿ | Python | âœ… å·²æœ‰ |
| ci_cd_pipeline.py | CI/CDæµç¨‹æ§åˆ¶ | Python | â­• å¾…å¼€å‘ |

### 7.2 æµ‹è¯•å·¥å…·

| å·¥å…·åç§° | åŠŸèƒ½ | ç±»å‹ | çŠ¶æ€ |
|---------|------|------|------|
| AutoTest.exe | å¯é ä¼ è¾“åè®®æµ‹è¯• | C++ | âœ… å·²æœ‰ï¼ˆéœ€å¢å¼ºï¼‰ |
| TransportUnitTest.exe | Transportå±‚å•å…ƒæµ‹è¯• | C++ | â­• å¾…å¼€å‘ |
| ProtocolUnitTest.exe | Protocolå±‚å•å…ƒæµ‹è¯• | C++ | â­• å¾…å¼€å‘ |
| UIUnitTest.exe | UIå±‚å•å…ƒæµ‹è¯• | C++ | â­• å¾…å¼€å‘ |
| IntegrationTest.exe | é›†æˆæµ‹è¯• | C++ | â­• å¾…å¼€å‘ |
| SystemTest.exe | ç³»ç»Ÿæµ‹è¯• | C++ | â­• å¾…å¼€å‘ |

### 7.3 è¾…åŠ©è„šæœ¬

| è„šæœ¬åç§° | åŠŸèƒ½ | çŠ¶æ€ |
|---------|------|------|
| static_analysis.py | é™æ€ä»£ç åˆ†æ | â­• å¾…å¼€å‘ |
| coverage_measurement.py | ä»£ç è¦†ç›–ç‡æµ‹é‡ | â­• å¾…å¼€å‘ |
| performance_benchmark.py | æ€§èƒ½åŸºå‡†æµ‹è¯• | â­• å¾…å¼€å‘ |
| test_data_generator.py | æµ‹è¯•æ•°æ®ç”Ÿæˆ | â­• å¾…å¼€å‘ |
| doc_sync_check.py | æ–‡æ¡£åŒæ­¥æ£€æŸ¥ | â­• å¾…å¼€å‘ |

### 7.4 ä¾èµ–åº“å’Œå·¥å…·

**C++å¼€å‘**:
- Visual Studio 2022
- v143 toolset
- MFCé™æ€é“¾æ¥

**Pythonç¯å¢ƒ**:
```
pip install -r requirements.txt

# requirements.txtå†…å®¹ï¼š
psutil>=5.9.0
Pillow>=9.0.0
pytesseract>=0.3.10
pygetwindow>=0.0.9
reportlab>=3.6.0
flask>=2.0.0
```

**é™æ€åˆ†æå·¥å…·**:
- cppcheck
- clang-tidy
- OpenCppCoverage

**æµ‹è¯•å·¥å…·**:
- com0comï¼ˆè™šæ‹Ÿä¸²å£å¯¹ï¼‰
- Wiresharkï¼ˆç½‘ç»œæŠ“åŒ…ï¼‰

---

## æ€»ç»“

æœ¬å®æ–½æ–¹æ¡ˆæä¾›äº†ä¸€ä¸ª**å®Œæ•´çš„å…¨è‡ªåŠ¨åŒ–AIé©±åŠ¨å¼€å‘ç³»ç»Ÿæ¡†æ¶**ï¼Œæ¶µç›–ä»éœ€æ±‚åˆ†æåˆ°ç‰ˆæœ¬éƒ¨ç½²çš„å®Œæ•´æµç¨‹ã€‚

**æ ¸å¿ƒä¼˜åŠ¿**:
1. âœ… **å…­é˜¶æ®µå…¨è‡ªåŠ¨åŒ–æµç¨‹** - æœ€å¤§åŒ–å‡å°‘äººå·¥ä»‹å…¥
2. âœ… **åˆ†å±‚è‡ªåŠ¨åŒ–æµ‹è¯•** - ç¡®ä¿æ¯ä¸ªå±‚æ¬¡çš„ä»£ç è´¨é‡
3. âœ… **æ™ºèƒ½è‡ªåŠ¨ä¿®å¤** - åŸºäºé”™è¯¯æ¨¡å¼åº“çš„è‡ªåŠ¨ä¿®å¤
4. âœ… **è´¨é‡ä¿è¯ä½“ç³»** - å¤šç»´åº¦è´¨é‡æ£€æŸ¥å’Œä»£ç å®¡æŸ¥
5. âœ… **CI/CDé›†æˆ** - æŒç»­é›†æˆå’ŒæŒç»­éƒ¨ç½²

**ä¸‹ä¸€æ­¥è¡ŒåŠ¨**:
1. åŸºäºæœ¬æ–¹æ¡ˆï¼Œé€æ­¥å¼€å‘å„é¡¹è‡ªåŠ¨åŒ–å·¥å…·
2. å®Œå–„AutoTestå’Œautonomous_fix_controller
3. å»ºç«‹æµ‹è¯•æ•°æ®é›†å’Œé”™è¯¯æ¨¡å¼åº“
4. éƒ¨ç½²CI/CDæµç¨‹
5. æŒç»­ä¼˜åŒ–å’Œè¿­ä»£

**é¢„æœŸæ•ˆæœ**:
- å¼€å‘æ•ˆç‡æå‡ **5-10å€**
- äººå·¥æµ‹è¯•æ—¶é—´å‡å°‘ **80%**
- Bugå‘ç°å’Œä¿®å¤æ—¶é—´ç¼©çŸ­ **70%**
- ä»£ç è´¨é‡æ˜¾è‘—æå‡
- é¡¹ç›®äº¤ä»˜å‘¨æœŸå¤§å¹…ç¼©çŸ­
