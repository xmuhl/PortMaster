# PortMaster 可靠模式下保存文件数据丢失问题分析报告

**报告日期:** 2025年9月29日

## 1. 问题现象

在“可靠传输模式”下，传输一个约21MB的大文件。传输结束后，点击“保存”按钮，将接收到的数据保存到本地。最终生成的文件大小为 **21,786,624** 字节，与原始文件大小 **21,981,282** 字节不符，数据发生丢失。

用户反馈此问题曾在早期版本修复，属于“回归性缺陷 (Regression Bug)”。

## 2. 日志分析与事件还原

通过分析 `PortMaster_debug.log` 文件末尾的日志，可以清晰地还原问题发生时的事件顺序：

1.  **数据接收：** 接收线程持续接收数据，并通过 `ThreadSafeAppendReceiveData` 函数将数据块写入临时文件 `C:\Users\huangl\AppData\Local\Temp\PM_7BEC.tmp`。日志显示，在保存操作发生前，最后一次写入使文件总大小达到了 `21,786,624` 字节。

2.  **保存操作触发：** 在 `10:48:48.363`，用户点击保存按钮，UI线程开始执行保存逻辑。
    ```log
    [10:48:48.363] 用户确认保存，立即读取临时文件最新数据
    ```

3.  **关闭文件流：** 为了读取数据，保存函数首先关闭了用于写入的临时文件流。
    ```log
    [10:48:48.364] ReadDataFromTempCacheUnlocked: 临时关闭写入流，确保读取数据完整性
    ```

4.  **读取不完整的文件：** 保存函数立即从临时文件中读取数据。此时，由于最后的数据包仍在传输途中或在系统缓冲区中，尚未被程序写入，因此函数读取到的文件大小为不完整的 `21,786,624` 字节。
    ```log
    [10:48:48.416] ReadDataFromTempCacheUnlocked: 临时缓存文件大小 21786624 字节
    [10:48:48.481] ReadDataFromTempCacheUnlocked: ✅ 数据读取完整，成功读取 21786624 字节
    ```

5.  **最后的数据包到达：** 在主线程读取文件的**同时**，接收线程处理完了最后 `2146` 字节的数据。它尝试写入临时文件，但发现文件流已被关闭，于是触发恢复机制，重新打开文件并写入了这部分数据。
    ```log
    [10:48:49.801] 缓存追加完成: 21979136 → 21981282 字节
    [10:48:49.804] 文件系统中文件大小: 21981282 字节
    ```

6.  **错误的结果：** 尽管临时文件最终达到了正确的大小，但保存函数早已基于第4步读取的不完整数据进行操作，最终导致生成了错误的文件。

## 3. 根本原因：线程竞态条件 (Race Condition)

问题的核心是**保存逻辑与数据接收逻辑之间存在竞态条件，缺乏正确的线程同步**。

保存功能采用了一种“先关闭，再读取”的危险操作。这个逻辑在UI线程执行，而数据接收和写入临时文件则在后台的接收线程执行。当用户在数据传输完成的瞬间点击保存时，UI线程会关闭文件流，而此时接收线程可能还有最后几个数据包没有来得及写入磁盘。这就导致UI线程读取到的是一个不完整的“快照”，而丢失的数据在一瞬间之后才被写入文件，但为时已晚。

此缺陷的回归，很可能是因为近期某次代码修改简化或移除了原有的、更为健壮的同步机制（例如，在允许保存前，没有严格等待所有I/O操作完成的信号量或标志位）。

## 4. 错误代码定位

- **文件:** `src\PortMasterDlg.cpp`
- **核心问题函数:** `ReadAllDataFromTempCacheUnlocked` (或类似功能的函数)，该函数被 `OnBnClickedButtonSaveAll` 调用。
- **错误逻辑:** 在该函数内部，`m_tempCacheFile.close()` 的调用是问题的直接原因。

## 5. 修复建议

为了根除此问题，在读取临时文件时，**绝不能关闭共享的文件写入流**。应采用以下线程安全的读取方式：

1.  在执行任何读写前，通过互斥锁（`m_receiveFileMutex`）保护临界区。
2.  **强制刷新缓冲区：** 调用 `m_tempCacheFile.flush()`，确保所有操作系统和C++运行库内存中的数据都已写入磁盘。
3.  **重定位读取指针：** 调用 `m_tempCacheFile.seekg(0)`，将读取指针移动到文件开头，准备读取。
4.  **执行读取：** 从文件流中读取全部内容。
5.  **恢复写入指针（可选但推荐）：** 调用 `m_tempCacheFile.seekp(0, std::ios_base::end)` 将写入指针恢复到文件末尾，以便后续操作。
6.  释放互斥锁。

通过此方法，文件流句柄始终有效，接收线程的数据写入操作不会被阻塞或失败，从而保证了UI线程在任何时候读取到的都是当时最完整的数据。
