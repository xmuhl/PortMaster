# 可靠传输大文件失败问题分析报告

## 1. 错误现象概述

- **用户操作**：在“可靠传输”模式下发送大文件 `test.pdf`。  
- **UI 异常**：  
  - 弹窗提示“传输队列繁忙，大文件传输时可能出现此问题”（截图：`C:\Users\huangl\Desktop\PixPin_2025-10-11_17-01-14.png`）。  
  - 进度条多次从 0% → 100% → 0% 循环闪烁。  
  - 最终生成的 `ReceiveData.pdf` 与源文件大小/内容不一致。  
- **日志表现（节选自 `build/Debug/PortMaster_debug.log`）**：  
  - 大量 `ProcessDataFrame: sequence outside window, expected=272, received=265`。  
  - 持续的 `ReportError called: 数据包重传失败，序列号: 353`（序列号不断增加）。  
  - `TransmitQueue` 达到上限后出现“发送队列已满(size=320, max=320)，拒绝新数据”。

## 2. 问题原因分析

### 2.1 队列流量控制策略的问题
修订记录《修订工作记录20251011-160909.md》中新增的流量控制策略，在 `ReliableChannel::Send` 中当 `m_sendQueue` 达到 `windowSize * 10` 时直接返回 `false`。  
但上层 `TransmissionTask::DoSendChunk` 收到 `false` 后仍继续推进下一块发送，导致：

1. **前一块数据尚未入队**——可靠通道实际上没有接手这块数据；  
2. **TransmissionTask 误以为发送成功**——继续把后续块加入队列；  
3. **窗口数据未完成确认**——出现大量重传，ACK 一直落在旧序列号上；  
4. **可靠通道和 TransmissionTask 状态脱节**，最终触发“队列繁忙”的弹窗和文件内容缺失。

### 2.2 接收窗口卡死的链式反应

- 连续的 `sequence outside window` 日志说明接收端窗口的基序号一直未向前推进。  
- 队列满导致旧数据重发，窗口无法释放，`ProcessThread` 反复重传序列 260~280 左右的数据帧。  
- 上层反复刷新进度，用户看到的就是 0%→100%→0% 的闪烁。  
- 临时缓存文件在重试过程中被清空/覆盖，只剩部分数据，造成 `ReceiveData.pdf` 与 `test.pdf` 不一致。

## 3. 可行的解决方案建议

1. **平滑的队列阻塞处理**  
   - 在 `ReliableChannel::Send` 队列已满时不要立即返回 `false`，而是等待窗口释放（基于条件变量 `m_windowCondition` 或新增机制），并在窗口空出时唤醒等待的线程。  
   - 保证 TransmissionTask 只有在可靠通道真正接收了该块后才继续发送下一块。

2. **TransmissionTask 重试/等待机制**  
   - 若 `Send` 返回 `false` 或 `TransportError::WriteFailed`，上层应该释放 CPU 并短暂等待，而不是立刻推进下一块。  
   - 这样可以与通道的流量控制配合，防止“发送过快、队列堆积”。

3. **进度更新以 ACK 为准（后续优化）**  
   - 长期方案应考虑把进度更新绑定到 ACK 反馈，以避免 UI 误判已“发送完成”，从源头解决进度闪烁。

4. **回归验证**  
   - 调整完上述逻辑后，重新在可靠模式下传输 `test.pdf` 等大文件，确认日志中无持续重传、`ReceiveData.pdf` 与源文件一致、进度条平滑收敛。

---

**编写时间**：2025-10-11  
**编写人**：Claude Code 协同分析  
