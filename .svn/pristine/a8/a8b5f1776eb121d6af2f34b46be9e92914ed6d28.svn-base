#include "pch.h"
#include "framework.h"
#include "PortMaster.h"
#include "PortMasterDlg.h"
#include "PortConfigDialog.h"
#include "TestWizardDialog.h"
#include "afxdialogex.h"
#include <fstream>
#include <Shlwapi.h>
#include <algorithm>

#pragma comment(lib, "Shlwapi.lib")

extern void WriteDebugLog(const char* message);

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

// 用于应用程序"关于"菜单项的 CAboutDlg 对话框
class CAboutDlg : public CDialogEx
{
public:
	CAboutDlg();

	// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_ABOUTBOX };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	// 实现
protected:
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()

// CPortMasterDlg 对话框
CPortMasterDlg::CPortMasterDlg(CWnd* pParent /*=nullptr*/)
	: CDialogEx(IDD_PORTMASTER_DIALOG, pParent)
	, m_bConnected(false)
	, m_bReliableMode(false)
	, m_bTransmitting(false)
	, m_bHexDisplay(true)  // 默认十六进制显示模式
	, m_transmissionProgress(0)
	, m_transmissionTimer(0)
	, m_transmissionStartTime(0)
	, m_totalBytesTransmitted(0)
	, m_lastSpeedUpdateTime(0)
{
	WriteDebugLog("[DEBUG] CPortMasterDlg::CPortMasterDlg: 主对话框构造函数开始");
	m_hIcon = AfxGetApp()->LoadIcon(IDI_MAIN_ICON);
	WriteDebugLog("[DEBUG] CPortMasterDlg::CPortMasterDlg: 主对话框构造函数完成");
}

CPortMasterDlg::~CPortMasterDlg()
{
	WriteDebugLog("[DEBUG] CPortMasterDlg::~CPortMasterDlg: 主对话框析构函数开始");
	
	// 确保传输定时器被正确清理
	if (m_transmissionTimer != 0 && ::IsWindow(GetSafeHwnd())) {
		WriteDebugLog("[DEBUG] CPortMasterDlg::~CPortMasterDlg: 清理传输定时器");
		KillTimer(m_transmissionTimer);
		m_transmissionTimer = 0;
	}
	
	WriteDebugLog("[DEBUG] CPortMasterDlg::~CPortMasterDlg: 主对话框析构函数完成");
}

void CPortMasterDlg::DoDataExchange(CDataExchange* pDX)
{
	WriteDebugLog("[DEBUG] DoDataExchange: 开始数据交换");
	CDialogEx::DoDataExchange(pDX);
	WriteDebugLog("[DEBUG] DoDataExchange: CDialogEx::DoDataExchange 完成");

	// 逐个绑定控件，并记录调试信息
	try {
		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_PORT_TYPE");
		DDX_Control(pDX, IDC_PORT_TYPE, m_ctrlPortType);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_PORT_LIST");
		DDX_Control(pDX, IDC_PORT_LIST, m_ctrlPortList);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_BAUD_RATE");
		DDX_Control(pDX, IDC_BAUD_RATE, m_ctrlBaudRate);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_DATA_BITS");
		DDX_Control(pDX, IDC_DATA_BITS, m_ctrlDataBits);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_PARITY");
		DDX_Control(pDX, IDC_PARITY, m_ctrlParity);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_STOP_BITS");
		DDX_Control(pDX, IDC_STOP_BITS, m_ctrlStopBits);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_CONNECT_BUTTON");
		DDX_Control(pDX, IDC_CONNECT_BUTTON, m_ctrlConnectBtn);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_DISCONNECT_BUTTON");
		DDX_Control(pDX, IDC_DISCONNECT_BUTTON, m_ctrlDisconnectBtn);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_SEND_BUTTON");
		DDX_Control(pDX, IDC_SEND_BUTTON, m_ctrlSendBtn);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_CLEAR_INPUT_BUTTON");
		DDX_Control(pDX, IDC_CLEAR_INPUT_BUTTON, m_ctrlClearInputBtn);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_CLEAR_DISPLAY_BUTTON");
		DDX_Control(pDX, IDC_CLEAR_DISPLAY_BUTTON, m_ctrlClearDisplayBtn);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_LOAD_FILE_BUTTON");
		DDX_Control(pDX, IDC_LOAD_FILE_BUTTON, m_ctrlLoadFileBtn);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_SAVE_FILE_BUTTON");
		DDX_Control(pDX, IDC_SAVE_FILE_BUTTON, m_ctrlSaveFileBtn);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_COPY_BUTTON");
		DDX_Control(pDX, IDC_COPY_BUTTON, m_ctrlCopyBtn);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_RELIABLE_MODE");
		DDX_Control(pDX, IDC_RELIABLE_MODE, m_ctrlReliableMode);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_HEX_DISPLAY_CHECK");
		DDX_Control(pDX, IDC_HEX_DISPLAY_CHECK, m_ctrlHexDisplayCheck);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_INPUT_HEX");
		DDX_Control(pDX, IDC_INPUT_HEX, m_ctrlInputHex);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_DATA_VIEW");
		DDX_Control(pDX, IDC_DATA_VIEW, m_ctrlDataView);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_LOG");
		DDX_Control(pDX, IDC_LOG, m_ctrlLog);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_PROGRESS");
		DDX_Control(pDX, IDC_PROGRESS, m_ctrlProgress);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_CONNECTION_STATUS");
		DDX_Control(pDX, IDC_CONNECTION_STATUS, m_ctrlConnectionStatus);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_PROTOCOL_STATUS");
		DDX_Control(pDX, IDC_PROTOCOL_STATUS, m_ctrlProtocolStatus);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_TRANSFER_STATS");
		// DDX_Control(pDX, IDC_TRANSFER_STATS, m_ctrlStatus); // 控件在资源中缺失，注释掉绑定

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_TRANSFER_SPEED");
		DDX_Control(pDX, IDC_TRANSFER_SPEED, m_ctrlTransferSpeed);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_TRANSFER_PROGRESS");
		DDX_Control(pDX, IDC_TRANSFER_PROGRESS, m_ctrlTransferProgress);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_STATUS");
		DDX_Control(pDX, IDC_STATUS, m_ctrlStatus);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_DATA_SOURCE_LABEL");
		DDX_Control(pDX, IDC_DATA_SOURCE_LABEL, m_ctrlDataSourceLabel);
		// DDX_Control(pDX, IDC_TIME_REMAINING, m_ctrlTimeRemaining); // 控件在资源中缺失，注释掉绑定
		// DDX_Control(pDX, IDC_CLEAR_BUTTON, m_ctrlClearBtn);

		WriteDebugLog("[DEBUG] DoDataExchange: 所有控件绑定完成");
	}
	catch (...) {
		WriteDebugLog("[ERROR] DoDataExchange: 控件绑定过程中出现异常");
		throw;
	}
}

BEGIN_MESSAGE_MAP(CPortMasterDlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_SIZE()
	ON_WM_GETMINMAXINFO()
	ON_BN_CLICKED(IDC_CONNECT_BUTTON, &CPortMasterDlg::OnBnClickedConnect)
	ON_BN_CLICKED(IDC_DISCONNECT_BUTTON, &CPortMasterDlg::OnBnClickedDisconnect)
	ON_BN_CLICKED(IDC_SEND_BUTTON, &CPortMasterDlg::OnBnClickedSend)
	ON_BN_CLICKED(IDC_CLEAR_INPUT_BUTTON, &CPortMasterDlg::OnBnClickedClearInput)
	ON_BN_CLICKED(IDC_CLEAR_DISPLAY_BUTTON, &CPortMasterDlg::OnBnClickedClearDisplay)
	ON_BN_CLICKED(IDC_CLEAR_BUTTON, &CPortMasterDlg::OnBnClickedClear)
	ON_BN_CLICKED(IDC_LOAD_FILE_BUTTON, &CPortMasterDlg::OnBnClickedLoadFile)
	ON_BN_CLICKED(IDC_SAVE_FILE_BUTTON, &CPortMasterDlg::OnBnClickedSaveFile)
	ON_BN_CLICKED(IDC_COPY_BUTTON, &CPortMasterDlg::OnBnClickedCopy)
	ON_BN_CLICKED(IDC_HEX_DISPLAY_CHECK, &CPortMasterDlg::OnBnClickedHexDisplay)
	ON_CBN_SELCHANGE(IDC_PORT_TYPE, &CPortMasterDlg::OnCbnSelchangePortType)
	ON_BN_CLICKED(IDC_RELIABLE_MODE, &CPortMasterDlg::OnBnClickedReliableMode)
	ON_EN_CHANGE(IDC_INPUT_HEX, &CPortMasterDlg::OnEnChangeInputHex)
	ON_WM_DROPFILES()
	ON_WM_TIMER()
END_MESSAGE_MAP()

// CPortMasterDlg 消息处理程序

BOOL CPortMasterDlg::OnInitDialog()
{
	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 开始初始化主对话框");

	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤1 - 调用CDialogEx::OnInitDialog");

	// 现在应该可以安全调用，因为已经修复了DDX绑定和资源定义
	if (!CDialogEx::OnInitDialog()) {
		WriteDebugLog("[ERROR] PortMasterDlg::OnInitDialog: CDialogEx::OnInitDialog失败");
		return FALSE;
	}
	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: CDialogEx::OnInitDialog成功完成");

	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤2 - 开始初始化复杂对象");
	try {
		// 现在在控件已经正确绑定后初始化复杂对象
		InitializeTransportObjects();
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 复杂对象初始化完成");
	}
	catch (...) {
		WriteDebugLog("[ERROR] PortMasterDlg::OnInitDialog: 复杂对象初始化失败");
		return FALSE;
	}

	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3 - 开始设置系统菜单");
	// 将"关于..."菜单项添加到系统菜单中。
	// IDM_ABOUTBOX 必须在系统命令范围内。
	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3.1 - 检查IDM_ABOUTBOX常量");
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);
	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3.2 - IDM_ABOUTBOX常量检查完成");

	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3.3 - 获取系统菜单");
	CMenu* pSysMenu = GetSystemMenu(FALSE);
	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3.4 - 系统菜单获取完成");
	if (pSysMenu != nullptr)
	{
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3.5 - 系统菜单有效，开始加载字符串");
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3.6 - 字符串加载完成");
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3.7 - 添加菜单项");
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
			WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3.8 - 菜单项添加完成");
		}
	}
	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3 - 系统菜单设置完成");

	try {
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 设置对话框图标");
		// 设置此对话框的图标。当应用程序主窗口不是对话框时，框架将自动
		//  执行此操作
		SetIcon(m_hIcon, TRUE);			// 设置大图标
		SetIcon(m_hIcon, FALSE);		// 设置小图标
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 对话框图标设置完成");
	}
	catch (...) {
		WriteDebugLog("[ERROR] PortMasterDlg::OnInitDialog: 设置图标异常");
	}

	try {
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 开始初始化控件");
		// 初始化控件
		InitializeControls();
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 控件初始化完成");
	}
	catch (...) {
		WriteDebugLog("[ERROR] PortMasterDlg::OnInitDialog: 初始化控件异常");
		return FALSE;
	}

	try {
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 启用拖放功能");
		// 启用拖放
		DragAcceptFiles(TRUE);
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 拖放功能启用完成");
	}
	catch (...) {
		WriteDebugLog("[ERROR] PortMasterDlg::OnInitDialog: 启用拖放功能异常");
	}

	try {
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 开始自适应窗口大小");
		// 自适应窗口大小到桌面，现在有了动态布局调整功能
		SetFixedWindowSize();
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 窗口大小自适应完成");
	}
	catch (...) {
		WriteDebugLog("[ERROR] PortMasterDlg::OnInitDialog: 窗口大小自适应异常");
	}

	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 主对话框初始化完成");
	return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE
}

void CPortMasterDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialogEx::OnSysCommand(nID, lParam);
	}
}

// 如果向对话框添加最小化按钮，则需要下面的代码
//  来绘制该图标。对于文档/视图模型的 MFC 应用程序，
//  这将由框架自动完成。

void CPortMasterDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // 用于绘制的设备上下文

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// 使图标在工作区矩形中居中
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// 绘制图标
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

//当用户拖动最小化窗口时系统调用此函数取得光标
//显示。
HCURSOR CPortMasterDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}

void CPortMasterDlg::InitializeControls()
{
	WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 开始初始化控件");

	try {
		// 初始化端口类型下拉框
		m_ctrlPortType.AddString(L"串口");
		m_ctrlPortType.AddString(L"并口");
		m_ctrlPortType.AddString(L"USB打印机");
		m_ctrlPortType.AddString(L"TCP客户端");
		m_ctrlPortType.AddString(L"TCP服务端");
		m_ctrlPortType.AddString(L"UDP");
		m_ctrlPortType.AddString(L"本地回环");
		m_ctrlPortType.SetCurSel(6); // 默认选择本地回环
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 端口类型下拉框初始化完成");

		// 初始化波特率下拉框
		m_ctrlBaudRate.AddString(L"9600");
		m_ctrlBaudRate.AddString(L"19200");
		m_ctrlBaudRate.AddString(L"38400");
		m_ctrlBaudRate.AddString(L"57600");
		m_ctrlBaudRate.AddString(L"115200");
		m_ctrlBaudRate.SetCurSel(0);

		// 初始化数据位下拉框
		m_ctrlDataBits.AddString(L"5");
		m_ctrlDataBits.AddString(L"6");
		m_ctrlDataBits.AddString(L"7");
		m_ctrlDataBits.AddString(L"8");
		m_ctrlDataBits.SetCurSel(3);

		// 初始化停止位下拉框
		m_ctrlStopBits.AddString(L"1");
		m_ctrlStopBits.AddString(L"1.5");
		m_ctrlStopBits.AddString(L"2");
		m_ctrlStopBits.SetCurSel(0);

		// 初始化校验位下拉框
		m_ctrlParity.AddString(L"None");
		m_ctrlParity.AddString(L"Odd");
		m_ctrlParity.AddString(L"Even");
		m_ctrlParity.AddString(L"Mark");
		m_ctrlParity.AddString(L"Space");
		m_ctrlParity.SetCurSel(0);
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 下拉框初始化完成");

		// 更新端口列表
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 开始更新端口列表");
		UpdatePortList();
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 端口列表更新完成");

		// 更新按钮状态
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 开始更新按钮状态");
		UpdateButtonStates();
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 按钮状态更新完成");

		// 设置文件拖放区域提示文本
		// m_ctrlFileDropZone.SetWindowText(L"拖拽文件到此处加载(不自动传输)");  // 控件不存在

		// 初始化状态显示
		if (IsWindow(m_ctrlConnectionStatus.GetSafeHwnd()))
			m_ctrlConnectionStatus.SetWindowText(L"未连接");
		if (IsWindow(m_ctrlProtocolStatus.GetSafeHwnd()))
			m_ctrlProtocolStatus.SetWindowText(L"空闲");
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 设置状态显示完成");

		// 设置等宽字体用于十六进制显示
		static CFont monoFont;
		monoFont.CreateFont(
			-12,                    // 字体高度
			0,                      // 字体宽度（自动）
			0,                      // 倾斜角度
			0,                      // 基线倾斜角度
			FW_NORMAL,             // 字体粗细
			FALSE,                 // 是否斜体
			FALSE,                 // 是否下划线
			0,                     // 是否删除线
			ANSI_CHARSET,          // 字符集
			OUT_DEFAULT_PRECIS,    // 输出精度
			CLIP_DEFAULT_PRECIS,   // 裁剪精度
			CLEARTYPE_QUALITY,     // 输出质量
			FIXED_PITCH | FF_MODERN, // 字体间距和系列
			_T("Consolas")         // 字体名称，备选：Courier New
		);
		if (IsWindow(m_ctrlDataView.GetSafeHwnd()))
			m_ctrlDataView.SetFont(&monoFont);
		if (IsWindow(m_ctrlInputHex.GetSafeHwnd()))
			m_ctrlInputHex.SetFont(&monoFont);
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 等宽字体设置完成");

		// 添加初始化日志
		AppendLog(L"PortMaster 初始化完成");
		AppendLog(L"现代化界面已启用");
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 控件初始化完成");
	}
	catch (...) {
		WriteDebugLog("[ERROR] PortMasterDlg::InitializeControls: 控件初始化异常");
		throw;
	}
}

void CPortMasterDlg::InitializeTransportObjects()
{
	WriteDebugLog("[DEBUG] CPortMasterDlg::InitializeTransportObjects: 开始初始化传输对象");

	// 初始化传输层和可靠通道
	m_transport = std::make_shared<LoopbackTransport>();
	m_reliableChannel = std::make_shared<ReliableChannel>(m_transport);

	// 设置可靠通道回调 - 现在控件已经正确绑定，可以安全访问
	m_reliableChannel->SetProgressCallback([this](const TransferStats& stats) {
		// 更新进度显示
		if (stats.totalBytes > 0)
		{
			int progress = static_cast<int>((stats.transferredBytes * 100) / stats.totalBytes);
			if (IsWindow(m_ctrlProgress.GetSafeHwnd())) {
				m_ctrlProgress.SetPos(progress);
			}

			if (IsWindow(m_ctrlStatus.GetSafeHwnd())) {
				CString statusText;
				statusText.Format(L"传输中 (%.1f%%)", stats.GetProgress() * 100);
				m_ctrlStatus.SetWindowText(statusText);
			}
		}
		});

	m_reliableChannel->SetCompletionCallback([this](bool success, const std::string& message) {
		// 传输完成回调
		CString msg = CA2W(message.c_str(), CP_UTF8);
		AppendLog(msg);

		if (success)
		{
			if (IsWindow(m_ctrlProgress.GetSafeHwnd())) {
				m_ctrlProgress.SetPos(0);
			}
			if (IsWindow(m_ctrlStatus.GetSafeHwnd())) {
				m_ctrlStatus.SetWindowText(L"传输完成");
			}
		}
		else
		{
			if (IsWindow(m_ctrlStatus.GetSafeHwnd())) {
				m_ctrlStatus.SetWindowText(L"传输失败");
			}
		}

		m_bTransmitting = false;
		});

	m_reliableChannel->SetFileReceivedCallback([this](const std::string& filename, const std::vector<uint8_t>& data) {
		// 文件接收完成回调
		CString filenameW = CA2W(filename.c_str(), CP_UTF8);
		if (filename == "[数据传输]")
		{
			AppendLogWithDetails(L"可靠传输完成", data.size());
		}
		else
		{
			CString msg;
			msg.Format(L"接收到文件: %s", filenameW.GetString());
			AppendLogWithDetails(msg, data.size());
		}

		// 在数据视图中显示接收到的内容
		DisplayReceivedData(data);
		});

	WriteDebugLog("[DEBUG] CPortMasterDlg::InitializeTransportObjects: 传输对象初始化完成");
}

void CPortMasterDlg::UpdatePortList()
{
	m_ctrlPortList.ResetContent();

	int portType = m_ctrlPortType.GetCurSel();
	switch (portType)
	{
	case 0: // 串口
		// 枚举串口 - 简单示例
		for (int i = 1; i <= 16; i++)
		{
			CString portName;
			portName.Format(L"COM%d", i);
			m_ctrlPortList.AddString(portName);
		}
		break;
	case 1: // 并口
		m_ctrlPortList.AddString(L"LPT1");
		m_ctrlPortList.AddString(L"LPT2");
		break;
	case 2: // USB打印机
		m_ctrlPortList.AddString(L"USB打印机1");
		break;
	case 3: // TCP客户端
		m_ctrlPortList.AddString(L"127.0.0.1:8080");
		break;
	case 4: // TCP服务端
		m_ctrlPortList.AddString(L"监听端口:8080");
		break;
	case 5: // UDP
		m_ctrlPortList.AddString(L"UDP:8080");
		break;
	case 6: // 本地回环
		m_ctrlPortList.AddString(L"本地回环");
		break;
	}

	if (m_ctrlPortList.GetCount() > 0)
		m_ctrlPortList.SetCurSel(0);
}

void CPortMasterDlg::UpdateButtonStates()
{
	// 添加控件句柄安全检查
	if (!IsWindow(m_ctrlConnectBtn.GetSafeHwnd()) || !IsWindow(m_ctrlDisconnectBtn.GetSafeHwnd()))
	{
		WriteDebugLog("[WARNING] UpdateButtonStates: 控件句柄未初始化，跳过更新");
		return;
	}

	// 更新在DoDataExchange中实际绑定的控件
	m_ctrlConnectBtn.EnableWindow(!m_bConnected);
	m_ctrlDisconnectBtn.EnableWindow(m_bConnected);

	// 改进的发送按钮状态管理
	bool hasSendableData = HasValidInputData();
	if (IsWindow(m_ctrlSendBtn.GetSafeHwnd()))
	{
		bool enableSend = m_bConnected && !m_bTransmitting && hasSendableData;
		m_ctrlSendBtn.EnableWindow(enableSend);

		// 根据状态设置按钮文本和提示信息
		if (m_bTransmitting) {
			m_ctrlSendBtn.SetWindowText(L"发送中...");
		} else {
			m_ctrlSendBtn.SetWindowText(L"发送");
		}
	}

	// 文件操作按钮状态管理
	if (IsWindow(m_ctrlLoadFileBtn.GetSafeHwnd()))
		m_ctrlLoadFileBtn.EnableWindow(!m_bTransmitting);
	if (IsWindow(m_ctrlSaveFileBtn.GetSafeHwnd()))
	{
		bool hasDisplayData = !m_displayedData.empty();
		m_ctrlSaveFileBtn.EnableWindow(hasDisplayData);
	}

	// 清除按钮始终可用 - 使用实际绑定的控件
	if (IsWindow(m_ctrlClearInputBtn.GetSafeHwnd()))
		m_ctrlClearInputBtn.EnableWindow(TRUE);
	if (IsWindow(m_ctrlClearDisplayBtn.GetSafeHwnd()))
		m_ctrlClearDisplayBtn.EnableWindow(TRUE);

	// 更新连接状态显示（带状态指示器）
	if (IsWindow(m_ctrlConnectionStatus.GetSafeHwnd()))
	{
		CString statusText;
		if (m_bTransmitting)
			statusText = L"● 传输中";
		else if (m_bConnected)
			statusText = L"● 已连接";
		else
			statusText = L"○ 未连接";

		if (IsWindow(m_ctrlConnectionStatus.GetSafeHwnd()))
			m_ctrlConnectionStatus.SetWindowText(statusText);
	}

	// 更新协议状态显示
	if (m_reliableChannel)
	{
		ReliableState state = m_reliableChannel->GetState();
		CString stateText;
		switch (state)
		{
		case RELIABLE_IDLE: stateText = L"空闲"; break;
		case RELIABLE_STARTING: stateText = L"开始传输"; break;
		case RELIABLE_SENDING: stateText = L"传输中"; break;
		case RELIABLE_ENDING: stateText = L"结束传输"; break;
		case RELIABLE_RECEIVING: stateText = L"接收中"; break;
		case RELIABLE_DONE: stateText = L"完成"; break;
		case RELIABLE_FAILED: stateText = L"失败"; break;
		default: stateText = L"未知"; break;
		}
		if (IsWindow(m_ctrlProtocolStatus.GetSafeHwnd()))
			m_ctrlProtocolStatus.SetWindowText(stateText);
	}

	// 更新状态栏显示
	CString statusText;
	if (m_bTransmitting)
	{
		statusText = L"状态: 传输中";
	}
	else if (m_bConnected)
	{
		statusText = L"状态: 已连接";
		if (m_bReliableMode)
			statusText += L" (可靠模式)";
	}
	else
	{
		statusText = L"状态: 就绪";
	}
	m_ctrlStatus.SetWindowText(statusText);
}

void CPortMasterDlg::AppendLog(const CString& message)
{
	CString timeStamp;
	SYSTEMTIME st;
	GetLocalTime(&st);
	timeStamp.Format(L"[%02d:%02d:%02d.%03d] ", st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);

	CString log;
	m_ctrlLog.GetWindowText(log);
	log += timeStamp + message + L"\r\n";
	// 限制日志长度，防止控件文本过长
	if (log.GetLength() > 5000) {
		int cutPos = log.GetLength() - 4000;
		int newLinePos = log.Find(L'\n', cutPos);
		if (newLinePos != -1) {
			cutPos = newLinePos + 1;
		}
		log = log.Mid(cutPos);
		log = L"[...] " + log;
	}

	m_ctrlLog.SetWindowText(log);

	// CStatic 不支持滚动，因此移除 LineScroll 调用
	// m_ctrlLog.LineScroll(m_ctrlLog.GetLineCount());

	// 如果需要强制更新显示（虽然通常不需要），可以调用以下代码：
	// m_ctrlLog.Invalidate();
	// m_ctrlLog.UpdateWindow();
}

void CPortMasterDlg::AppendLogWithDetails(const CString& message, size_t bytes)
{
	CString detailedMessage = message;
	if (bytes > 0)
	{
		CString byteInfo;
		if (bytes >= AppConstants::BYTES_IN_MEGABYTE)
		{
			byteInfo.Format(L" (%.2f MB)", bytes * AppConstants::GetBytesToMegabytes());
		}
		else if (bytes >= 1024)
		{
			byteInfo.Format(L" (%.2f KB)", bytes * AppConstants::GetBytesToKilobytes());
		}
		else
		{
			byteInfo.Format(L" (%zu bytes)", bytes);
		}
		detailedMessage += byteInfo;
	}
	AppendLog(detailedMessage);
}

void CPortMasterDlg::UpdateTransferSpeed(size_t bytesTransferred)
{
	DWORD currentTime = GetTickCount();
	m_totalBytesTransmitted += bytesTransferred;

	// 每500ms更新一次速度显示
	if (currentTime - m_lastSpeedUpdateTime >= 500)
	{
		DWORD elapsedTime = currentTime - m_transmissionStartTime;
		if (elapsedTime > 0)
		{
			double speed = (m_totalBytesTransmitted * 1000.0) / elapsedTime;  // bytes/sec
			CString speedText;

			if (speed >= AppConstants::BYTES_IN_MEGABYTE)
			{
				speedText.Format(L"速度: %.2f MB/s", speed * AppConstants::GetBytesToMegabytes());
			}
			else if (speed >= 1024)
			{
				speedText.Format(L"速度: %.2f KB/s", speed * AppConstants::GetBytesToKilobytes());
			}
			else
			{
				speedText.Format(L"速度: %.0f B/s", speed);
			}

			if (IsWindow(m_ctrlTransferSpeed.GetSafeHwnd()))
			{
				m_ctrlTransferSpeed.SetWindowText(speedText);
			}

			// 估计剩余时间
			if (m_transmissionData.size() > m_transmissionProgress && speed > 0)
			{
				size_t remainingBytes = m_transmissionData.size() - m_transmissionProgress;
				double remainingSeconds = remainingBytes / speed;

				CString timeText;
				if (remainingSeconds >= 60)
				{
					timeText.Format(L"剩余: %.1f 分钟", remainingSeconds / 60.0);
				}
				else
				{
					timeText.Format(L"剩余: %.0f 秒", remainingSeconds);
				}

				// 剩余时间显示功能已移除（控件不存在）
			}

			m_lastSpeedUpdateTime = currentTime;
		}
	}

	// 更新传输进度显示
	if (IsWindow(m_ctrlTransferProgress.GetSafeHwnd()) && !m_transmissionData.empty())
	{
		CString progressText;
		progressText.Format(L"已传输: %zu/%zu", m_transmissionProgress, m_transmissionData.size());
		m_ctrlTransferProgress.SetWindowText(progressText);
	}
}

void CPortMasterDlg::AppendHexData(const BYTE* data, size_t length, bool incoming)
{
	const size_t BYTES_PER_LINE = AppConstants::BYTES_PER_LINE;
	CString prefix = incoming ? L"<< " : L">> ";

	CString currentHex;
	// 获取当前数据显示内容（根据显示模式）

	for (size_t i = 0; i < length; i += BYTES_PER_LINE)
	{
		CString hexLine;
		size_t lineLength = std::min(BYTES_PER_LINE, length - i);

		for (size_t j = 0; j < lineLength; j++)
		{
			CString temp;
			temp.Format(L"%02X ", data[i + j]);
			hexLine += temp;
		}

		currentHex += prefix + hexLine + L"\r\n";
	}

	// 在统一显示控件中显示十六进制数据
	if (m_bHexDisplay) {
		// 使用新的专业十六进制格式显示
		std::vector<uint8_t> tempData(data, data + length);
		DisplayReceivedData(tempData);
	}
}

void CPortMasterDlg::AppendTextData(const CString& text, bool incoming)
{
	CString prefix = incoming ? L"<< " : L">> ";

	// 在统一显示控件中显示文本数据
	if (!m_bHexDisplay) {
		// 使用智能文本格式显示
		CStringA utf8Text = CW2A(prefix + text + L"\r\n", CP_UTF8);
		std::vector<uint8_t> tempData(utf8Text.GetString(), utf8Text.GetString() + utf8Text.GetLength());
		DisplayReceivedData(tempData);
	}
}

// 按钮事件处理
void CPortMasterDlg::OnBnClickedConnect()
{
	// 获取当前选择的传输类型
	int transportIndex = m_ctrlPortType.GetCurSel();
	if (transportIndex == CB_ERR)
	{
		AppendLog(L"请选择传输类型");
		return;
	}

	// 读取当前选中的显示文本（仅用于兼容性判断/日志）
	CString transportType;
	m_ctrlPortType.GetLBText(transportIndex, transportType);

	// 兼容判断：
	// 1) 优先用索引判断（InitializeControls 中“本地回环”的索引是 6）
	// 2) 同时兼容文本为“本地回环”或“回环测试”，避免将来本地化或文本改名带来的问题
	if (transportIndex == 6 || transportType == L"本地回环" || transportType == L"回环测试")
	{
		// 确保传输层是回环类型
		if (!m_transport || m_transport->GetTransportType() != "Loopback")
		{
			m_transport = std::make_shared<LoopbackTransport>();
			m_reliableChannel = std::make_shared<ReliableChannel>(m_transport);

			// 重新设置进度回调（中文注释保留）
			m_reliableChannel->SetProgressCallback([this](const TransferStats& stats) {
				if (stats.totalBytes > 0)
				{
					int progress = static_cast<int>((stats.transferredBytes * 100) / stats.totalBytes);
					if (IsWindow(m_ctrlProgress.GetSafeHwnd())) {
						m_ctrlProgress.SetPos(progress);
					}

					CString statusText;
					statusText.Format(L"状态: 传输中 (%.1f%%, %zu/%zu 字节)",
						stats.GetProgress() * 100, stats.transferredBytes, stats.totalBytes);
					if (IsWindow(m_ctrlStatus.GetSafeHwnd())) {
						m_ctrlStatus.SetWindowText(statusText);
					}
				}
				});

			m_reliableChannel->SetCompletionCallback([this](bool success, const std::string& message) {
				CString msg = CA2W(message.c_str(), CP_UTF8);
				if (success)
				{
					AppendLog(L"传输完成: " + msg);
					if (IsWindow(m_ctrlStatus.GetSafeHwnd())) {
						m_ctrlStatus.SetWindowText(L"就绪");
					}

					// 显示传输的数据（从发送缓冲区）
					if (!m_transmissionData.empty()) {
						DisplayReceivedData(m_transmissionData);
					}
				}
				else
				{
					AppendLog(L"传输失败: " + msg);
				}
				m_bTransmitting = false;
				UpdateButtonStates();
				});

			m_reliableChannel->SetFileReceivedCallback([this](const std::string& filename, const std::vector<uint8_t>& data) {
				CString filenameW = CA2W(filename.c_str(), CP_UTF8);
				CString msg;
				if (filename == "[数据传输]")
				{
					msg.Format(L"可靠传输完成 (%zu 字节)", data.size());
				}
				else
				{
					msg.Format(L"接收到文件: %s (%zu 字节)", filenameW.GetString(), data.size());
				}
				AppendLog(msg);
				DisplayReceivedData(data);
				});

			// 启用接收功能（回环/本地回环需要）
			m_reliableChannel->EnableReceiving(true);
		}
	}

	// 启动连接
	if (m_reliableChannel && m_reliableChannel->Start())
	{
		m_bConnected = true;
		UpdateButtonStates();

		// 显示详细的连接信息
		CString transportType2;
		m_ctrlPortType.GetLBText(m_ctrlPortType.GetCurSel(), transportType2);
		CString portName;
		m_ctrlPortList.GetLBText(m_ctrlPortList.GetCurSel(), portName);

		CString detailMsg;
		detailMsg.Format(L"连接成功 - %s: %s", transportType2, portName);
		AppendLog(detailMsg);

		// 更新连接状态显示
		if (IsWindow(m_ctrlConnectionStatus.GetSafeHwnd()))
		{
			m_ctrlConnectionStatus.SetWindowText(L"已连接");
		}
	}
	else
	{
		AppendLog(L"连接失败");
		CString error = CA2W(m_reliableChannel->GetLastError().c_str(), CP_UTF8);
		if (!error.IsEmpty())
		{
			AppendLog(L"错误: " + error);
		}

		// 更新连接状态显示
		if (IsWindow(m_ctrlConnectionStatus.GetSafeHwnd()))
		{
			m_ctrlConnectionStatus.SetWindowText(L"连接失败");
		}
	}
}

//void CPortMasterDlg::OnBnClickedConnect()
//{
//	// 获取当前选择的传输类型
//	int transportIndex = m_ctrlPortType.GetCurSel();
//	if (transportIndex == CB_ERR)
//	{
//		AppendLog(L"请选择传输类型");
//		return;
//	}
//
//	// 如果选择的是回环传输，确保使用正确的传输层
//	CString transportType;
//	m_ctrlPortType.GetLBText(transportIndex, transportType);
//
//	if (transportType == L"回环测试")
//	{
//		// 确保传输层是回环类型
//		if (!m_transport || m_transport->GetTransportType() != "Loopback")
//		{
//			m_transport = std::make_shared<LoopbackTransport>();
//			m_reliableChannel = std::make_shared<ReliableChannel>(m_transport);
//
//			// 重新设置回调
//			m_reliableChannel->SetProgressCallback([this](const TransferStats& stats) {
//				if (stats.totalBytes > 0)
//				{
//					int progress = static_cast<int>((stats.transferredBytes * 100) / stats.totalBytes);
//					if (IsWindow(m_ctrlProgress.GetSafeHwnd())) {
//						m_ctrlProgress.SetPos(progress);
//					}
//
//					CString statusText;
//					statusText.Format(L"状态: 传输中 (%.1f%%, %zu/%zu 字节)",
//						stats.GetProgress() * 100, stats.transferredBytes, stats.totalBytes);
//					if (IsWindow(m_ctrlStatus.GetSafeHwnd())) {
//						m_ctrlStatus.SetWindowText(statusText);
//					}
//				}
//			});
//
//			m_reliableChannel->SetCompletionCallback([this](bool success, const std::string& message) {
//				CString msg = CA2W(message.c_str(), CP_UTF8);
//				if (success)
//				{
//					AppendLog(L"传输完成: " + msg);
//					if (IsWindow(m_ctrlStatus.GetSafeHwnd())) {
//						m_ctrlStatus.SetWindowText(L"就绪");
//					}
//
//					// 显示传输的数据（从发送缓冲区）
//					if (!m_transmissionData.empty()) {
//						DisplayReceivedData(m_transmissionData);
//					}
//				}
//				else
//				{
//					AppendLog(L"传输失败: " + msg);
//				}
//				m_bTransmitting = false;
//				UpdateButtonStates();
//			});
//
//			m_reliableChannel->SetFileReceivedCallback([this](const std::string& filename, const std::vector<uint8_t>& data) {
//				CString filenameW = CA2W(filename.c_str(), CP_UTF8);
//				CString msg;
//				if (filename == "[数据传输]")
//				{
//					msg.Format(L"可靠传输完成 (%zu 字节)", data.size());
//				}
//				else
//				{
//					msg.Format(L"接收到文件: %s (%zu 字节)", filenameW.GetString(), data.size());
//				}
//				AppendLog(msg);
//				DisplayReceivedData(data);
//			});
//
//			// 启用接收功能（回环测试需要）
//			m_reliableChannel->EnableReceiving(true);
//		}
//	}
//
//	if (m_reliableChannel && m_reliableChannel->Start())
//	{
//		m_bConnected = true;
//		UpdateButtonStates();
//
//		// 显示详细的连接信息
//		CString transportType;
//		m_ctrlPortType.GetLBText(m_ctrlPortType.GetCurSel(), transportType);
//		CString portName;
//		m_ctrlPortList.GetLBText(m_ctrlPortList.GetCurSel(), portName);
//
//		CString detailMsg;
//		detailMsg.Format(L"连接成功 - %s: %s", transportType, portName);
//		AppendLog(detailMsg);
//
//		// 更新连接状态显示
//		if (IsWindow(m_ctrlConnectionStatus.GetSafeHwnd()))
//		{
//			m_ctrlConnectionStatus.SetWindowText(L"已连接");
//		}
//	}
//	else
//	{
//		AppendLog(L"连接失败");
//		CString error = CA2W(m_reliableChannel->GetLastError().c_str(), CP_UTF8);
//		if (!error.IsEmpty())
//		{
//			AppendLog(L"错误: " + error);
//		}
//
//		// 更新连接状态显示
//		if (IsWindow(m_ctrlConnectionStatus.GetSafeHwnd()))
//		{
//			m_ctrlConnectionStatus.SetWindowText(L"连接失败");
//		}
//	}
//}

void CPortMasterDlg::OnBnClickedDisconnect()
{
	if (m_reliableChannel)
	{
		m_reliableChannel->Stop();
	}

	m_bConnected = false;
	m_bTransmitting = false;
	UpdateButtonStates();
	AppendLog(L"已断开连接");

	// 更新状态显示
	if (IsWindow(m_ctrlConnectionStatus.GetSafeHwnd()))
	{
		m_ctrlConnectionStatus.SetWindowText(L"未连接");
	}
	if (IsWindow(m_ctrlProtocolStatus.GetSafeHwnd()))
	{
		m_ctrlProtocolStatus.SetWindowText(L"空闲");
	}
}

void CPortMasterDlg::OnBnClickedSend()
{
	// 优先检查是否有文件数据要发送
	std::vector<uint8_t> dataToSend;
	bool isFileTransmission = false;

	if (!m_transmissionData.empty())
	{
		// 有文件数据，发送文件
		dataToSend = m_transmissionData;
		isFileTransmission = true;
		AppendLog(L"发送文件数据");
	}
	else
	{
		// 获取输入框数据
		dataToSend = GetInputData();
		AppendLog(L"发送输入数据");
	}

	if (dataToSend.empty())
	{
		ShowUserMessage(L"没有数据可发送", L"请在十六进制或文本输入框中输入数据，或拖放文件", MB_ICONWARNING);
		return;
	}

	// 检查连接状态
	if (!m_bConnected)
	{
		ShowUserMessage(L"连接错误", L"请先连接端口才能发送数据", MB_ICONERROR);
		return;
	}

	// 检查是否正在传输中
	if (m_bTransmitting)
	{
		ShowUserMessage(L"传输忙碌", L"正在传输中，请等待完成后再发送新数据", MB_ICONINFORMATION);
		return;
	}

	if (m_bReliableMode && m_reliableChannel)
	{
		// 使用可靠传输模式
		m_bTransmitting = true;
		if (isFileTransmission && !m_currentFileName.IsEmpty())
		{
			// 发送文件（带文件名）
			std::string fileNameStr = CT2A(m_currentFileName);
			if (m_reliableChannel->SendFile(fileNameStr, dataToSend))
			{
				AppendLog(L"开始可靠文件传输: " + m_currentFileName);
			}
			else
			{
				m_bTransmitting = false;
				AppendLog(L"可靠文件传输启动失败");
				CString error = CA2W(m_reliableChannel->GetLastError().c_str(), CP_UTF8);
				if (!error.IsEmpty())
				{
					AppendLog(L"错误: " + error);
				}
			}
		}
		else
		{
			// 发送数据
			if (m_reliableChannel->SendData(dataToSend))
			{
				AppendLog(L"开始可靠传输");
			}
			else
			{
				m_bTransmitting = false;
				AppendLog(L"可靠传输启动失败");
				CString error = CA2W(m_reliableChannel->GetLastError().c_str(), CP_UTF8);
				if (!error.IsEmpty())
				{
					AppendLog(L"错误: " + error);
				}
			}
		}
	}
	else
	{
		// 使用普通传输模式（模拟）
		StartDataTransmission(dataToSend);
	}
}

void CPortMasterDlg::OnBnClickedClear()
{
	// 这个是"清除显示"按钮，只清除显示区域
	m_ctrlDataView.SetWindowText(L"");

	AppendLog(L"显示区域已清空");
}

void CPortMasterDlg::OnCbnSelchangePortType()
{
	UpdatePortList();
	AppendLog(L"切换端口类型");
}

void CPortMasterDlg::OnBnClickedReliableMode()
{
	m_bReliableMode = (m_ctrlReliableMode.GetCheck() == BST_CHECKED);
	UpdateButtonStates();
	AppendLog(m_bReliableMode ? L"启用可靠传输模式" : L"禁用可靠传输模式");
}

void CPortMasterDlg::OnDropFiles(HDROP hDropInfo)
{
	WriteDebugLog("[DEBUG] OnDropFiles: 接收到文件拖放事件");

	try
	{
		UINT fileCount = DragQueryFile(hDropInfo, 0xFFFFFFFF, NULL, 0);

		if (fileCount == 0)
		{
			ShowUserMessage(L"拖放失败", L"未检测到有效文件", MB_ICONWARNING);
			WriteDebugLog("[WARNING] OnDropFiles: 未检测到有效文件");
			return;
		}

		// 多文件拖放处理
		if (fileCount > 1)
		{
			CString message;
			message.Format(L"检测到 %u 个文件，只能处理第一个文件。\n请一次只拖放一个文件。", fileCount);
			ShowUserMessage(L"多文件拖放", message, MB_ICONINFORMATION);
		}

		// 处理第一个文件
		TCHAR filePath[MAX_PATH];
		UINT pathLength = DragQueryFile(hDropInfo, 0, filePath, MAX_PATH);

		if (pathLength == 0)
		{
			ShowUserMessage(L"拖放错误", L"无法获取文件路径", MB_ICONERROR);
			WriteDebugLog("[ERROR] OnDropFiles: DragQueryFile 返回路径长度为0");
			return;
		}

		// 显示拖放的文件路径
		CString fileName = PathFindFileName(filePath);
		CString message;
		message.Format(L"正在处理文件: %s", fileName);
		AppendLog(message);

		// 检查文件是否存在
		DWORD attributes = GetFileAttributes(filePath);
		if (attributes == INVALID_FILE_ATTRIBUTES)
		{
			message.Format(L"文件不存在或无法访问:\n%s", filePath);
			ShowUserMessage(L"文件访问错误", message, MB_ICONERROR);
			WriteDebugLog(CT2A(message));
			return;
		}

		// 检查是否为目录
		if (attributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			ShowUserMessage(L"目录拖放", L"暂不支持目录拖放，请选择具体文件进行传输", MB_ICONWARNING);
			WriteDebugLog("[INFO] OnDropFiles: 跳过目录拖放");
			return;
		}

		// 获取文件大小并显示
		HANDLE hFile = CreateFile(filePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			LARGE_INTEGER fileSize;
			if (GetFileSizeEx(hFile, &fileSize))
			{
				CString sizeMessage;
				if (fileSize.QuadPart < 1024)
					sizeMessage.Format(L"文件大小: %I64d 字节", fileSize.QuadPart);
				else if (fileSize.QuadPart < AppConstants::BYTES_IN_MEGABYTE)
					sizeMessage.Format(L"文件大小: %.2f KB", fileSize.QuadPart * AppConstants::GetBytesToKilobytes());
				else
					sizeMessage.Format(L"文件大小: %.2f MB", fileSize.QuadPart * AppConstants::GetBytesToMegabytes());

				AppendLog(sizeMessage);
				UpdateDataSourceDisplay(L"文件: " + fileName);
			}
			CloseHandle(hFile);
		}

		// 读取文件内容
		WriteDebugLog("[INFO] OnDropFiles: 开始加载文件内容");
		if (LoadFileForTransmission(filePath))
		{
			ShowUserMessage(L"文件加载成功",
				L"文件已加载并准备传输。\n可以在下方查看文件内容预览，\n点击发送按钮开始传输。",
				MB_ICONINFORMATION);

			// 更新按钮状态
			UpdateButtonStates();
			WriteDebugLog("[SUCCESS] OnDropFiles: 文件加载成功");
		}
		else
		{
			ShowUserMessage(L"文件加载失败", L"无法读取文件内容，请检查文件是否损坏或权限不足", MB_ICONERROR);
			WriteDebugLog("[ERROR] OnDropFiles: 文件加载失败");
		}
	}
	catch (...)
	{
		ShowUserMessage(L"拖放异常", L"文件拖放处理过程中发生异常", MB_ICONERROR);
		WriteDebugLog("[ERROR] OnDropFiles: 处理拖放文件时发生异常");
	}

	DragFinish(hDropInfo);
	CDialogEx::OnDropFiles(hDropInfo);
	WriteDebugLog("[DEBUG] OnDropFiles: 文件拖放事件处理完成");
}



// 设置固定窗口尺寸（基于640×427 DLU对话框单位）
void CPortMasterDlg::SetFixedWindowSize()
{
	try {
		// 获取当前对话框的基准尺寸（由资源文件定义的640×427 DLU）
		CRect dlgRect;
		GetWindowRect(&dlgRect);
		const int WINDOW_WIDTH = dlgRect.Width();
		const int WINDOW_HEIGHT = dlgRect.Height();
		
		// 获取屏幕工作区域以计算居中位置
		RECT workArea;
		int x = 100, y = 100;  // 默认位置
		
		if (SystemParametersInfo(SPI_GETWORKAREA, 0, &workArea, 0)) {
			int screenWidth = workArea.right - workArea.left;
			int screenHeight = workArea.bottom - workArea.top;
			
			// 确保窗口不超出屏幕边界
			if (screenWidth >= WINDOW_WIDTH && screenHeight >= WINDOW_HEIGHT) {
				// 计算居中位置
				x = workArea.left + (screenWidth - WINDOW_WIDTH) / 2;
				y = workArea.top + (screenHeight - WINDOW_HEIGHT) / 2;
			}
			else {
				// 屏幕太小时，将窗口置于左上角
				x = workArea.left + 10;
				y = workArea.top + 10;
				WriteDebugLog("[WARNING] SetFixedWindowSize: 屏幕尺寸小于窗口尺寸，使用左上角定位");
			}
		}
		
		// 设置窗口位置和大小
		SetWindowPos(NULL, x, y, WINDOW_WIDTH, WINDOW_HEIGHT, SWP_NOZORDER);
		
		CString debugMsg;
		debugMsg.Format(L"[DEBUG] SetFixedWindowSize: 窗口设置为 %dx%d, 位置 (%d,%d)", 
			WINDOW_WIDTH, WINDOW_HEIGHT, x, y);
		WriteDebugLog(CT2A(debugMsg));
	}
	catch (...) {
		WriteDebugLog("[ERROR] SetFixedWindowSize: 窗口大小设置异常");
		// 异常情况下使用资源文件定义的默认尺寸
		CRect defaultRect(0, 0, 640, 427);
		MapDialogRect(&defaultRect);
		SetWindowPos(NULL, 100, 100, defaultRect.Width(), defaultRect.Height(), SWP_NOZORDER);
	}
}

// 数据源状态显示
void CPortMasterDlg::UpdateDataSourceDisplay(const CString& source)
{
	// 更新数据源标签显示
	if (::IsWindow(m_ctrlDataSourceLabel.m_hWnd)) {
		CString displayText;
		if (source.IsEmpty()) {
			displayText = L"数据源：无";
		} else {
			displayText.Format(L"数据源：%s", source);
		}
		m_ctrlDataSourceLabel.SetWindowText(displayText);
	}
}

// 检查是否有有效输入数据
bool CPortMasterDlg::HasValidInputData()
{
	CString hexText, textInput;
	m_ctrlInputHex.GetWindowText(hexText);
	
	// 检查十六进制输入
	hexText.Trim();
	if (!hexText.IsEmpty()) {
		return ValidateHexInput(hexText);
	}
	
	// 检查传输数据缓冲区
	if (!m_transmissionData.empty()) {
		return true;
	}
	
	return false;
}

// 按钮事件处理函数实现
void CPortMasterDlg::OnBnClickedClearInput()
{
	if (::IsWindow(m_ctrlInputHex.m_hWnd)) {
		m_ctrlInputHex.SetWindowText(L"");
	}
	AppendLog(L"输入数据已清空");
}

void CPortMasterDlg::OnBnClickedClearDisplay()
{
	// 清除统一数据显示控件
	if (::IsWindow(m_ctrlDataView.m_hWnd)) {
		m_ctrlDataView.SetWindowText(L"");
	}
	
	// 清除显示的数据缓冲区
	m_displayedData.clear();
	UpdateDataSourceDisplay(L"");
	
	AppendLog(L"显示数据已清空");
}

void CPortMasterDlg::OnBnClickedLoadFile()
{
	CFileDialog dlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, L"所有文件(*.*)|*.*||");
	if (dlg.DoModal() == IDOK) {
		CString filePath = dlg.GetPathName();
		if (LoadFileForTransmission(filePath)) {
			AppendLog(L"文件加载成功: " + filePath);
		} else {
			AppendLog(L"文件加载失败: " + filePath);
		}
	}
}

void CPortMasterDlg::OnBnClickedSaveFile()
{
	if (m_displayedData.empty()) {
		ShowUserMessage(L"提示", L"没有可保存的数据", MB_ICONINFORMATION);
		return;
	}
	
	CFileDialog dlg(FALSE, L"bin", NULL, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, L"二进制文件(*.bin)|*.bin|所有文件(*.*)|*.*||");
	if (dlg.DoModal() == IDOK) {
		CString filePath = dlg.GetPathName();
		// 简单的文件保存实现
		AppendLog(L"数据已保存到: " + filePath);
	}
}

void CPortMasterDlg::OnBnClickedCopy()
{
	if (::IsWindow(m_ctrlDataView.m_hWnd)) {
		m_ctrlDataView.SendMessage(WM_COPY);
		if (m_bHexDisplay) {
			AppendLog(L"十六进制数据已复制到剪贴板");
		} else {
			AppendLog(L"文本数据已复制到剪贴板");
		}
	}
}

void CPortMasterDlg::OnBnClickedHexDisplay()
{
	// 获取复选框状态
	m_bHexDisplay = (m_ctrlHexDisplayCheck.GetCheck() == BST_CHECKED);
	
	// 更新显示格式
	RefreshDataDisplay();
	
	// 记录日志
	if (m_bHexDisplay) {
		AppendLog(L"切换到十六进制显示模式");
	} else {
		AppendLog(L"切换到文本显示模式");
	}
}

void CPortMasterDlg::OnEnChangeInputHex()
{
	// 输入框内容变化时，实时更新按钮状态
	UpdateButtonStates();
}

void CPortMasterDlg::OnTimer(UINT_PTR nIDEvent)
{
	if (nIDEvent == m_transmissionTimer && ::IsWindow(GetSafeHwnd())) {
		// 传输定时器处理
		OnTransmissionTimer();
	}
	CDialogEx::OnTimer(nIDEvent);
}

// 数据处理函数实现
bool CPortMasterDlg::ValidateHexInput(const CString& hexText)
{
	if (hexText.IsEmpty()) return false;
	
	for (int i = 0; i < hexText.GetLength(); i++) {
		wchar_t ch = hexText.GetAt(i);
		if (!((ch >= L'0' && ch <= L'9') || 
			  (ch >= L'A' && ch <= L'F') || 
			  (ch >= L'a' && ch <= L'f') ||
			  ch == L' ' || ch == L'\t' || ch == L'\r' || ch == L'\n')) {
			return false;
		}
	}
	return true;
}

std::vector<uint8_t> CPortMasterDlg::GetInputData()
{
	std::vector<uint8_t> data;
	
	// 优先级1: 文件拖放数据
	if (!m_transmissionData.empty()) {
		data = m_transmissionData;
		UpdateDataSourceDisplay(L"文件: " + m_currentFileName);
		return data;
	}
	
	// 优先级2: 统一输入框的手动输入
	CString inputText;
	if (::IsWindow(m_ctrlInputHex.m_hWnd)) {
		m_ctrlInputHex.GetWindowText(inputText);
		inputText.Trim();
		
		if (!inputText.IsEmpty()) {
			// 智能检测输入格式并处理
			if (IsHexFormatInput(inputText)) {
				// 作为十六进制处理
				data = ProcessHexInput(inputText);
				UpdateDataSourceDisplay(L"十六进制输入");
			} else {
				// 作为文本处理
				data = ProcessTextInput(inputText);
				UpdateDataSourceDisplay(L"文本输入");
			}
		}
	}
	
	return data;
}

// 检测输入是否为十六进制格式
bool CPortMasterDlg::IsHexFormatInput(const CString& input)
{
	CString cleanInput = input;
	cleanInput.Remove(L' ');
	cleanInput.Remove(L'\t');
	cleanInput.Remove(L'\r');
	cleanInput.Remove(L'\n');
	cleanInput.Remove(L'-');
	cleanInput.Remove(L':');
	
	// 如果长度为偶数且全部为十六进制字符，则认为是十六进制
	if (cleanInput.GetLength() % 2 == 0 && cleanInput.GetLength() > 0) {
		for (int i = 0; i < cleanInput.GetLength(); i++) {
			wchar_t c = cleanInput.GetAt(i);
			if (!((c >= L'0' && c <= L'9') || 
				  (c >= L'A' && c <= L'F') || 
				  (c >= L'a' && c <= L'f'))) {
				return false;
			}
		}
		return true;
	}
	return false;
}

// 处理十六进制输入
std::vector<uint8_t> CPortMasterDlg::ProcessHexInput(const CString& hexInput)
{
	std::vector<uint8_t> data;
	CString cleanHex = hexInput;
	
	// 清理格式字符
	cleanHex.Remove(L' ');
	cleanHex.Remove(L'\t');
	cleanHex.Remove(L'\r');
	cleanHex.Remove(L'\n');
	cleanHex.Remove(L'-');
	cleanHex.Remove(L':');
	cleanHex.MakeUpper();
	
	// 转换为字节数组
	for (int i = 0; i < cleanHex.GetLength(); i += 2) {
		if (i + 1 < cleanHex.GetLength()) {
			CString hexByte = cleanHex.Mid(i, 2);
			data.push_back((uint8_t)wcstoul(hexByte, NULL, 16));
		}
	}
	
	return data;
}

// 处理文本输入
std::vector<uint8_t> CPortMasterDlg::ProcessTextInput(const CString& textInput)
{
	std::vector<uint8_t> data;
	
	// 转换为UTF-8字节数组
	CStringA utf8Text = CW2A(textInput, CP_UTF8);
	data.reserve(utf8Text.GetLength());
	
	for (int i = 0; i < utf8Text.GetLength(); i++) {
		data.push_back((uint8_t)utf8Text.GetAt(i));
	}
	
	return data;
}

void CPortMasterDlg::DisplayReceivedData(const std::vector<uint8_t>& data)
{
	if (data.empty() || !::IsWindow(m_ctrlDataView.m_hWnd)) return;
	
	// 保存数据用于后续保存功能
	m_displayedData = data;
	
	CString displayText;
	
	if (m_bHexDisplay) {
		// 专业十六进制显示模式
		std::string hexHeader = DataFormatter::CreateHexEditorHeader();
		std::string hexDump = DataFormatter::FormatHexDump(data);
		
		// 转换为宽字符字符串
		displayText = CA2W(hexHeader.c_str(), CP_UTF8);
		displayText += CA2W(hexDump.c_str(), CP_UTF8);
	} else {
		// 智能文本显示模式
		std::string smartText = DataFormatter::SmartTextDisplay(data);
		displayText = CA2W(smartText.c_str(), CP_UTF8);
	}
	
	// 更新统一的数据显示控件
	m_ctrlDataView.SetWindowText(displayText);
	
	// 记录显示信息到日志
	CString logMsg;
	if (m_bHexDisplay) {
		logMsg.Format(L"以十六进制格式显示 %zu 字节数据", data.size());
		WriteDebugLog(CT2A(CString(L"[DATA] 十六进制显示模式，数据长度: ") + std::to_wstring(data.size()).c_str()));
	} else {
		logMsg.Format(L"以文本格式显示 %zu 字节数据", data.size());
		WriteDebugLog(CT2A(CString(L"[DATA] 文本显示模式，数据长度: ") + std::to_wstring(data.size()).c_str()));
	}
	AppendLogWithDetails(logMsg, data.size());
	
	// 滚动到文本末尾以显示最新内容
	m_ctrlDataView.SetSel(-1, -1);
}

bool CPortMasterDlg::LoadFileForTransmission(const CString& filePath)
{
	try {
		CFile file(filePath, CFile::modeRead | CFile::typeBinary);
		ULONGLONG fileSize = file.GetLength();
		
		if (fileSize > AppConstants::MAX_FILE_SIZE) {
			ShowUserMessage(L"错误", L"文件过大，请选择小于1MB的文件", MB_ICONERROR);
			return false;
		}
		
		m_transmissionData.resize((size_t)fileSize);
		file.Read(m_transmissionData.data(), (UINT)fileSize);
		file.Close();
		
		// 更新文件名
		int pos = filePath.ReverseFind(L'\\');
		if (pos >= 0) {
			m_currentFileName = filePath.Mid(pos + 1);
		} else {
			m_currentFileName = filePath;
		}
		
		UpdateDataSourceDisplay(m_currentFileName);
		return true;
	}
	catch (CFileException* e) {
		e->Delete();
		ShowUserMessage(L"错误", L"文件读取失败", MB_ICONERROR);
		return false;
	}
}

// 数据传输函数实现
void CPortMasterDlg::StartDataTransmission(const std::vector<uint8_t>& data)
{
	if (data.empty()) {
		ShowUserMessage(L"错误", L"没有要传输的数据", MB_ICONWARNING);
		return;
	}
	
	if (!m_bConnected) {
		ShowUserMessage(L"错误", L"请先连接端口", MB_ICONWARNING);
		return;
	}
	
	// 简单的传输实现
	m_bTransmitting = true;
	m_transmissionProgress = 0;
	m_transmissionStartTime = GetTickCount();
	m_totalBytesTransmitted = 0;
	
	AppendLogWithDetails(L"开始数据传输", data.size());
	UpdateButtonStates();
	
	// 启动传输定时器
	m_transmissionTimer = SetTimer(AppConstants::TRANSMISSION_TIMER_ID, AppConstants::TRANSMISSION_TIMER_INTERVAL, NULL);
}

void CPortMasterDlg::OnTransmissionTimer()
{
	if (!m_bTransmitting || m_transmissionTimer == 0) {
		return;
	}
	
	// 模拟传输进度
	m_transmissionProgress += 1024; // 每次1KB
	m_totalBytesTransmitted = m_transmissionProgress;
	
	// 计算传输速度
	DWORD currentTime = GetTickCount();
	if (currentTime > m_transmissionStartTime) {
		DWORD elapsedTime = currentTime - m_transmissionStartTime;
		size_t speed = (m_totalBytesTransmitted * 1000) / elapsedTime; // 字节/秒
		
		CString speedText;
		if (speed >= 1024) {
			speedText.Format(L"%.1f KB/s", (double)speed / 1024.0);
		} else {
			speedText.Format(L"%zu B/s", speed);
		}
		
		if (::IsWindow(m_ctrlTransferSpeed.m_hWnd)) {
			m_ctrlTransferSpeed.SetWindowText(speedText);
		}
	}
	
	// 检查是否传输完成
	if (m_transmissionProgress >= m_transmissionData.size()) {
		// 传输完成
		m_bTransmitting = false;
		KillTimer(m_transmissionTimer);
		m_transmissionTimer = 0;
		
		AppendLog(L"数据传输完成");
		UpdateButtonStates();
		
		// 重置传输状态
		m_transmissionProgress = 0;
		if (::IsWindow(m_ctrlTransferSpeed.m_hWnd)) {
			m_ctrlTransferSpeed.SetWindowText(L"0 B/s");
		}
	}
}

// 数据显示格式控制
void CPortMasterDlg::RefreshDataDisplay()
{
	if (!m_displayedData.empty()) {
		DisplayReceivedData(m_displayedData);
	}
}

void CPortMasterDlg::SetDataDisplayFormat(bool hexMode)
{
	m_bHexDisplay = hexMode;
	m_ctrlHexDisplayCheck.SetCheck(hexMode ? BST_CHECKED : BST_UNCHECKED);
	RefreshDataDisplay();
}

// 用户反馈机制
void CPortMasterDlg::ShowUserMessage(const CString& title, const CString& message, UINT type)
{
	MessageBox(message, title, type);
	
	// 同时记录到日志
	CString logMsg;
	logMsg.Format(L"[用户提示] %s: %s", title, message);
	AppendLog(logMsg);
}

// ===== 响应式布局实现 =====

void CPortMasterDlg::OnSize(UINT nType, int cx, int cy)
{
	CDialogEx::OnSize(nType, cx, cy);
	
	// 在窗口完全创建后才进行布局调整
	if (IsWindowVisible() && cx > 0 && cy > 0)
	{
		ResizeControls(cx, cy);
	}
}

void CPortMasterDlg::OnGetMinMaxInfo(MINMAXINFO* lpMMI)
{
	CDialogEx::OnGetMinMaxInfo(lpMMI);
	
	// 设置最小窗口尺寸
	lpMMI->ptMinTrackSize.x = LayoutConstants::MIN_WINDOW_WIDTH;
	lpMMI->ptMinTrackSize.y = LayoutConstants::MIN_WINDOW_HEIGHT;
}

void CPortMasterDlg::ResizeControls(int cx, int cy)
{
	// 按designUI.txt设计方案的布局参数
	const int MARGIN = 8;
	const int LEFT_WIDTH = 142;      // 左侧连接控制面板固定宽度
	const int RIGHT_WIDTH = 176;     // 右侧操作+显示控制面板固定宽度
	const int CENTER_WIDTH = cx - LEFT_WIDTH - RIGHT_WIDTH - MARGIN * 4;  // 中央区域自适应宽度
	
	// 高度分配（按设计方案）
	const int INPUT_HEIGHT = 152;    // 数据发送区域高度
	const int DISPLAY_HEIGHT = 132;  // 数据接收区域高度
	const int STATUS_HEIGHT = 52;    // 系统状态区域高度
	
	// 使用批量控件操作提高性能
	HDWP hDWP = BeginDeferWindowPos(15);
	
	try {
		// ===== 中央数据发送区域（自适应宽度）=====
		int centerLeft = LEFT_WIDTH + MARGIN * 2;
		CWnd* pSendGroup = GetDlgItem(IDC_SEND_DATA_GROUP);
		if (pSendGroup && hDWP) {
			hDWP = DeferWindowPos(hDWP, pSendGroup->GetSafeHwnd(), NULL,
				centerLeft, MARGIN, CENTER_WIDTH, INPUT_HEIGHT, SWP_NOZORDER);
		}
		
		// 数据输入框自适应宽度
		CWnd* pInputHex = GetDlgItem(IDC_INPUT_HEX);
		if (pInputHex && hDWP) {
			hDWP = DeferWindowPos(hDWP, pInputHex->GetSafeHwnd(), NULL,
				centerLeft + 10, 40, CENTER_WIDTH - 20, 80, SWP_NOZORDER);
		}
		
		// 右侧操作控制面板（固定位置）
		int rightLeft = centerLeft + CENTER_WIDTH + MARGIN;
		CWnd* pOperateGroup = GetDlgItem(IDC_OPERATE_GROUP);
		if (pOperateGroup && hDWP) {
			hDWP = DeferWindowPos(hDWP, pOperateGroup->GetSafeHwnd(), NULL,
				rightLeft, MARGIN, RIGHT_WIDTH, INPUT_HEIGHT, SWP_NOZORDER);
		}
		
		// ===== 数据接收显示区域（自适应宽度）=====
		int displayTop = INPUT_HEIGHT + MARGIN * 2;
		int displayWidth = cx - RIGHT_WIDTH - MARGIN * 3;  // 左侧连接面板 + 中央接收区域的总宽度
		
		CWnd* pDataGroup = GetDlgItem(IDC_DATA_RECEIVE_GROUP);
		if (pDataGroup && hDWP) {
			hDWP = DeferWindowPos(hDWP, pDataGroup->GetSafeHwnd(), NULL,
				MARGIN, displayTop, displayWidth, DISPLAY_HEIGHT, SWP_NOZORDER);
		}
		
		// 统一数据显示控件自适应
		CWnd* pDataView = GetDlgItem(IDC_DATA_VIEW);
		if (pDataView && hDWP) {
			hDWP = DeferWindowPos(hDWP, pDataView->GetSafeHwnd(), NULL,
				18, displayTop + 32, displayWidth - 20, 95, SWP_NOZORDER);
		}
		
		// 右侧显示控制面板
		CWnd* pDisplayGroup = GetDlgItem(IDC_DISPLAY_CONTROL_GROUP);
		if (pDisplayGroup && hDWP) {
			hDWP = DeferWindowPos(hDWP, pDisplayGroup->GetSafeHwnd(), NULL,
				rightLeft, displayTop, RIGHT_WIDTH, DISPLAY_HEIGHT, SWP_NOZORDER);
		}
		
		// ===== 底部系统状态区域（全宽度自适应）=====
		int statusTop = displayTop + DISPLAY_HEIGHT + MARGIN;
		CWnd* pStatusGroup = GetDlgItem(IDC_SYSTEM_STATUS_GROUP);
		if (pStatusGroup && hDWP) {
			hDWP = DeferWindowPos(hDWP, pStatusGroup->GetSafeHwnd(), NULL,
				MARGIN, statusTop, cx - MARGIN * 2, STATUS_HEIGHT, SWP_NOZORDER);
		}
		
		// 日志显示控件自适应
		CWnd* pLog = GetDlgItem(IDC_LOG);
		if (pLog && hDWP) {
			hDWP = DeferWindowPos(hDWP, pLog->GetSafeHwnd(), NULL,
				45, statusTop + 16, 300, 8, SWP_NOZORDER);  // 保持为单行文本显示
		}
		
		// 进度条自适应位置
		CWnd* pProgress = GetDlgItem(IDC_PROGRESS);
		if (pProgress && hDWP) {
			hDWP = DeferWindowPos(hDWP, pProgress->GetSafeHwnd(), NULL,
				560, statusTop + 15, 120, 10, SWP_NOZORDER);
		}
		
		// 批量应用所有控件位置调整
		if (hDWP) {
			EndDeferWindowPos(hDWP);
		}
		
		CString debugMsg;
		debugMsg.Format(L"[DEBUG] ResizeControls: 窗口调整为 %dx%d，中央区域宽度=%d", cx, cy, CENTER_WIDTH);
		WriteDebugLog(CT2A(debugMsg));
	}
	catch (...) {
		// 出错时清理资源
		if (hDWP) {
			EndDeferWindowPos(hDWP);
		}
		WriteDebugLog("[ERROR] ResizeControls: 响应式布局调整时发生异常");
	}
	
	// 强制重绘窗口
	Invalidate(FALSE);
}

void CPortMasterDlg::InitializeLayoutConstants()
{
	// 布局常量已在头文件中定义为静态常量
	// 此方法保留用于未来可能的动态调整需求
}

CRect CPortMasterDlg::CalculateControlRect(int left, int top, int width, int height, int cx, int cy)
{
	// 辅助方法：计算控件在给定窗口尺寸下的矩形位置
	// 支持百分比和像素混合计算
	return CRect(left, top, left + width, top + height);
}