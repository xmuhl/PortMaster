#pragma once

#include "FrameCodec.h"
#include "../Transport/ITransport.h"
#include <memory>
#include <functional>
#include <mutex>
#include <atomic>
#include <thread>
#include <condition_variable>
#include <chrono>

// 鍙潬浼犺緭鐘舵€?
enum ReliableState
{
    RELIABLE_IDLE,           // 绌洪棽
    RELIABLE_STARTING,       // 鍙戦€佺锛氬彂閫丼TART甯?
    RELIABLE_SENDING,        // 鍙戦€佺锛氬彂閫佹暟鎹抚
    RELIABLE_ENDING,         // 鍙戦€佺锛氬彂閫丒ND甯?
    RELIABLE_READY,          // 鎺ユ敹绔細鍑嗗鎺ユ敹
    RELIABLE_RECEIVING,      // 鎺ユ敹绔細鎺ユ敹鏁版嵁
    RELIABLE_DONE,           // 瀹屾垚
    RELIABLE_FAILED          // 澶辫触
};

// 浼犺緭缁熻淇℃伅
struct TransferStats
{
    size_t totalBytes;      // 鎬诲瓧鑺傛暟
    size_t transferredBytes; // 宸蹭紶杈撳瓧鑺傛暟
    size_t totalFrames;     // 鎬诲抚鏁?
    size_t sentFrames;      // 宸插彂閫佸抚鏁?
    size_t retransmissions; // 閲嶄紶娆℃暟
    size_t crcErrors;       // CRC閿欒娆℃暟
    size_t timeouts;        // 瓒呮椂娆℃暟
    
    TransferStats() 
        : totalBytes(0), transferredBytes(0), totalFrames(0)
        , sentFrames(0), retransmissions(0), crcErrors(0), timeouts(0) {}
    
    double GetProgress() const
    {
        return totalBytes > 0 ? static_cast<double>(transferredBytes) / totalBytes : 0.0;
    }
};

// 鍥炶皟鍑芥暟绫诲瀷
typedef std::function<void(const TransferStats&)> ProgressCallback;
typedef std::function<void(bool, const std::string&)> CompletionCallback;
typedef std::function<void(const std::string&, const std::vector<uint8_t>&)> FileReceivedCallback;

// 鍙潬浼犺緭閫氶亾
class ReliableChannel
{
public:
    ReliableChannel(std::shared_ptr<ITransport> transport);
    ~ReliableChannel();

    // 鍩烘湰鎿嶄綔
    bool Start();
    void Stop();
    bool IsActive() const;
    
    // 鍙戦€佹搷浣?    bool SendData(const std::vector<uint8_t>& data);
    bool SendFile(const std::string& filePath);
    bool SendFile(const std::string& filename, const std::vector<uint8_t>& fileData);
    
    // 鎺ユ敹鎿嶄綔
    void EnableReceiving(bool enable);
    bool IsReceivingEnabled() const;
    
    // 鐘舵€佹煡璇?    ReliableState GetState() const;
    TransferStats GetStats() const;
    std::string GetLastError() const;
    
    // 閰嶇疆
    void SetAckTimeout(int timeoutMs) { m_ackTimeoutMs = timeoutMs; }
    void SetMaxRetries(int maxRetries) { m_maxRetries = maxRetries; }
    void SetMaxPayloadSize(size_t size) { m_frameCodec.SetMaxPayloadSize(size); }
    void SetReceiveDirectory(const std::string& directory) { m_receiveDirectory = directory; }
    
    int GetAckTimeout() const { return m_ackTimeoutMs; }
    int GetMaxRetries() const { return m_maxRetries; }
    size_t GetMaxPayloadSize() const { return m_frameCodec.GetMaxPayloadSize(); }
    std::string GetReceiveDirectory() const { return m_receiveDirectory; }
    
    // 鍥炶皟璁剧疆
    void SetProgressCallback(ProgressCallback callback) { m_progressCallback = callback; }
    void SetCompletionCallback(CompletionCallback callback) { m_completionCallback = callback; }
    void SetFileReceivedCallback(FileReceivedCallback callback) { m_fileReceivedCallback = callback; }

private:
    std::shared_ptr<ITransport> m_transport;
    FrameCodec m_frameCodec;
    
    // 鐘舵€佸彉閲?    std::atomic<ReliableState> m_state;
    std::atomic<bool> m_active;
    std::atomic<bool> m_receivingEnabled;
    std::string m_lastError;
    mutable std::mutex m_mutex;
    
    // 鍙戦€佺鐘舵€?    std::vector<uint8_t> m_sendData;
    std::string m_sendFilename;
    size_t m_sendOffset;
    uint16_t m_sendSequence;
    int m_retryCount;
    std::chrono::steady_clock::time_point m_lastSendTime;
    
    // 鎺ユ敹绔姸鎬?    std::vector<uint8_t> m_receiveBuffer;
    std::vector<uint8_t> m_receivedData;
    std::string m_receivedFilename;
    uint16_t m_expectedSequence;
    StartMetadata m_receiveMetadata;
    
    // 缁熻淇℃伅
    TransferStats m_stats;
    
    // 閰嶇疆鍙傛暟
    int m_ackTimeoutMs = 1000;  // ACK瓒呮椂鏃堕棿
    int m_maxRetries = 3;       // 鏈€澶ч噸璇曟鏁?
    std::string m_receiveDirectory; // 鎺ユ敹鐩綍
    
    // 宸ヤ綔绾跨▼
    std::thread m_protocolThread;
    std::atomic<bool> m_stopThread;
    std::condition_variable m_protocolCV;
    
    // 鍥炶皟鍑芥暟
    ProgressCallback m_progressCallback;
    CompletionCallback m_completionCallback;
    FileReceivedCallback m_fileReceivedCallback;
    
    // 鍐呴儴鏂规硶
    void ProtocolThreadFunc();
    void OnDataReceived(const std::vector<uint8_t>& data);
    void ProcessReceivedData();
    void ProcessReceivedFrame(const Frame& frame);
    
    // 鍙戦€佺鐘舵€佹満
    void HandleSending();
    void SendStartFrame();
    void SendDataFrame();
    void SendEndFrame();
    bool WaitForAck(uint16_t sequence);
    
    // 鎺ユ敹绔姸鎬佹満
    void HandleReceiving();
    void SendAck(uint16_t sequence);
    void SendNak(uint16_t sequence);
    void CompleteReceive();
    void AbortReceive(const std::string& reason);
    
    // 杈呭姪鏂规硶
    void SetState(ReliableState state);
    void SetError(const std::string& error);
    void UpdateProgress();
    void NotifyCompletion(bool success, const std::string& message);
    std::string GenerateUniqueFilename(const std::string& originalName);
    bool SaveReceivedFile();
    
    // 鍙戦€佸師濮嬪抚
    bool SendFrame(const Frame& frame);
};