#include "pch.h"
#include "DeviceManager.h"
#include "../Transport/SerialTransport.h"
#include "../Transport/LptSpoolerTransport.h"
#include "../Transport/UsbPrinterTransport.h"
#include "ConfigManager.h"
#include <algorithm>
#include <sstream>
#include <regex>
#include <windows.h>

DeviceManager::DeviceManager()
    : m_monitoring(false)
    , m_stopMonitoring(false)
{
    LoadDeviceHistory();
    LoadFavoriteDevices();
}

DeviceManager::~DeviceManager()
{
    StopDeviceMonitoring();
    SaveDeviceHistory();
    SaveFavoriteDevices();
}

std::vector<DeviceInfo> DeviceManager::EnumerateAllDevices()
{
    std::vector<DeviceInfo> allDevices;
    
    // 串口设备
    auto serialDevices = EnumerateSerialPorts();
    allDevices.insert(allDevices.end(), serialDevices.begin(), serialDevices.end());
    
    // TCP设备 (常用配置)
    auto tcpDevices = EnumerateTcpDevices();
    allDevices.insert(allDevices.end(), tcpDevices.begin(), tcpDevices.end());
    
    // UDP设备 (常用配置)
    auto udpDevices = EnumerateUdpDevices();
    allDevices.insert(allDevices.end(), udpDevices.begin(), udpDevices.end());
    
    // LPT打印机
    auto lptDevices = EnumerateLptPrinters();
    allDevices.insert(allDevices.end(), lptDevices.begin(), lptDevices.end());
    
    // USB打印机
    auto usbDevices = EnumerateUsbPrinters();
    allDevices.insert(allDevices.end(), usbDevices.begin(), usbDevices.end());
    
    // 虚拟设备
    auto virtualDevices = EnumerateVirtualDevices();
    allDevices.insert(allDevices.end(), virtualDevices.begin(), virtualDevices.end());
    
    // 自定义设备
    allDevices.insert(allDevices.end(), m_customDevices.begin(), m_customDevices.end());
    
    // 去重并排序
    DeduplicateDevices(allDevices);
    SortDevices(allDevices);
    
    return allDevices;
}

std::vector<DeviceInfo> DeviceManager::EnumerateDevicesByType(const std::string& transportType)
{
    if (transportType == "Serial") {
        return EnumerateSerialPorts();
    } else if (transportType == "TCP") {
        return EnumerateTcpDevices();
    } else if (transportType == "UDP") {
        return EnumerateUdpDevices();
    } else if (transportType == "LPT") {
        return EnumerateLptPrinters();
    } else if (transportType == "USB") {
        return EnumerateUsbPrinters();
    } else if (transportType == "Loopback") {
        return EnumerateVirtualDevices();
    }
    
    return std::vector<DeviceInfo>();
}

std::vector<DeviceInfo> DeviceManager::EnumerateSerialPorts()
{
    std::vector<DeviceInfo> devices;
    
    // 使用SerialTransport的现有枚举功能
    auto portNames = SerialTransport::EnumeratePorts();
    
    for (const auto& portName : portNames)
    {
        DeviceInfo device(portName, "Serial");
        device.displayName = "串口 " + portName;
        device.description = GetDeviceDescription(portName, "Serial");
        device.isAvailable = IsSerialPortAvailable(portName);
        
        // 添加串口特定属性
        device.properties["type"] = "Serial";
        device.properties["interface"] = "RS232/RS485";
        
        devices.push_back(device);
    }
    
    return devices;
}

std::vector<DeviceInfo> DeviceManager::EnumerateTcpDevices()
{
    std::vector<DeviceInfo> devices;
    
    // 常用的TCP配置
    std::vector<std::pair<std::string, int>> commonTcpConfigs = {
        {"127.0.0.1", 8080},
        {"127.0.0.1", 9000},
        {"127.0.0.1", 10001},
        {"192.168.1.100", 8080},
        {"localhost", 8080}
    };
    
    for (const auto& config : commonTcpConfigs)
    {
        // TCP客户端模式
        auto clientDevice = CreateTcpDevice(config.first, config.second, false);
        devices.push_back(clientDevice);
        
        // TCP服务器模式
        auto serverDevice = CreateTcpDevice(config.first, config.second, true);
        devices.push_back(serverDevice);
    }
    
    return devices;
}

std::vector<DeviceInfo> DeviceManager::EnumerateUdpDevices()
{
    std::vector<DeviceInfo> devices;
    
    // 常用的UDP配置
    std::vector<std::pair<std::string, int>> commonUdpConfigs = {
        {"127.0.0.1", 8080},
        {"127.0.0.1", 9000},
        {"192.168.1.100", 8080},
        {"255.255.255.255", 8080} // 广播
    };
    
    for (const auto& config : commonUdpConfigs)
    {
        auto device = CreateUdpDevice(config.first, config.second);
        devices.push_back(device);
    }
    
    return devices;
}

std::vector<DeviceInfo> DeviceManager::EnumerateLptPrinters()
{
    std::vector<DeviceInfo> devices;
    
    // 使用LptSpoolerTransport的现有枚举功能
    auto printerNames = LptSpoolerTransport::EnumeratePrinters();
    
    for (const auto& printerName : printerNames)
    {
        DeviceInfo device(printerName, "LPT");
        device.displayName = "LPT打印机 " + printerName;
        device.description = GetDeviceDescription(printerName, "LPT");
        device.isAvailable = true; // 假设打印机可用
        
        device.properties["type"] = "LPT";
        device.properties["interface"] = "Print Spooler";
        
        devices.push_back(device);
    }
    
    return devices;
}

std::vector<DeviceInfo> DeviceManager::EnumerateUsbPrinters()
{
    std::vector<DeviceInfo> devices;
    
    // 使用UsbPrinterTransport的现有枚举功能
    auto printerNames = UsbPrinterTransport::EnumerateUsbPrinters();
    
    for (const auto& printerName : printerNames)
    {
        DeviceInfo device(printerName, "USB");
        device.displayName = "USB打印机 " + printerName;
        device.description = GetDeviceDescription(printerName, "USB");
        device.isAvailable = true; // 假设USB打印机可用
        
        device.properties["type"] = "USB";
        device.properties["interface"] = "USB";
        
        devices.push_back(device);
    }
    
    return devices;
}

std::vector<DeviceInfo> DeviceManager::EnumerateVirtualDevices()
{
    std::vector<DeviceInfo> devices;
    
    // 环回设备
    auto loopbackDevice = CreateVirtualDevice("Loopback", "Loopback");
    loopbackDevice.description = "内部环回测试设备";
    devices.push_back(loopbackDevice);
    
    return devices;
}

bool DeviceManager::IsDeviceAvailable(const std::string& deviceName, const std::string& transportType)
{
    if (transportType == "Serial") {
        return IsSerialPortAvailable(deviceName);
    } else if (transportType == "Loopback") {
        return true; // 虚拟设备总是可用
    } else if (transportType == "TCP" || transportType == "UDP") {
        // 网络设备需要更复杂的可用性检查
        return true; // 简化处理
    }
    
    return false;
}

void DeviceManager::AddToHistory(const DeviceInfo& device)
{
    // 移除重复项
    auto it = std::remove_if(m_historyDevices.begin(), m_historyDevices.end(),
        [&device](const DeviceInfo& existing) {
            return existing.deviceName == device.deviceName && 
                   existing.transportType == device.transportType;
        });
    m_historyDevices.erase(it, m_historyDevices.end());
    
    // 添加到前面
    m_historyDevices.insert(m_historyDevices.begin(), device);
    
    // 限制历史记录数量
    if (m_historyDevices.size() > 20) {
        m_historyDevices.resize(20);
    }
    
    SaveDeviceHistory();
}

void DeviceManager::AddToFavorites(const DeviceInfo& device)
{
    // 检查是否已存在
    auto it = std::find_if(m_favoriteDevices.begin(), m_favoriteDevices.end(),
        [&device](const DeviceInfo& existing) {
            return existing.deviceName == device.deviceName && 
                   existing.transportType == device.transportType;
        });
    
    if (it == m_favoriteDevices.end()) {
        m_favoriteDevices.push_back(device);
        SaveFavoriteDevices();
    }
}

void DeviceManager::RemoveFromFavorites(const std::string& deviceName, const std::string& transportType)
{
    auto it = std::remove_if(m_favoriteDevices.begin(), m_favoriteDevices.end(),
        [&](const DeviceInfo& device) {
            return device.deviceName == deviceName && device.transportType == transportType;
        });
    
    if (it != m_favoriteDevices.end()) {
        m_favoriteDevices.erase(it, m_favoriteDevices.end());
        SaveFavoriteDevices();
    }
}

std::vector<DeviceInfo> DeviceManager::GetHistoryDevices()
{
    return m_historyDevices;
}

std::vector<DeviceInfo> DeviceManager::GetFavoriteDevices()
{
    return m_favoriteDevices;
}

DeviceInfo DeviceManager::CreateTcpDevice(const std::string& address, int port, bool isServer)
{
    std::string deviceName = address + ":" + std::to_string(port);
    DeviceInfo device(deviceName, "TCP");
    
    device.displayName = (isServer ? "TCP服务器 " : "TCP客户端 ") + deviceName;
    device.description = isServer ? "TCP服务器连接" : "TCP客户端连接";
    device.isAvailable = true;
    
    device.properties["address"] = address;
    device.properties["port"] = std::to_string(port);
    device.properties["mode"] = isServer ? "server" : "client";
    
    return device;
}

DeviceInfo DeviceManager::CreateUdpDevice(const std::string& address, int port)
{
    std::string deviceName = address + ":" + std::to_string(port);
    DeviceInfo device(deviceName, "UDP");
    
    device.displayName = "UDP " + deviceName;
    device.description = "UDP数据报连接";
    device.isAvailable = true;
    
    device.properties["address"] = address;
    device.properties["port"] = std::to_string(port);
    
    return device;
}

DeviceInfo DeviceManager::CreateVirtualDevice(const std::string& name, const std::string& type)
{
    DeviceInfo device(name, type);
    device.displayName = "虚拟设备 " + name;
    device.isAvailable = true;
    
    device.properties["virtual"] = "true";
    
    return device;
}

bool DeviceManager::IsSerialPortAvailable(const std::string& portName)
{
    // 尝试短暂打开端口测试可用性
    std::string portPath = "\\\\.\\" + portName;
    HANDLE hPort = CreateFileA(
        portPath.c_str(),
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
    );
    
    if (hPort != INVALID_HANDLE_VALUE) {
        CloseHandle(hPort);
        return true;
    }
    
    return false;
}

std::string DeviceManager::GetDeviceDescription(const std::string& deviceName, const std::string& transportType)
{
    if (transportType == "Serial") {
        return "串行通信端口";
    } else if (transportType == "TCP") {
        return "TCP网络连接";
    } else if (transportType == "UDP") {
        return "UDP数据报连接";
    } else if (transportType == "LPT") {
        return "并行端口打印机";
    } else if (transportType == "USB") {
        return "USB打印机";
    }
    
    return "未知设备类型";
}

void DeviceManager::DeduplicateDevices(std::vector<DeviceInfo>& devices) const
{
    std::sort(devices.begin(), devices.end(), 
        [](const DeviceInfo& a, const DeviceInfo& b) {
            if (a.transportType != b.transportType)
                return a.transportType < b.transportType;
            return a.deviceName < b.deviceName;
        });
    
    auto it = std::unique(devices.begin(), devices.end(),
        [](const DeviceInfo& a, const DeviceInfo& b) {
            return a.deviceName == b.deviceName && a.transportType == b.transportType;
        });
    
    devices.erase(it, devices.end());
}

void DeviceManager::SortDevices(std::vector<DeviceInfo>& devices, const std::string& sortBy) const
{
    if (sortBy == "name") {
        std::sort(devices.begin(), devices.end(),
            [](const DeviceInfo& a, const DeviceInfo& b) {
                return a.deviceName < b.deviceName;
            });
    } else if (sortBy == "type") {
        std::sort(devices.begin(), devices.end(),
            [](const DeviceInfo& a, const DeviceInfo& b) {
                if (a.transportType != b.transportType)
                    return a.transportType < b.transportType;
                return a.deviceName < b.deviceName;
            });
    }
}

void DeviceManager::LoadDeviceHistory()
{
    // 使用ConfigManager加载历史记录
    ConfigManager config;
    config.LoadConfig();
    
    // 简化实现：从配置中加载历史设备
    // TODO: 实现完整的历史记录持久化
    m_historyDevices.clear();
}

void DeviceManager::SaveDeviceHistory()
{
    // 使用ConfigManager保存历史记录
    ConfigManager config;
    config.LoadConfig();
    
    // 简化实现：保存历史设备到配置
    // TODO: 实现完整的历史记录持久化
    
    config.SaveConfig();
}

void DeviceManager::LoadFavoriteDevices()
{
    m_favoriteDevices.clear();
    // TODO: 从配置文件加载收藏设备
}

void DeviceManager::SaveFavoriteDevices()
{
    // TODO: 保存收藏设备到配置文件
}

std::vector<DeviceInfo> DeviceManager::FilterDevices(const std::vector<DeviceInfo>& devices, 
                                                     const std::string& filter) const
{
    if (filter.empty()) {
        return devices;
    }
    
    std::vector<DeviceInfo> filtered;
    std::string lowerFilter = filter;
    std::transform(lowerFilter.begin(), lowerFilter.end(), lowerFilter.begin(), ::tolower);
    
    for (const auto& device : devices) {
        std::string lowerName = device.displayName;
        std::transform(lowerName.begin(), lowerName.end(), lowerName.begin(), ::tolower);
        
        if (lowerName.find(lowerFilter) != std::string::npos ||
            device.deviceName.find(filter) != std::string::npos ||
            device.transportType.find(filter) != std::string::npos) {
            filtered.push_back(device);
        }
    }
    
    return filtered;
}

size_t DeviceManager::GetTotalDeviceCount() const
{
    // 为了避免const问题，我们重新实现而不调用非const方法
    size_t totalCount = 0;
    
    // 简化计数：估算常见设备类型数量
    totalCount += SerialTransport::EnumeratePorts().size();
    totalCount += LptSpoolerTransport::EnumeratePrinters().size();
    totalCount += UsbPrinterTransport::EnumerateUsbPrinters().size();
    totalCount += 8; // TCP/UDP常用配置
    totalCount += 1; // Loopback
    totalCount += m_customDevices.size();
    
    return totalCount;
}

std::map<std::string, size_t> DeviceManager::GetDeviceCountByType() const
{
    std::map<std::string, size_t> counts;
    
    counts["Serial"] = SerialTransport::EnumeratePorts().size();
    counts["LPT"] = LptSpoolerTransport::EnumeratePrinters().size();
    counts["USB"] = UsbPrinterTransport::EnumerateUsbPrinters().size();
    counts["TCP"] = 4; // 常用TCP配置数量
    counts["UDP"] = 4; // 常用UDP配置数量
    counts["Loopback"] = 1;
    
    // 统计自定义设备
    for (const auto& device : m_customDevices) {
        counts[device.transportType]++;
    }
    
    return counts;
}

void DeviceManager::StartDeviceMonitoring()
{
    if (m_monitoring) return;
    
    m_monitoring = true;
    m_stopMonitoring = false;
    
    // 简化实现：暂时不启动监控线程
    // TODO: 实现设备热插拔监控
}

void DeviceManager::StopDeviceMonitoring()
{
    if (!m_monitoring) return;
    
    m_stopMonitoring = true;
    
    // 等待监控线程结束
    if (m_monitorThread.joinable()) {
        m_monitorThread.join();
    }
    
    m_monitoring = false;
}

void DeviceManager::SetDeviceChangedCallback(DeviceChangedCallback callback)
{
    m_deviceCallback = callback;
}

bool DeviceManager::TestDeviceConnection(const DeviceInfo& device)
{
    // 简化实现：基于设备类型进行基本可用性检查
    return IsDeviceAvailable(device.deviceName, device.transportType);
}

bool DeviceManager::SaveDeviceConfig(const DeviceInfo& device, const TransportConfig& config)
{
    // TODO: 实现设备配置保存
    return true;
}

TransportConfig DeviceManager::LoadDeviceConfig(const DeviceInfo& device)
{
    // TODO: 实现设备配置加载
    return TransportConfig();
}

void DeviceManager::RegisterCustomDevice(const DeviceInfo& device)
{
    // 检查是否已存在
    auto it = std::find_if(m_customDevices.begin(), m_customDevices.end(),
        [&device](const DeviceInfo& existing) {
            return existing.deviceName == device.deviceName && 
                   existing.transportType == device.transportType;
        });
    
    if (it == m_customDevices.end()) {
        m_customDevices.push_back(device);
    }
}

void DeviceManager::UnregisterCustomDevice(const std::string& deviceName, const std::string& transportType)
{
    auto it = std::remove_if(m_customDevices.begin(), m_customDevices.end(),
        [&](const DeviceInfo& device) {
            return device.deviceName == deviceName && device.transportType == transportType;
        });
    
    if (it != m_customDevices.end()) {
        m_customDevices.erase(it, m_customDevices.end());
    }
}

void DeviceManager::MergeDeviceProperties(DeviceInfo& target, const DeviceInfo& source) const
{
    // 合并设备属性
    for (const auto& prop : source.properties) {
        if (target.properties.find(prop.first) == target.properties.end()) {
            target.properties[prop.first] = prop.second;
        }
    }
    
    // 更新描述信息
    if (target.description.empty() && !source.description.empty()) {
        target.description = source.description;
    }
}