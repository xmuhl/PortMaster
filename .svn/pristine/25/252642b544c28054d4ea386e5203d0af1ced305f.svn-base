#pragma once

#include <vector>
#include <mutex>
#include <atomic>

// 鑷姩鎵╁睍鐜舰缂撳啿鍖?class RingBuffer
{
public:
    explicit RingBuffer(size_t initialSize = 4096);
    ~RingBuffer();
    
    // 鍩烘湰鎿嶄綔
    size_t Write(const uint8_t* data, size_t length);
    size_t Write(const std::vector<uint8_t>& data);
    size_t Read(uint8_t* buffer, size_t maxLength);
    size_t Read(std::vector<uint8_t>& buffer, size_t maxLength);
    
    // 鐘舵€佹煡璇?    size_t Available() const;           // 鍙鏁版嵁澶у皬
    size_t FreeSpace() const;          // 鍙啓绌洪棿澶у皬
    size_t Capacity() const;           // 鎬诲閲?    bool IsEmpty() const;              // 鏄惁涓虹┖
    bool IsFull() const;               // 鏄惁宸叉弧
    
    // 绠＄悊鎿嶄綔
    void Clear();                      // 娓呯┖缂撳啿鍖?    bool Resize(size_t newSize);       // 璋冩暣澶у皬
    void SetAutoExpand(bool enable, size_t maxSize = 0); // 璁剧疆鑷姩鎵╁睍
    
    // 闈為樆濉炴搷浣?    uint8_t Peek(size_t offset = 0) const;  // 棰勮鏁版嵁锛堜笉绉婚櫎锛?    size_t Peek(uint8_t* buffer, size_t length, size_t offset = 0) const;
    size_t Skip(size_t length);        // 璺宠繃鏁版嵁
    
    // 鏌ユ壘鎿嶄綔
    size_t Find(uint8_t byte, size_t startOffset = 0) const;
    size_t Find(const uint8_t* pattern, size_t patternLength, size_t startOffset = 0) const;

private:
    mutable std::mutex m_mutex;
    std::vector<uint8_t> m_buffer;
    size_t m_readPos;
    size_t m_writePos;
    std::atomic<size_t> m_dataSize;
    bool m_autoExpand;
    size_t m_maxSize;
    
    // 鍐呴儴杈呭姪鏂规硶
    bool ExpandIfNeeded(size_t requiredSize);
    size_t GetContiguousWriteSize() const;
    size_t GetContiguousReadSize() const;
    void AdvanceWritePos(size_t length);
    void AdvanceReadPos(size_t length);
};