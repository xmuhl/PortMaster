#include "pch.h"
#include "framework.h"
#include "PortMaster.h"
#include "PortMasterDlg.h"
#include "PortConfigDialog.h"
#include "TestWizardDialog.h"
#include "afxdialogex.h"
#include <fstream>
#include <Shlwapi.h>
#include <algorithm>

#pragma comment(lib, "Shlwapi.lib")

extern void WriteDebugLog(const char* message);

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

// 用于应用程序"关于"菜单项的 CAboutDlg 对话框
class CAboutDlg : public CDialogEx
{
public:
	CAboutDlg();

	// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_ABOUTBOX };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	// 实现
protected:
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()

// CPortMasterDlg 对话框
CPortMasterDlg::CPortMasterDlg(CWnd* pParent /*=nullptr*/)
	: CDialogEx(IDD_PORTMASTER_DIALOG, pParent)
	, m_bConnected(false)
	, m_bReliableMode(false)
	, m_bHexDisplay(false)  // 默认文本显示模式
	, m_transmissionProgress(0)
	, m_transmissionTimer(0)
	, m_transmissionStartTime(0)
	, m_totalBytesTransmitted(0)
	, m_lastSpeedUpdateTime(0)
	, m_transmissionCounter(0)
	, m_chunkTransmissionIndex(0)
	, m_chunkSize(256)
{
	WriteDebugLog("[DEBUG] CPortMasterDlg::CPortMasterDlg: 主对话框构造函数开始");
	// 初始化原子变量
	m_bTransmitting.store(false);
	
	m_hIcon = AfxGetApp()->LoadIcon(IDI_MAIN_ICON);
	WriteDebugLog("[DEBUG] CPortMasterDlg::CPortMasterDlg: 主对话框构造函数完成");
}

CPortMasterDlg::~CPortMasterDlg()
{
	WriteDebugLog("[DEBUG] CPortMasterDlg::~CPortMasterDlg: 主对话框析构函数开始");
	
	// 确保所有定时器被正确清理
	if (::IsWindow(GetSafeHwnd())) {
		if (m_transmissionTimer != 0) {
			WriteDebugLog("[DEBUG] CPortMasterDlg::~CPortMasterDlg: 清理传输定时器");
			KillTimer(m_transmissionTimer);
			m_transmissionTimer = 0;
		}
		
		// 清理其他定时器
		KillTimer(3001); // 延迟重绘定时器
	}
	
	WriteDebugLog("[DEBUG] CPortMasterDlg::~CPortMasterDlg: 主对话框析构函数完成");
}

void CPortMasterDlg::DoDataExchange(CDataExchange* pDX)
{
	WriteDebugLog("[DEBUG] DoDataExchange: 开始数据交换");
	CDialogEx::DoDataExchange(pDX);
	WriteDebugLog("[DEBUG] DoDataExchange: CDialogEx::DoDataExchange 完成");

	// 逐个绑定控件，并记录调试信息
	try {
		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_PORT_TYPE");
		DDX_Control(pDX, IDC_PORT_TYPE, m_ctrlPortType);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_PORT_LIST");
		DDX_Control(pDX, IDC_PORT_LIST, m_ctrlPortList);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_BAUD_RATE");
		DDX_Control(pDX, IDC_BAUD_RATE, m_ctrlBaudRate);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_DATA_BITS");
		DDX_Control(pDX, IDC_DATA_BITS, m_ctrlDataBits);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_PARITY");
		DDX_Control(pDX, IDC_PARITY, m_ctrlParity);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_STOP_BITS");
		DDX_Control(pDX, IDC_STOP_BITS, m_ctrlStopBits);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_CONNECT_BUTTON");
		DDX_Control(pDX, IDC_CONNECT_BUTTON, m_ctrlConnectBtn);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_DISCONNECT_BUTTON");
		DDX_Control(pDX, IDC_DISCONNECT_BUTTON, m_ctrlDisconnectBtn);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_SEND_BUTTON");
		DDX_Control(pDX, IDC_SEND_BUTTON, m_ctrlSendBtn);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_CLEAR_INPUT_BUTTON");
		DDX_Control(pDX, IDC_CLEAR_INPUT_BUTTON, m_ctrlClearInputBtn);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_CLEAR_DISPLAY_BUTTON");
		DDX_Control(pDX, IDC_CLEAR_DISPLAY_BUTTON, m_ctrlClearDisplayBtn);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_LOAD_FILE_BUTTON");
		DDX_Control(pDX, IDC_LOAD_FILE_BUTTON, m_ctrlLoadFileBtn);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_SAVE_FILE_BUTTON");
		DDX_Control(pDX, IDC_SAVE_FILE_BUTTON, m_ctrlSaveFileBtn);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_COPY_BUTTON");
		DDX_Control(pDX, IDC_COPY_BUTTON, m_ctrlCopyBtn);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_RELIABLE_MODE");
		DDX_Control(pDX, IDC_RELIABLE_MODE, m_ctrlReliableMode);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_HEX_DISPLAY_CHECK");
		DDX_Control(pDX, IDC_HEX_DISPLAY_CHECK, m_ctrlHexDisplayCheck);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_INPUT_HEX");
		DDX_Control(pDX, IDC_INPUT_HEX, m_ctrlInputHex);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_DATA_VIEW");
		DDX_Control(pDX, IDC_DATA_VIEW, m_ctrlDataView);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_LOG");
		DDX_Control(pDX, IDC_LOG, m_ctrlLog);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_PROGRESS");
		DDX_Control(pDX, IDC_PROGRESS, m_ctrlProgress);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_CONNECTION_STATUS");
		DDX_Control(pDX, IDC_CONNECTION_STATUS, m_ctrlConnectionStatus);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_PROTOCOL_STATUS");
		DDX_Control(pDX, IDC_PROTOCOL_STATUS, m_ctrlProtocolStatus);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_TRANSFER_STATS");
		// DDX_Control(pDX, IDC_TRANSFER_STATS, m_ctrlStatus); // 控件在资源中缺失，注释掉绑定

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_TRANSFER_SPEED");
		DDX_Control(pDX, IDC_TRANSFER_SPEED, m_ctrlTransferSpeed);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_TRANSFER_PROGRESS");
		DDX_Control(pDX, IDC_TRANSFER_PROGRESS, m_ctrlTransferProgress);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_STATUS");
		DDX_Control(pDX, IDC_STATUS, m_ctrlStatus);

		WriteDebugLog("[DEBUG] DoDataExchange: 绑定 IDC_DATA_SOURCE_LABEL");
		DDX_Control(pDX, IDC_DATA_SOURCE_LABEL, m_ctrlDataSourceLabel);
		// DDX_Control(pDX, IDC_TIME_REMAINING, m_ctrlTimeRemaining); // 控件在资源中缺失，注释掉绑定
		// DDX_Control(pDX, IDC_CLEAR_BUTTON, m_ctrlClearBtn);

		WriteDebugLog("[DEBUG] DoDataExchange: 所有控件绑定完成");
	}
	catch (...) {
		WriteDebugLog("[ERROR] DoDataExchange: 控件绑定过程中出现异常");
		throw;
	}
}

BEGIN_MESSAGE_MAP(CPortMasterDlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	// ON_WM_SIZE() 已移除 - 固定窗口大小，不支持拉伸
	ON_WM_GETMINMAXINFO()
	ON_BN_CLICKED(IDC_CONNECT_BUTTON, &CPortMasterDlg::OnBnClickedConnect)
	ON_BN_CLICKED(IDC_DISCONNECT_BUTTON, &CPortMasterDlg::OnBnClickedDisconnect)
	ON_BN_CLICKED(IDC_SEND_BUTTON, &CPortMasterDlg::OnBnClickedSend)
	ON_BN_CLICKED(IDC_CLEAR_INPUT_BUTTON, &CPortMasterDlg::OnBnClickedClearInput)
	ON_BN_CLICKED(IDC_CLEAR_DISPLAY_BUTTON, &CPortMasterDlg::OnBnClickedClearDisplay)
	ON_BN_CLICKED(IDC_CLEAR_BUTTON, &CPortMasterDlg::OnBnClickedClear)
	ON_BN_CLICKED(IDC_LOAD_FILE_BUTTON, &CPortMasterDlg::OnBnClickedLoadFile)
	ON_BN_CLICKED(IDC_SAVE_FILE_BUTTON, &CPortMasterDlg::OnBnClickedSaveFile)
	ON_BN_CLICKED(IDC_COPY_BUTTON, &CPortMasterDlg::OnBnClickedCopy)
	ON_BN_CLICKED(IDC_HEX_DISPLAY_CHECK, &CPortMasterDlg::OnBnClickedHexDisplay)
	ON_CBN_SELCHANGE(IDC_PORT_TYPE, &CPortMasterDlg::OnCbnSelchangePortType)
	ON_BN_CLICKED(IDC_RELIABLE_MODE, &CPortMasterDlg::OnBnClickedReliableMode)
	ON_EN_CHANGE(IDC_INPUT_HEX, &CPortMasterDlg::OnEnChangeInputHex)
	ON_WM_DROPFILES()
	ON_WM_TIMER()
	ON_MESSAGE(WM_USER + 1001, &CPortMasterDlg::OnDisplayReceivedData)
END_MESSAGE_MAP()

// CPortMasterDlg 消息处理程序

BOOL CPortMasterDlg::OnInitDialog()
{
	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 开始初始化主对话框");

	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤1 - 调用CDialogEx::OnInitDialog");

	// 现在应该可以安全调用，因为已经修复了DDX绑定和资源定义
	if (!CDialogEx::OnInitDialog()) {
		WriteDebugLog("[ERROR] PortMasterDlg::OnInitDialog: CDialogEx::OnInitDialog失败");
		return FALSE;
	}
	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: CDialogEx::OnInitDialog成功完成");

	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤2 - 开始初始化复杂对象");
	try {
		// 现在在控件已经正确绑定后初始化复杂对象
		InitializeTransportObjects();
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 复杂对象初始化完成");
	}
	catch (...) {
		WriteDebugLog("[ERROR] PortMasterDlg::OnInitDialog: 复杂对象初始化失败");
		return FALSE;
	}

	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3 - 开始设置系统菜单");
	// 将"关于..."菜单项添加到系统菜单中。
	// IDM_ABOUTBOX 必须在系统命令范围内。
	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3.1 - 检查IDM_ABOUTBOX常量");
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);
	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3.2 - IDM_ABOUTBOX常量检查完成");

	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3.3 - 获取系统菜单");
	CMenu* pSysMenu = GetSystemMenu(FALSE);
	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3.4 - 系统菜单获取完成");
	if (pSysMenu != nullptr)
	{
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3.5 - 系统菜单有效，开始加载字符串");
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3.6 - 字符串加载完成");
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3.7 - 添加菜单项");
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
			WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3.8 - 菜单项添加完成");
		}
	}
	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 步骤3 - 系统菜单设置完成");

	try {
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 设置对话框图标");
		// 设置此对话框的图标。当应用程序主窗口不是对话框时，框架将自动
		//  执行此操作
		SetIcon(m_hIcon, TRUE);			// 设置大图标
		SetIcon(m_hIcon, FALSE);		// 设置小图标
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 对话框图标设置完成");
	}
	catch (...) {
		WriteDebugLog("[ERROR] PortMasterDlg::OnInitDialog: 设置图标异常");
	}

	try {
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 开始初始化控件");
		// 初始化控件
		InitializeControls();
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 控件初始化完成");
	}
	catch (...) {
		WriteDebugLog("[ERROR] PortMasterDlg::OnInitDialog: 初始化控件异常");
		return FALSE;
	}

	try {
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 启用拖放功能");
		// 启用拖放
		DragAcceptFiles(TRUE);
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 拖放功能启用完成");
	}
	catch (...) {
		WriteDebugLog("[ERROR] PortMasterDlg::OnInitDialog: 启用拖放功能异常");
	}

	try {
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 开始自适应窗口大小");
		// 自适应窗口大小到桌面，现在有了动态布局调整功能
		SetFixedWindowSize();
		WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 窗口大小自适应完成");
	}
	catch (...) {
		WriteDebugLog("[ERROR] PortMasterDlg::OnInitDialog: 窗口大小自适应异常");
	}

	WriteDebugLog("[DEBUG] PortMasterDlg::OnInitDialog: 主对话框初始化完成");
	return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE
}

void CPortMasterDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialogEx::OnSysCommand(nID, lParam);
	}
}

// 如果向对话框添加最小化按钮，则需要下面的代码
//  来绘制该图标。对于文档/视图模型的 MFC 应用程序，
//  这将由框架自动完成。

void CPortMasterDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // 用于绘制的设备上下文

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// 使图标在工作区矩形中居中
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// 绘制图标
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

//当用户拖动最小化窗口时系统调用此函数取得光标
//显示。
HCURSOR CPortMasterDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}

void CPortMasterDlg::InitializeControls()
{
	WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 开始初始化控件");

	try {
		// 初始化端口类型下拉框
		m_ctrlPortType.AddString(L"串口");
		m_ctrlPortType.AddString(L"并口");
		m_ctrlPortType.AddString(L"USB打印机");
		m_ctrlPortType.AddString(L"TCP客户端");
		m_ctrlPortType.AddString(L"TCP服务端");
		m_ctrlPortType.AddString(L"UDP");
		m_ctrlPortType.AddString(L"本地回环");
		m_ctrlPortType.SetCurSel(6); // 默认选择本地回环
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 端口类型下拉框初始化完成");

		// 初始化波特率下拉框
		m_ctrlBaudRate.AddString(L"9600");
		m_ctrlBaudRate.AddString(L"19200");
		m_ctrlBaudRate.AddString(L"38400");
		m_ctrlBaudRate.AddString(L"57600");
		m_ctrlBaudRate.AddString(L"115200");
		m_ctrlBaudRate.SetCurSel(0);

		// 初始化数据位下拉框
		m_ctrlDataBits.AddString(L"5");
		m_ctrlDataBits.AddString(L"6");
		m_ctrlDataBits.AddString(L"7");
		m_ctrlDataBits.AddString(L"8");
		m_ctrlDataBits.SetCurSel(3);

		// 初始化停止位下拉框
		m_ctrlStopBits.AddString(L"1");
		m_ctrlStopBits.AddString(L"1.5");
		m_ctrlStopBits.AddString(L"2");
		m_ctrlStopBits.SetCurSel(0);

		// 初始化校验位下拉框
		m_ctrlParity.AddString(L"None");
		m_ctrlParity.AddString(L"Odd");
		m_ctrlParity.AddString(L"Even");
		m_ctrlParity.AddString(L"Mark");
		m_ctrlParity.AddString(L"Space");
		m_ctrlParity.SetCurSel(0);
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 下拉框初始化完成");

		// 更新端口列表
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 开始更新端口列表");
		UpdatePortList();
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 端口列表更新完成");

		// 更新按钮状态
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 开始更新按钮状态");
		UpdateButtonStates();
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 按钮状态更新完成");

		// 初始化十六进制显示复选框状态（与m_bHexDisplay保持同步）
		if (IsWindow(m_ctrlHexDisplayCheck.GetSafeHwnd())) {
			m_ctrlHexDisplayCheck.SetCheck(m_bHexDisplay ? BST_CHECKED : BST_UNCHECKED);
		}
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 十六进制显示复选框初始化完成");

		// 设置文件拖放区域提示文本
		// m_ctrlFileDropZone.SetWindowText(L"拖拽文件到此处加载(不自动传输)");  // 控件不存在

		// 初始化状态显示
		if (IsWindow(m_ctrlConnectionStatus.GetSafeHwnd()))
			m_ctrlConnectionStatus.SetWindowText(L"未连接");
		if (IsWindow(m_ctrlProtocolStatus.GetSafeHwnd()))
			m_ctrlProtocolStatus.SetWindowText(L"空闲");
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 设置状态显示完成");

		// 设置等宽字体用于十六进制显示
		static CFont monoFont;
		monoFont.CreateFont(
			-12,                    // 字体高度
			0,                      // 字体宽度（自动）
			0,                      // 倾斜角度
			0,                      // 基线倾斜角度
			FW_NORMAL,             // 字体粗细
			FALSE,                 // 是否斜体
			FALSE,                 // 是否下划线
			0,                     // 是否删除线
			ANSI_CHARSET,          // 字符集
			OUT_DEFAULT_PRECIS,    // 输出精度
			CLIP_DEFAULT_PRECIS,   // 裁剪精度
			CLEARTYPE_QUALITY,     // 输出质量
			FIXED_PITCH | FF_MODERN, // 字体间距和系列
			_T("Consolas")         // 字体名称，备选：Courier New
		);
		if (IsWindow(m_ctrlDataView.GetSafeHwnd()))
			m_ctrlDataView.SetFont(&monoFont);
		if (IsWindow(m_ctrlInputHex.GetSafeHwnd()))
			m_ctrlInputHex.SetFont(&monoFont);
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 等宽字体设置完成");

		// 初始化十六进制显示复选框状态（与m_bHexDisplay保持同步）
		if (IsWindow(m_ctrlHexDisplayCheck.GetSafeHwnd())) {
			m_ctrlHexDisplayCheck.SetCheck(m_bHexDisplay ? BST_CHECKED : BST_UNCHECKED);
			WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 十六进制显示复选框初始化完成");
		}
		
		// 添加初始化日志
		AppendLog(L"PortMaster 初始化完成");
		AppendLog(L"现代化界面已启用");
		WriteDebugLog("[DEBUG] PortMasterDlg::InitializeControls: 控件初始化完成");
	}
	catch (...) {
		WriteDebugLog("[ERROR] PortMasterDlg::InitializeControls: 控件初始化异常");
		throw;
	}
}

void CPortMasterDlg::InitializeTransportObjects()
{
	WriteDebugLog("[DEBUG] CPortMasterDlg::InitializeTransportObjects: 开始初始化传输对象");

	// 初始化传输层和可靠通道
	m_transport = std::make_shared<LoopbackTransport>();
	m_reliableChannel = std::make_shared<ReliableChannel>(m_transport);
	
	// 保存直接传输模式的数据接收回调（供后续按需设置）
	m_directTransportCallback = [this](const std::vector<uint8_t>& data) {
		WriteDebugLog(("[DIRECT] 接收到直接传输数据，长度: " + std::to_string(data.size())).c_str());
		
		// 确保数据不为空
		if (!data.empty()) {
			DisplayReceivedData(data);
			AppendLogWithDetails(L"直接传输接收完成", data.size());
			WriteDebugLog("[DIRECT] 数据显示完成");
		} else {
			WriteDebugLog("[DIRECT] 警告: 接收到空数据");
		}
	};
	
	// 注意：ReliableChannel构造函数会设置自己的Transport回调
	// 因此这里不立即设置直接传输回调，而是在连接时根据传输模式动态设置

	// 设置可靠通道回调 - 现在控件已经正确绑定，可以安全访问
	m_reliableChannel->SetProgressCallback([this](const TransferStats& stats) {
		// 更新进度显示
		if (stats.totalBytes > 0)
		{
			int progress = static_cast<int>((stats.transferredBytes * 100) / stats.totalBytes);
			if (IsWindow(m_ctrlProgress.GetSafeHwnd())) {
				m_ctrlProgress.SetPos(progress);
			}

			if (IsWindow(m_ctrlStatus.GetSafeHwnd())) {
				CString statusText;
				statusText.Format(L"传输中 (%.1f%%)", stats.GetProgress() * 100);
				m_ctrlStatus.SetWindowText(statusText);
			}
		}
		});

	m_reliableChannel->SetCompletionCallback([this](bool success, const std::string& message) {
		// 传输完成回调
		CString msg = CA2W(message.c_str(), CP_UTF8);
		AppendLog(msg);

		if (success)
		{
			if (IsWindow(m_ctrlProgress.GetSafeHwnd())) {
				m_ctrlProgress.SetPos(0);
			}
			if (IsWindow(m_ctrlStatus.GetSafeHwnd())) {
				m_ctrlStatus.SetWindowText(L"传输完成");
			}
		}
		else
		{
			if (IsWindow(m_ctrlStatus.GetSafeHwnd())) {
				m_ctrlStatus.SetWindowText(L"传输失败");
			}
		}

		m_bTransmitting.store(false);
		});

	m_reliableChannel->SetFileReceivedCallback([this](const std::string& filename, const std::vector<uint8_t>& data) {
		// 文件接收完成回调
		CString filenameW = CA2W(filename.c_str(), CP_UTF8);
		if (filename == "[数据传输]")
		{
			AppendLogWithDetails(L"可靠传输完成", data.size());
		}
		else
		{
			CString msg;
			msg.Format(L"接收到文件: %s", filenameW.GetString());
			AppendLogWithDetails(msg, data.size());
		}

		// 注释掉重复显示，避免数据被显示两次（数据已通过ChunkReceivedCallback实时显示）
		// DisplayReceivedData(data);
		});

	// 设置实时分片数据回调
	m_reliableChannel->SetChunkReceivedCallback([this](const std::vector<uint8_t>& chunk, size_t transferred, size_t total) {
		// 实时显示数据片段
		DisplayReceivedData(chunk);
		
		// 更新进度信息
		CString progressMsg;
		progressMsg.Format(L"实时接收: %zu/%zu 字节 (%.1f%%)", transferred, total, (transferred * 100.0) / total);
		AppendLog(progressMsg);
		});

	WriteDebugLog("[DEBUG] CPortMasterDlg::InitializeTransportObjects: 传输对象初始化完成");
}

void CPortMasterDlg::ConfigureTransportCallback()
{
	WriteDebugLog("[DEBUG] ConfigureTransportCallback: 开始配置Transport回调");
	
	if (!m_transport) {
		WriteDebugLog("[ERROR] ConfigureTransportCallback: Transport未初始化");
		return;
	}
	
	// 根据当前传输模式设置回调
	if (m_bReliableMode) {
		// 可靠传输模式：确保ReliableChannel的回调被正确设置
		if (m_reliableChannel) {
			// 重新配置ReliableChannel的Transport回调，防止被直接传输模式覆盖
			m_reliableChannel->ReconfigureTransportCallback();
			WriteDebugLog("[DEBUG] ConfigureTransportCallback: 可靠传输模式 - ReliableChannel回调已重新配置");
		} else {
			WriteDebugLog("[ERROR] ConfigureTransportCallback: ReliableChannel未初始化");
		}
	} else {
		// 直接传输模式：设置直接传输回调
		WriteDebugLog("[DEBUG] ConfigureTransportCallback: 配置直接传输模式回调");
		m_transport->SetDataReceivedCallback(m_directTransportCallback);
	}
	
	WriteDebugLog("[DEBUG] ConfigureTransportCallback: Transport回调配置完成");
}

void CPortMasterDlg::UpdatePortList()
{
	m_ctrlPortList.ResetContent();

	int portType = m_ctrlPortType.GetCurSel();
	switch (portType)
	{
	case 0: // 串口
		// 枚举串口 - 简单示例
		for (int i = 1; i <= 16; i++)
		{
			CString portName;
			portName.Format(L"COM%d", i);
			m_ctrlPortList.AddString(portName);
		}
		break;
	case 1: // 并口
		m_ctrlPortList.AddString(L"LPT1");
		m_ctrlPortList.AddString(L"LPT2");
		break;
	case 2: // USB打印机
		m_ctrlPortList.AddString(L"USB打印机1");
		break;
	case 3: // TCP客户端
		m_ctrlPortList.AddString(L"127.0.0.1:8080");
		break;
	case 4: // TCP服务端
		m_ctrlPortList.AddString(L"监听端口:8080");
		break;
	case 5: // UDP
		m_ctrlPortList.AddString(L"UDP:8080");
		break;
	case 6: // 本地回环
		m_ctrlPortList.AddString(L"本地回环");
		break;
	}

	if (m_ctrlPortList.GetCount() > 0)
		m_ctrlPortList.SetCurSel(0);
}

void CPortMasterDlg::UpdateButtonStates()
{
	// 添加控件句柄安全检查
	if (!IsWindow(m_ctrlConnectBtn.GetSafeHwnd()) || !IsWindow(m_ctrlDisconnectBtn.GetSafeHwnd()))
	{
		WriteDebugLog("[WARNING] UpdateButtonStates: 控件句柄未初始化，跳过更新");
		return;
	}

	// 更新在DoDataExchange中实际绑定的控件
	m_ctrlConnectBtn.EnableWindow(!m_bConnected);
	m_ctrlDisconnectBtn.EnableWindow(m_bConnected);

	// 改进的发送按钮状态管理
	bool hasSendableData = HasValidInputData();
	if (IsWindow(m_ctrlSendBtn.GetSafeHwnd()))
	{
		bool enableSend = m_bConnected && !m_bTransmitting && hasSendableData;
		m_ctrlSendBtn.EnableWindow(enableSend);

		// 根据状态设置按钮文本和提示信息
		if (m_bTransmitting.load()) {
			m_ctrlSendBtn.SetWindowText(L"发送中...");
		} else {
			m_ctrlSendBtn.SetWindowText(L"发送");
		}
	}

	// 文件操作按钮状态管理
	if (IsWindow(m_ctrlLoadFileBtn.GetSafeHwnd()))
		m_ctrlLoadFileBtn.EnableWindow(!m_bTransmitting);
	
	// 数据操作按钮状态管理（基于显示数据是否存在，线程安全）
	bool hasDisplayData = false;
	{
		std::lock_guard<std::mutex> lock(m_displayDataMutex);
		hasDisplayData = !m_displayedData.empty();
	}
	if (IsWindow(m_ctrlSaveFileBtn.GetSafeHwnd()))
		m_ctrlSaveFileBtn.EnableWindow(hasDisplayData);
	if (IsWindow(m_ctrlCopyBtn.GetSafeHwnd()))
		m_ctrlCopyBtn.EnableWindow(hasDisplayData);

	// 清除按钮始终可用 - 使用实际绑定的控件
	if (IsWindow(m_ctrlClearInputBtn.GetSafeHwnd()))
		m_ctrlClearInputBtn.EnableWindow(TRUE);
	if (IsWindow(m_ctrlClearDisplayBtn.GetSafeHwnd()))
		m_ctrlClearDisplayBtn.EnableWindow(TRUE);

	// 更新连接状态显示（带状态指示器）
	if (IsWindow(m_ctrlConnectionStatus.GetSafeHwnd()))
	{
		CString statusText;
		if (m_bTransmitting.load())
			statusText = L"● 传输中";
		else if (m_bConnected)
			statusText = L"● 已连接";
		else
			statusText = L"○ 未连接";

		if (IsWindow(m_ctrlConnectionStatus.GetSafeHwnd()))
			m_ctrlConnectionStatus.SetWindowText(statusText);
	}

	// 更新协议状态显示
	if (m_reliableChannel)
	{
		ReliableState state = m_reliableChannel->GetState();
		CString stateText;
		switch (state)
		{
		case RELIABLE_IDLE: stateText = L"空闲"; break;
		case RELIABLE_STARTING: stateText = L"开始传输"; break;
		case RELIABLE_SENDING: stateText = L"传输中"; break;
		case RELIABLE_ENDING: stateText = L"结束传输"; break;
		case RELIABLE_RECEIVING: stateText = L"接收中"; break;
		case RELIABLE_DONE: stateText = L"完成"; break;
		case RELIABLE_FAILED: stateText = L"失败"; break;
		default: stateText = L"未知"; break;
		}
		if (IsWindow(m_ctrlProtocolStatus.GetSafeHwnd()))
			m_ctrlProtocolStatus.SetWindowText(stateText);
	}

	// 更新状态栏显示
	CString statusText;
	if (m_bTransmitting.load())
	{
		statusText = L"状态: 传输中";
	}
	else if (m_bConnected)
	{
		statusText = L"状态: 已连接";
		if (m_bReliableMode)
			statusText += L" (可靠模式)";
	}
	else
	{
		statusText = L"状态: 就绪";
	}
	m_ctrlStatus.SetWindowText(statusText);
}

void CPortMasterDlg::AppendLog(const CString& message)
{
	CString timeStamp;
	SYSTEMTIME st;
	GetLocalTime(&st);
	timeStamp.Format(L"[%02d:%02d:%02d.%03d] ", st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);

	CString log;
	m_ctrlLog.GetWindowText(log);
	log += timeStamp + message + L"\r\n";
	// 限制日志长度，防止控件文本过长
	if (log.GetLength() > 5000) {
		int cutPos = log.GetLength() - 4000;
		int newLinePos = log.Find(L'\n', cutPos);
		if (newLinePos != -1) {
			cutPos = newLinePos + 1;
		}
		log = log.Mid(cutPos);
		log = L"[...] " + log;
	}

	m_ctrlLog.SetWindowText(log);

	// CStatic 不支持滚动，因此移除 LineScroll 调用
	// m_ctrlLog.LineScroll(m_ctrlLog.GetLineCount());

	// 如果需要强制更新显示（虽然通常不需要），可以调用以下代码：
	// m_ctrlLog.Invalidate();
	// m_ctrlLog.UpdateWindow();
}

void CPortMasterDlg::AppendLogWithDetails(const CString& message, size_t bytes)
{
	CString detailedMessage = message;
	if (bytes > 0)
	{
		CString byteInfo;
		if (bytes >= AppConstants::BYTES_IN_MEGABYTE)
		{
			byteInfo.Format(L" (%.2f MB)", bytes * AppConstants::GetBytesToMegabytes());
		}
		else if (bytes >= 1024)
		{
			byteInfo.Format(L" (%.2f KB)", bytes * AppConstants::GetBytesToKilobytes());
		}
		else
		{
			byteInfo.Format(L" (%zu bytes)", bytes);
		}
		detailedMessage += byteInfo;
	}
	AppendLog(detailedMessage);
}

void CPortMasterDlg::UpdateTransferSpeed(size_t bytesTransferred)
{
	DWORD currentTime = GetTickCount();
	m_totalBytesTransmitted += bytesTransferred;

	// 每500ms更新一次速度显示
	if (currentTime - m_lastSpeedUpdateTime >= 500)
	{
		DWORD elapsedTime = currentTime - m_transmissionStartTime;
		if (elapsedTime > 0)
		{
			double speed = (m_totalBytesTransmitted * 1000.0) / elapsedTime;  // bytes/sec
			CString speedText;

			if (speed >= AppConstants::BYTES_IN_MEGABYTE)
			{
				speedText.Format(L"速度: %.2f MB/s", speed * AppConstants::GetBytesToMegabytes());
			}
			else if (speed >= 1024)
			{
				speedText.Format(L"速度: %.2f KB/s", speed * AppConstants::GetBytesToKilobytes());
			}
			else
			{
				speedText.Format(L"速度: %.0f B/s", speed);
			}

			if (IsWindow(m_ctrlTransferSpeed.GetSafeHwnd()))
			{
				m_ctrlTransferSpeed.SetWindowText(speedText);
			}

			// 估计剩余时间
			if (m_transmissionData.size() > m_transmissionProgress && speed > 0)
			{
				size_t remainingBytes = m_transmissionData.size() - m_transmissionProgress;
				double remainingSeconds = remainingBytes / speed;

				CString timeText;
				if (remainingSeconds >= 60)
				{
					timeText.Format(L"剩余: %.1f 分钟", remainingSeconds / 60.0);
				}
				else
				{
					timeText.Format(L"剩余: %.0f 秒", remainingSeconds);
				}

				// 剩余时间显示功能已移除（控件不存在）
			}

			m_lastSpeedUpdateTime = currentTime;
		}
	}

	// 更新传输进度显示
	if (IsWindow(m_ctrlTransferProgress.GetSafeHwnd()) && !m_transmissionData.empty())
	{
		CString progressText;
		progressText.Format(L"已传输: %zu/%zu", m_transmissionProgress, m_transmissionData.size());
		m_ctrlTransferProgress.SetWindowText(progressText);
	}
}

void CPortMasterDlg::AppendHexData(const BYTE* data, size_t length, bool incoming)
{
	const size_t BYTES_PER_LINE = AppConstants::BYTES_PER_LINE;
	CString prefix = incoming ? L"<< " : L">> ";

	CString currentHex;
	// 获取当前数据显示内容（根据显示模式）

	for (size_t i = 0; i < length; i += BYTES_PER_LINE)
	{
		CString hexLine;
		size_t lineLength = std::min(BYTES_PER_LINE, length - i);

		for (size_t j = 0; j < lineLength; j++)
		{
			CString temp;
			temp.Format(L"%02X ", data[i + j]);
			hexLine += temp;
		}

		currentHex += prefix + hexLine + L"\r\n";
	}

	// 在统一显示控件中显示十六进制数据
	if (m_bHexDisplay) {
		// 使用新的专业十六进制格式显示
		std::vector<uint8_t> tempData(data, data + length);
		DisplayReceivedData(tempData);
	}
}

void CPortMasterDlg::AppendTextData(const CString& text, bool incoming)
{
	CString prefix = incoming ? L"<< " : L">> ";

	// 在统一显示控件中显示文本数据
	if (!m_bHexDisplay) {
		// 使用智能文本格式显示
		CStringA utf8Text = CW2A(prefix + text + L"\r\n", CP_UTF8);
		std::vector<uint8_t> tempData(utf8Text.GetString(), utf8Text.GetString() + utf8Text.GetLength());
		DisplayReceivedData(tempData);
	}
}

// 按钮事件处理
void CPortMasterDlg::OnBnClickedConnect()
{
	// 获取当前选择的传输类型
	int transportIndex = m_ctrlPortType.GetCurSel();
	if (transportIndex == CB_ERR)
	{
		AppendLog(L"请选择传输类型");
		return;
	}

	// 读取当前选中的显示文本（仅用于兼容性判断/日志）
	CString transportType;
	m_ctrlPortType.GetLBText(transportIndex, transportType);

	// 兼容判断：
	// 1) 优先用索引判断（InitializeControls 中“本地回环”的索引是 6）
	// 2) 同时兼容文本为“本地回环”或“回环测试”，避免将来本地化或文本改名带来的问题
	if (transportIndex == 6 || transportType == L"本地回环" || transportType == L"回环测试")
	{
		// 确保传输层是回环类型
		if (!m_transport || m_transport->GetTransportType() != "Loopback")
		{
			m_transport = std::make_shared<LoopbackTransport>();
			m_reliableChannel = std::make_shared<ReliableChannel>(m_transport);

			// 重新设置进度回调（中文注释保留）
			m_reliableChannel->SetProgressCallback([this](const TransferStats& stats) {
				if (stats.totalBytes > 0)
				{
					int progress = static_cast<int>((stats.transferredBytes * 100) / stats.totalBytes);
					if (IsWindow(m_ctrlProgress.GetSafeHwnd())) {
						m_ctrlProgress.SetPos(progress);
					}

					CString statusText;
					statusText.Format(L"状态: 传输中 (%.1f%%, %zu/%zu 字节)",
						stats.GetProgress() * 100, stats.transferredBytes, stats.totalBytes);
					if (IsWindow(m_ctrlStatus.GetSafeHwnd())) {
						m_ctrlStatus.SetWindowText(statusText);
					}
				}
				});

			m_reliableChannel->SetCompletionCallback([this](bool success, const std::string& message) {
				CString msg = CA2W(message.c_str(), CP_UTF8);
				if (success)
				{
					AppendLog(L"传输完成: " + msg);
					if (IsWindow(m_ctrlStatus.GetSafeHwnd())) {
						m_ctrlStatus.SetWindowText(L"就绪");
					}

					// 显示传输的数据（从发送缓冲区）
					if (!m_transmissionData.empty()) {
						DisplayReceivedData(m_transmissionData);
					}
				}
				else
				{
					AppendLog(L"传输失败: " + msg);
				}
				m_bTransmitting.store(false);
				UpdateButtonStates();
				});

			m_reliableChannel->SetFileReceivedCallback([this](const std::string& filename, const std::vector<uint8_t>& data) {
				CString filenameW = CA2W(filename.c_str(), CP_UTF8);
				CString msg;
				if (filename == "[数据传输]")
				{
					msg.Format(L"可靠传输完成 (%zu 字节)", data.size());
				}
				else
				{
					msg.Format(L"接收到文件: %s (%zu 字节)", filenameW.GetString(), data.size());
				}
				AppendLog(msg);
				// 注释掉重复显示，避免数据被显示两次（数据已通过ChunkReceivedCallback实时显示）
				// DisplayReceivedData(data);
				});

			// 重新设置实时分片数据回调
			m_reliableChannel->SetChunkReceivedCallback([this](const std::vector<uint8_t>& chunk, size_t transferred, size_t total) {
				DisplayReceivedData(chunk);
				CString progressMsg;
				progressMsg.Format(L"实时接收: %zu/%zu 字节 (%.1f%%)", transferred, total, (transferred * 100.0) / total);
				AppendLog(progressMsg);
				});

			// 启用接收功能（回环/本地回环需要）
			m_reliableChannel->EnableReceiving(true);
		}
	}

	// 根据当前传输模式设置正确的Transport回调
	ConfigureTransportCallback();

	// 启动连接
	if (m_reliableChannel && m_reliableChannel->Start())
	{
		m_bConnected = true;
		UpdateButtonStates();

		// 显示详细的连接信息
		CString transportType2;
		m_ctrlPortType.GetLBText(m_ctrlPortType.GetCurSel(), transportType2);
		CString portName;
		m_ctrlPortList.GetLBText(m_ctrlPortList.GetCurSel(), portName);

		CString detailMsg;
		detailMsg.Format(L"连接成功 - %s: %s", transportType2, portName);
		AppendLog(detailMsg);

		// 更新连接状态显示
		if (IsWindow(m_ctrlConnectionStatus.GetSafeHwnd()))
		{
			m_ctrlConnectionStatus.SetWindowText(L"已连接");
		}
	}
	else
	{
		AppendLog(L"连接失败");
		CString error = CA2W(m_reliableChannel->GetLastError().c_str(), CP_UTF8);
		if (!error.IsEmpty())
		{
			AppendLog(L"错误: " + error);
		}

		// 更新连接状态显示
		if (IsWindow(m_ctrlConnectionStatus.GetSafeHwnd()))
		{
			m_ctrlConnectionStatus.SetWindowText(L"连接失败");
		}
	}
}

//void CPortMasterDlg::OnBnClickedConnect()
//{
//	// 获取当前选择的传输类型
//	int transportIndex = m_ctrlPortType.GetCurSel();
//	if (transportIndex == CB_ERR)
//	{
//		AppendLog(L"请选择传输类型");
//		return;
//	}
//
//	// 如果选择的是回环传输，确保使用正确的传输层
//	CString transportType;
//	m_ctrlPortType.GetLBText(transportIndex, transportType);
//
//	if (transportType == L"回环测试")
//	{
//		// 确保传输层是回环类型
//		if (!m_transport || m_transport->GetTransportType() != "Loopback")
//		{
//			m_transport = std::make_shared<LoopbackTransport>();
//			m_reliableChannel = std::make_shared<ReliableChannel>(m_transport);
//
//			// 重新设置回调
//			m_reliableChannel->SetProgressCallback([this](const TransferStats& stats) {
//				if (stats.totalBytes > 0)
//				{
//					int progress = static_cast<int>((stats.transferredBytes * 100) / stats.totalBytes);
//					if (IsWindow(m_ctrlProgress.GetSafeHwnd())) {
//						m_ctrlProgress.SetPos(progress);
//					}
//
//					CString statusText;
//					statusText.Format(L"状态: 传输中 (%.1f%%, %zu/%zu 字节)",
//						stats.GetProgress() * 100, stats.transferredBytes, stats.totalBytes);
//					if (IsWindow(m_ctrlStatus.GetSafeHwnd())) {
//						m_ctrlStatus.SetWindowText(statusText);
//					}
//				}
//			});
//
//			m_reliableChannel->SetCompletionCallback([this](bool success, const std::string& message) {
//				CString msg = CA2W(message.c_str(), CP_UTF8);
//				if (success)
//				{
//					AppendLog(L"传输完成: " + msg);
//					if (IsWindow(m_ctrlStatus.GetSafeHwnd())) {
//						m_ctrlStatus.SetWindowText(L"就绪");
//					}
//
//					// 显示传输的数据（从发送缓冲区）
//					if (!m_transmissionData.empty()) {
//						DisplayReceivedData(m_transmissionData);
//					}
//				}
//				else
//				{
//					AppendLog(L"传输失败: " + msg);
//				}
//				m_bTransmitting.store(false);
//				UpdateButtonStates();
//			});
//
//			m_reliableChannel->SetFileReceivedCallback([this](const std::string& filename, const std::vector<uint8_t>& data) {
//				CString filenameW = CA2W(filename.c_str(), CP_UTF8);
//				CString msg;
//				if (filename == "[数据传输]")
//				{
//					msg.Format(L"可靠传输完成 (%zu 字节)", data.size());
//				}
//				else
//				{
//					msg.Format(L"接收到文件: %s (%zu 字节)", filenameW.GetString(), data.size());
//				}
//				AppendLog(msg);
//				DisplayReceivedData(data);
//			});
//
//			// 启用接收功能（回环测试需要）
//			m_reliableChannel->EnableReceiving(true);
//		}
//	}
//
//	if (m_reliableChannel && m_reliableChannel->Start())
//	{
//		m_bConnected = true;
//		UpdateButtonStates();
//
//		// 显示详细的连接信息
//		CString transportType;
//		m_ctrlPortType.GetLBText(m_ctrlPortType.GetCurSel(), transportType);
//		CString portName;
//		m_ctrlPortList.GetLBText(m_ctrlPortList.GetCurSel(), portName);
//
//		CString detailMsg;
//		detailMsg.Format(L"连接成功 - %s: %s", transportType, portName);
//		AppendLog(detailMsg);
//
//		// 更新连接状态显示
//		if (IsWindow(m_ctrlConnectionStatus.GetSafeHwnd()))
//		{
//			m_ctrlConnectionStatus.SetWindowText(L"已连接");
//		}
//	}
//	else
//	{
//		AppendLog(L"连接失败");
//		CString error = CA2W(m_reliableChannel->GetLastError().c_str(), CP_UTF8);
//		if (!error.IsEmpty())
//		{
//			AppendLog(L"错误: " + error);
//		}
//
//		// 更新连接状态显示
//		if (IsWindow(m_ctrlConnectionStatus.GetSafeHwnd()))
//		{
//			m_ctrlConnectionStatus.SetWindowText(L"连接失败");
//		}
//	}
//}

void CPortMasterDlg::OnBnClickedDisconnect()
{
	if (m_reliableChannel)
	{
		m_reliableChannel->Stop();
	}

	m_bConnected = false;
	m_bTransmitting.store(false);
	UpdateButtonStates();
	AppendLog(L"已断开连接");

	// 更新状态显示
	if (IsWindow(m_ctrlConnectionStatus.GetSafeHwnd()))
	{
		m_ctrlConnectionStatus.SetWindowText(L"未连接");
	}
	if (IsWindow(m_ctrlProtocolStatus.GetSafeHwnd()))
	{
		m_ctrlProtocolStatus.SetWindowText(L"空闲");
	}
}

void CPortMasterDlg::OnBnClickedSend()
{
	WriteDebugLog("[DEBUG] OnBnClickedSend: 开始发送数据");
	
	// 检查基本前置条件
	if (!ValidateConnectionState()) {
		return;
	}
	
	if (m_bTransmitting.load()) {
		ShowUserMessage(L"传输忙碌", L"正在传输中，请等待完成后再发送新数据", MB_ICONINFORMATION);
		return;
	}
	
	// 获取发送数据和传输类型
	TransmissionData transmissionData;
	if (!PrepareTransmissionData(transmissionData)) {
		return;
	}
	
	// 执行传输
	if (m_bReliableMode) {
		ExecuteReliableTransmission(transmissionData);
	} else {
		ExecuteDirectTransmission(transmissionData);
	}
	
	WriteDebugLog("[DEBUG] OnBnClickedSend: 数据发送处理完成");
}

// TransmissionData 结构已移至头文件

// 新增：验证连接状态
bool CPortMasterDlg::ValidateConnectionState() {
	if (!m_bConnected) {
		ShowUserMessage(L"连接错误", L"请先连接端口才能发送数据", MB_ICONERROR);
		return false;
	}
	return true;
}

// 新增：准备传输数据
bool CPortMasterDlg::PrepareTransmissionData(TransmissionData& transmissionData) {
	if (!m_transmissionData.empty()) {
		// 文件传输优先
		transmissionData.data = m_transmissionData;
		transmissionData.isFileTransmission = true;
		transmissionData.displayName = m_currentFileName.IsEmpty() ? L"文件数据" : m_currentFileName;
		AppendLog(L"准备发送文件: " + transmissionData.displayName);
	} else {
		// 输入框数据
		transmissionData.data = GetInputData();
		transmissionData.isFileTransmission = false;
		transmissionData.displayName = L"输入数据";
		AppendLog(L"准备发送输入数据");
	}
	
	if (transmissionData.data.empty()) {
		ShowUserMessage(L"没有数据可发送", L"请在输入框中输入数据，或拖放文件", MB_ICONWARNING);
		return false;
	}
	
	return true;
}

// 新增：执行可靠传输
void CPortMasterDlg::ExecuteReliableTransmission(const TransmissionData& transmissionData) {
	if (!m_reliableChannel) {
		AppendLog(L"可靠传输通道未初始化");
		return;
	}
	
	m_bTransmitting.store(true);
	UpdateButtonStates(); // ★ 修复：立即更新按钮状态显示"发送中..."
	bool success = false;
	
	try {
		if (transmissionData.isFileTransmission) {
			std::string fileNameStr = CT2A(transmissionData.displayName);
			success = m_reliableChannel->SendFile(fileNameStr, transmissionData.data);
		} else {
			success = m_reliableChannel->SendData(transmissionData.data);
		}
		
		if (success) {
			AppendLog(L"开始可靠传输: " + transmissionData.displayName);
		} else {
			m_bTransmitting.store(false);
			UpdateButtonStates(); // ★ 修复：传输失败时恢复按钮状态
			HandleTransmissionError(L"可靠传输启动失败", m_reliableChannel->GetLastError());
		}
	} catch (...) {
		m_bTransmitting.store(false);
		UpdateButtonStates(); // ★ 修复：异常时恢复按钮状态
		AppendLog(L"可靠传输异常");
	}
}

// 新增：执行直接传输
void CPortMasterDlg::ExecuteDirectTransmission(const TransmissionData& transmissionData) {
	WriteDebugLog(("[DIRECT] 开始执行直接传输，数据大小: " + std::to_string(transmissionData.data.size())).c_str());
	
	if (!m_transport) {
		WriteDebugLog("[DIRECT] 错误: Transport 对象未初始化");
		AppendLog(L"错误：传输对象未初始化");
		return;
	}
	
	if (!m_transport->IsOpen()) {
		WriteDebugLog("[DIRECT] 警告: Transport 未打开，尝试打开");
		// 尝试打开连接
		TransportConfig config;  // 使用默认配置
		if (!m_transport->Open(config)) {
			WriteDebugLog("[DIRECT] 错误: 无法打开 Transport");
			AppendLog(L"错误：无法打开传输连接");
			return;
		}
		WriteDebugLog("[DIRECT] Transport 已成功打开");
	}
	
	try {
		WriteDebugLog("[DIRECT] 开始写入数据到 Transport");
		size_t written = m_transport->Write(transmissionData.data);
		WriteDebugLog(("[DIRECT] 写入操作完成，写入字节数: " + std::to_string(written)).c_str());
		
		if (written > 0) {
			AppendLogWithDetails(L"直接传输完成: " + transmissionData.displayName, written);
			HandleDirectTransmissionSuccess(transmissionData);
			WriteDebugLog("[DIRECT] 直接传输成功处理完成");
		} else {
			CString errorMsg = CA2W(m_transport->GetLastError().c_str());
			WriteDebugLog(("[DIRECT] 错误: 写入失败, " + std::string(CT2A(errorMsg))).c_str());
			HandleTransmissionError(L"直接传输失败", m_transport->GetLastError());
		}
	} catch (const std::exception& e) {
		WriteDebugLog(("[DIRECT] 异常: " + std::string(e.what())).c_str());
		AppendLog(CString(L"直接传输异常: ") + CA2W(e.what()));
	} catch (...) {
		WriteDebugLog("[DIRECT] 未知异常");
		AppendLog(L"直接传输未知异常");
	}
}

// 新增：处理直接传输成功
void CPortMasterDlg::HandleDirectTransmissionSuccess(const TransmissionData& transmissionData) {
	// 对于大文件，模拟分片传输进度反馈
	if (transmissionData.data.size() > 1024) {	// 大于1KB的数据
		SimulateChunkTransmission(transmissionData);
	}
	
	WriteDebugLog("[DIRECT] 直接传输成功，等待回调处理数据显示");
}

// 新增：模拟分片传输进度反馈
void CPortMasterDlg::SimulateChunkTransmission(const TransmissionData& transmissionData) {
	const size_t CHUNK_SIZE = 256;  // 256字节一个分片
	const size_t totalSize = transmissionData.data.size();
	const DWORD delay = 50; // 50ms模拟传输延迟
	
	WriteDebugLog(("[CHUNK] 开始模拟分片传输，总大小: " + std::to_string(totalSize)).c_str());
	
	// 启动分片传输定时器
	m_chunkTransmissionData = transmissionData.data;
	m_chunkTransmissionIndex = 0;
	m_chunkSize = CHUNK_SIZE;
	
	// 启动定时器
	SetTimer(AppConstants::TRANSMISSION_TIMER_ID + 1, delay, nullptr);
}

// 新增：分片传输定时器处理
void CPortMasterDlg::OnChunkTransmissionTimer() {
	if (m_chunkTransmissionIndex >= m_chunkTransmissionData.size()) {
		// 传输完成
		KillTimer(AppConstants::TRANSMISSION_TIMER_ID + 1);
		WriteDebugLog("[CHUNK] 分片传输模拟完成");
		return;
	}
	
	// 获取当前分片
	size_t remaining = m_chunkTransmissionData.size() - m_chunkTransmissionIndex;
	size_t currentChunkSize = std::min(m_chunkSize, remaining);
	
	std::vector<uint8_t> chunk(
		m_chunkTransmissionData.begin() + m_chunkTransmissionIndex,
		m_chunkTransmissionData.begin() + m_chunkTransmissionIndex + currentChunkSize
	);
	
	// 显示分片数据
	DisplayReceivedData(chunk);
	
	// 更新进度
	m_chunkTransmissionIndex += currentChunkSize;
	double progress = (static_cast<double>(m_chunkTransmissionIndex) / m_chunkTransmissionData.size()) * 100.0;
	
	CString progressMsg;
	progressMsg.Format(L"实时传输: %zu/%zu 字节 (%.1f%%)", 
		m_chunkTransmissionIndex, m_chunkTransmissionData.size(), progress);
	AppendLog(progressMsg);
	
	WriteDebugLog(("[CHUNK] 处理分片: " + std::to_string(currentChunkSize) + 
				 " 字节, 进度: " + std::to_string(progress) + "%").c_str());
}

// 新增：立即显示接收数据
void CPortMasterDlg::DisplayReceivedDataImmediate(const std::vector<uint8_t>& data, const CString& sourceName) {
	if (data.empty()) return;
	
	// 添加传输分隔符
	CString separator;
	separator.Format(L"\r\n--- 传输 #%d [%s] (%zu 字节) ---\r\n", 
					 m_transmissionCounter, sourceName, data.size());
	
	// 获取当前内容
	CString currentText;
	m_ctrlDataView.GetWindowText(currentText);
	
	// 追加分隔符
	currentText += separator;
	
	// 格式化数据内容
	if (m_bHexDisplay) {
		currentText += FormatHexDisplay(data);
	} else {
		currentText += FormatTextDisplay(data);
	}
	
	// 更新显示并滚动到底部
	m_ctrlDataView.SetWindowText(currentText);
	ScrollToBottom();
	
	// 更新累积数据
	m_displayedData.insert(m_displayedData.end(), data.begin(), data.end());
}

// 新增：处理传输错误
void CPortMasterDlg::HandleTransmissionError(const CString& operation, const std::string& error) {
	AppendLog(operation);
	if (!error.empty()) {
		CString errorW = CA2W(error.c_str(), CP_UTF8);
		AppendLog(L"错误详情: " + errorW);
	}
}

// 新增：格式化十六进制显示
// ★ 修复：优化十六进制显示格式化，增强错误处理和性能
CString CPortMasterDlg::FormatHexDisplay(const std::vector<uint8_t>& data) {
	// 空数据处理
	if (data.empty()) {
		return CString(L"[空数据]");
	}
	
	CString hexText;
	const size_t BYTES_PER_LINE = AppConstants::BYTES_PER_LINE;
	
	try {
		// 预分配内存以提高性能
		size_t estimatedSize = (data.size() / BYTES_PER_LINE + 1) * (8 + 3 * BYTES_PER_LINE + 3 + BYTES_PER_LINE + 3);
		hexText.Preallocate(static_cast<int>(estimatedSize));
		
		for (size_t i = 0; i < data.size(); i += BYTES_PER_LINE) {
			CString hexLine;
			size_t lineLength = std::min(BYTES_PER_LINE, data.size() - i);
			
			// 地址偏移（支持更大地址范围）
			hexLine.Format(L"%04X: ", static_cast<unsigned int>(i & 0xFFFF));
			
			// 十六进制数据
			for (size_t j = 0; j < lineLength; j++) {
				CString temp;
				temp.Format(L"%02X ", data[i + j]);
				hexLine += temp;
			}
			
			// 补齐对齐
			for (size_t j = lineLength; j < BYTES_PER_LINE; j++) {
				hexLine += L"   ";
			}
			
			// ASCII显示 - 增强字符范围处理
			hexLine += L" |";
			for (size_t j = 0; j < lineLength; j++) {
				uint8_t byte = data[i + j];
				// 扩展ASCII字符范围，更好地处理扩展字符
				if (byte >= 32 && byte <= 126) {
					// 标准可打印ASCII字符
					hexLine += static_cast<wchar_t>(byte);
				} else if (byte >= 128 && byte <= 255) {
					// 扩展ASCII字符，显示为点号
					hexLine += L'.';
				} else {
					// 控制字符和不可打印字符
					hexLine += L'.';
				}
			}
			
			// 补齐ASCII部分对齐
			for (size_t j = lineLength; j < BYTES_PER_LINE; j++) {
				hexLine += L' ';
			}
			
			hexLine += L"|\r\n";
			hexText += hexLine;
		}
		
		WriteDebugLog(("[DEBUG] FormatHexDisplay: 格式化完成，数据大小: " + std::to_string(data.size()) + " 字节").c_str());
		
	} catch (const std::exception& e) {
		WriteDebugLog(("[ERROR] FormatHexDisplay 异常: " + std::string(e.what())).c_str());
		return CString(L"[格式化错误]");
	} catch (...) {
		WriteDebugLog("[ERROR] FormatHexDisplay 未知异常");
		return CString(L"[格式化错误]");
	}
	
	return hexText;
}

// ★ 新增：简化的十六进制格式化（专用于复制）
CString CPortMasterDlg::FormatHexDisplaySimple(const std::vector<uint8_t>& data) {
	// 空数据处理
	if (data.empty()) {
		return CString(L"");
	}
	
	CString hexText;
	
	try {
		// 预分配内存：每字节3个字符（XX + 空格），最后去掉一个空格
		size_t estimatedSize = data.size() * 3;
		hexText.Preallocate(static_cast<int>(estimatedSize));
		
		// 生成纯十六进制字符串，用空格分隔
		for (size_t i = 0; i < data.size(); i++) {
			CString temp;
			temp.Format(L"%02X", data[i]);
			hexText += temp;
			
			// 除了最后一个字节，都要加空格
			if (i < data.size() - 1) {
				hexText += L" ";
			}
		}
		
		WriteDebugLog(("[DEBUG] FormatHexDisplaySimple: 简化格式化完成，数据大小: " + std::to_string(data.size()) + " 字节").c_str());
		
	} catch (const std::exception& e) {
		WriteDebugLog(("[ERROR] FormatHexDisplaySimple 异常: " + std::string(e.what())).c_str());
		return CString(L"");
	} catch (...) {
		WriteDebugLog("[ERROR] FormatHexDisplaySimple 未知异常");
		return CString(L"");
	}
	
	return hexText;
}

// ★★★ 彻底修复：强化中文编码处理，解决乱码问题 ★★★
CString CPortMasterDlg::FormatTextDisplay(const std::vector<uint8_t>& data) {
	if (data.empty()) {
		return CString(L"");
	}
	
	CString textDisplay;
	
	// 方案1: 直接尝试MultiByteToWideChar进行UTF-8转换
	try {
		int wideLen = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, 
			reinterpret_cast<const char*>(data.data()), static_cast<int>(data.size()), 
			nullptr, 0);
			
		if (wideLen > 0) {
			std::vector<wchar_t> wideBuffer(wideLen + 1);
			int converted = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS,
				reinterpret_cast<const char*>(data.data()), static_cast<int>(data.size()),
				wideBuffer.data(), wideLen);
				
			if (converted > 0) {
				wideBuffer[converted] = L'\0';
				textDisplay = wideBuffer.data();
				
				// 验证转换结果：检查是否有有效的中文字符
				bool hasValidChars = false;
				for (int i = 0; i < textDisplay.GetLength(); i++) {
					wchar_t wc = textDisplay[i];
					if ((wc >= 0x4E00 && wc <= 0x9FFF) || // 中文字符范围
						(wc >= 32 && wc <= 126) ||        // ASCII可打印字符
						wc == L'\r' || wc == L'\n' || wc == L'\t') {
						hasValidChars = true;
						break;
					}
				}
				
				if (hasValidChars) {
					return textDisplay;
				}
			}
		}
	} catch (...) {
		// UTF-8转换失败
	}
	
	// 方案2: 尝试GBK/ANSI编码
	try {
		int wideLen = MultiByteToWideChar(CP_ACP, 0,
			reinterpret_cast<const char*>(data.data()), static_cast<int>(data.size()),
			nullptr, 0);
			
		if (wideLen > 0) {
			std::vector<wchar_t> wideBuffer(wideLen + 1);
			int converted = MultiByteToWideChar(CP_ACP, 0,
				reinterpret_cast<const char*>(data.data()), static_cast<int>(data.size()),
				wideBuffer.data(), wideLen);
				
			if (converted > 0) {
				wideBuffer[converted] = L'\0';
				textDisplay = wideBuffer.data();
				
				// 检查GBK转换结果
				bool hasValidChars = false;
				for (int i = 0; i < textDisplay.GetLength(); i++) {
					wchar_t wc = textDisplay[i];
					if ((wc >= 0x4E00 && wc <= 0x9FFF) || // 中文字符
						(wc >= 32 && wc <= 126) ||        // ASCII
						wc == L'\r' || wc == L'\n' || wc == L'\t') {
						hasValidChars = true;
						break;
					}
				}
				
				if (hasValidChars) {
					return textDisplay;
				}
			}
		}
	} catch (...) {
		// GBK转换失败
	}
	
	// 方案3: 逐字节安全处理（避免产生特殊符号）
	textDisplay.Empty();
	for (size_t i = 0; i < data.size(); i++) {
		uint8_t byte = data[i];
		
		if (byte >= 32 && byte <= 126) {
			// ASCII可打印字符
			textDisplay += static_cast<wchar_t>(byte);
		} else if (byte == '\r') {
			textDisplay += L'\r';
		} else if (byte == '\n') {
			textDisplay += L'\n';
		} else if (byte == '\t') {
			textDisplay += L'\t';
		} else if (byte >= 0xA1 && byte <= 0xFE && i + 1 < data.size()) {
			// GBK双字节字符处理（更严格的范围检查）
			uint8_t nextByte = data[i + 1];
			if ((nextByte >= 0xA1 && nextByte <= 0xFE) || (nextByte >= 0x40 && nextByte <= 0x7E)) {
				// 尝试转换GBK字符对
				char mbBytes[3] = { static_cast<char>(byte), static_cast<char>(nextByte), 0 };
				int wideLen = MultiByteToWideChar(CP_ACP, 0, mbBytes, 2, nullptr, 0);
				if (wideLen == 1) {
					wchar_t wideChar;
					if (MultiByteToWideChar(CP_ACP, 0, mbBytes, 2, &wideChar, 1) == 1) {
						// 检查是否是有效的中文字符
						if (wideChar >= 0x4E00 && wideChar <= 0x9FFF) {
							textDisplay += wideChar;
							i++; // 跳过下一个字节
							continue;
						}
					}
				}
			}
			// 如果不是有效双字节字符，显示为转义形式
			textDisplay.AppendFormat(L"[%02X]", byte);
		} else {
			// 其他字节显示为十六进制转义（避免特殊符号显示）
			textDisplay.AppendFormat(L"[%02X]", byte);
		}
	}
	
	return textDisplay;
}

// 新增：滚动到底部
void CPortMasterDlg::ScrollToBottom() {
	if (::IsWindow(m_ctrlDataView.m_hWnd)) {
		int lineCount = m_ctrlDataView.GetLineCount();
		m_ctrlDataView.LineScroll(lineCount);
	}
}

// ★ 增强清除功能：同时重置累积数据和显示
void CPortMasterDlg::OnBnClickedClear()
{
	// 清除显示区域
	m_ctrlDataView.SetWindowText(L"");
	
	// ★ 新增：清除累积数据和重置计数器
	{
		std::lock_guard<std::mutex> lock(m_displayDataMutex);
		m_displayedData.clear(); // 清除累积的原始数据
		m_transmissionCounter = 0; // 重置传输计数器
		WriteDebugLog("[CLEAR] 累积数据已清除，传输计数器已重置");
	}
	
	// 更新按钮状态
	UpdateButtonStates();
	
	AppendLog(L"显示区域和累积数据已完全清空");
}

void CPortMasterDlg::OnCbnSelchangePortType()
{
	UpdatePortList();
	AppendLog(L"切换端口类型");
}

void CPortMasterDlg::OnBnClickedReliableMode()
{
	m_bReliableMode = (m_ctrlReliableMode.GetCheck() == BST_CHECKED);
	UpdateButtonStates();
	AppendLog(m_bReliableMode ? L"启用可靠传输模式" : L"禁用可靠传输模式");
	
	// 如果已连接，重新配置Transport回调
	if (m_bConnected) {
		ConfigureTransportCallback();
	}
}

void CPortMasterDlg::OnDropFiles(HDROP hDropInfo)
{
	WriteDebugLog("[DEBUG] OnDropFiles: 接收到文件拖放事件");

	try
	{
		UINT fileCount = DragQueryFile(hDropInfo, 0xFFFFFFFF, NULL, 0);

		if (fileCount == 0)
		{
			ShowUserMessage(L"拖放失败", L"未检测到有效文件", MB_ICONWARNING);
			WriteDebugLog("[WARNING] OnDropFiles: 未检测到有效文件");
			return;
		}

		// 多文件拖放处理
		if (fileCount > 1)
		{
			CString message;
			message.Format(L"检测到 %u 个文件，只能处理第一个文件。\n请一次只拖放一个文件。", fileCount);
			ShowUserMessage(L"多文件拖放", message, MB_ICONINFORMATION);
		}

		// 处理第一个文件
		TCHAR filePath[MAX_PATH];
		UINT pathLength = DragQueryFile(hDropInfo, 0, filePath, MAX_PATH);

		if (pathLength == 0)
		{
			ShowUserMessage(L"拖放错误", L"无法获取文件路径", MB_ICONERROR);
			WriteDebugLog("[ERROR] OnDropFiles: DragQueryFile 返回路径长度为0");
			return;
		}

		// 显示拖放的文件路径
		CString fileName = PathFindFileName(filePath);
		CString message;
		message.Format(L"正在处理文件: %s", fileName);
		AppendLog(message);

		// 检查文件是否存在
		DWORD attributes = GetFileAttributes(filePath);
		if (attributes == INVALID_FILE_ATTRIBUTES)
		{
			message.Format(L"文件不存在或无法访问:\n%s", filePath);
			ShowUserMessage(L"文件访问错误", message, MB_ICONERROR);
			WriteDebugLog(CT2A(message));
			return;
		}

		// 检查是否为目录
		if (attributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			ShowUserMessage(L"目录拖放", L"暂不支持目录拖放，请选择具体文件进行传输", MB_ICONWARNING);
			WriteDebugLog("[INFO] OnDropFiles: 跳过目录拖放");
			return;
		}

		// 获取文件大小并显示
		HANDLE hFile = CreateFile(filePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			LARGE_INTEGER fileSize;
			if (GetFileSizeEx(hFile, &fileSize))
			{
				CString sizeMessage;
				if (fileSize.QuadPart < 1024)
					sizeMessage.Format(L"文件大小: %I64d 字节", fileSize.QuadPart);
				else if (fileSize.QuadPart < AppConstants::BYTES_IN_MEGABYTE)
					sizeMessage.Format(L"文件大小: %.2f KB", fileSize.QuadPart * AppConstants::GetBytesToKilobytes());
				else
					sizeMessage.Format(L"文件大小: %.2f MB", fileSize.QuadPart * AppConstants::GetBytesToMegabytes());

				AppendLog(sizeMessage);
				UpdateDataSourceDisplay(L"文件: " + fileName);
			}
			CloseHandle(hFile);
		}

		// 读取文件内容
		WriteDebugLog("[INFO] OnDropFiles: 开始加载文件内容");
		if (LoadFileForTransmission(filePath))
		{
			ShowUserMessage(L"文件加载成功",
				L"文件已加载并准备传输。\n可以在下方查看文件内容预览，\n点击发送按钮开始传输。",
				MB_ICONINFORMATION);

			// 更新按钮状态
			UpdateButtonStates();
			WriteDebugLog("[SUCCESS] OnDropFiles: 文件加载成功");
		}
		else
		{
			ShowUserMessage(L"文件加载失败", L"无法读取文件内容，请检查文件是否损坏或权限不足", MB_ICONERROR);
			WriteDebugLog("[ERROR] OnDropFiles: 文件加载失败");
		}
	}
	catch (...)
	{
		ShowUserMessage(L"拖放异常", L"文件拖放处理过程中发生异常", MB_ICONERROR);
		WriteDebugLog("[ERROR] OnDropFiles: 处理拖放文件时发生异常");
	}

	DragFinish(hDropInfo);
	CDialogEx::OnDropFiles(hDropInfo);
	WriteDebugLog("[DEBUG] OnDropFiles: 文件拖放事件处理完成");
}



// 设置固定窗口尺寸（基于640×427 DLU对话框单位）
void CPortMasterDlg::SetFixedWindowSize()
{
	try {
		// 获取当前对话框的基准尺寸（由资源文件定义的640×427 DLU）
		CRect dlgRect;
		GetWindowRect(&dlgRect);
		const int WINDOW_WIDTH = dlgRect.Width();
		const int WINDOW_HEIGHT = dlgRect.Height();
		
		// 获取屏幕工作区域以计算居中位置
		RECT workArea;
		int x = 100, y = 100;  // 默认位置
		
		if (SystemParametersInfo(SPI_GETWORKAREA, 0, &workArea, 0)) {
			int screenWidth = workArea.right - workArea.left;
			int screenHeight = workArea.bottom - workArea.top;
			
			// 确保窗口不超出屏幕边界
			if (screenWidth >= WINDOW_WIDTH && screenHeight >= WINDOW_HEIGHT) {
				// 计算居中位置
				x = workArea.left + (screenWidth - WINDOW_WIDTH) / 2;
				y = workArea.top + (screenHeight - WINDOW_HEIGHT) / 2;
			}
			else {
				// 屏幕太小时，将窗口置于左上角
				x = workArea.left + 10;
				y = workArea.top + 10;
				WriteDebugLog("[WARNING] SetFixedWindowSize: 屏幕尺寸小于窗口尺寸，使用左上角定位");
			}
		}
		
		// 设置窗口位置和大小
		SetWindowPos(NULL, x, y, WINDOW_WIDTH, WINDOW_HEIGHT, SWP_NOZORDER);
		
		CString debugMsg;
		debugMsg.Format(L"[DEBUG] SetFixedWindowSize: 窗口设置为 %dx%d, 位置 (%d,%d)", 
			WINDOW_WIDTH, WINDOW_HEIGHT, x, y);
		WriteDebugLog(CT2A(debugMsg));
	}
	catch (...) {
		WriteDebugLog("[ERROR] SetFixedWindowSize: 窗口大小设置异常");
		// 异常情况下使用资源文件定义的默认尺寸
		CRect defaultRect(0, 0, 640, 427);
		MapDialogRect(&defaultRect);
		SetWindowPos(NULL, 100, 100, defaultRect.Width(), defaultRect.Height(), SWP_NOZORDER);
	}
}

// 数据源状态显示
void CPortMasterDlg::UpdateDataSourceDisplay(const CString& source)
{
	// 更新数据源标签显示
	if (::IsWindow(m_ctrlDataSourceLabel.m_hWnd)) {
		CString displayText;
		if (source.IsEmpty()) {
			displayText = L"数据源：无";
		} else {
			displayText.Format(L"数据源：%s", source);
		}
		m_ctrlDataSourceLabel.SetWindowText(displayText);
	}
}

// 检查是否有有效输入数据
bool CPortMasterDlg::HasValidInputData()
{
	// 优先检查传输数据缓冲区（文件拖放数据）
	if (!m_transmissionData.empty()) {
		return true;
	}
	
	// 检查十六进制输入框的手动输入
	CString hexText;
	m_ctrlInputHex.GetWindowText(hexText);
	hexText.Trim();
	if (!hexText.IsEmpty()) {
		return ValidateHexInput(hexText);
	}
	
	return false;
}

// 按钮事件处理函数实现
void CPortMasterDlg::OnBnClickedClearInput()
{
	if (::IsWindow(m_ctrlInputHex.m_hWnd)) {
		m_ctrlInputHex.SetWindowText(L"");
	}
	AppendLog(L"输入数据已清空");
}

void CPortMasterDlg::OnBnClickedClearDisplay()
{
	// 清除统一数据显示控件
	if (::IsWindow(m_ctrlDataView.m_hWnd)) {
		m_ctrlDataView.SetWindowText(L"");
	}
	
	// 清除显示的数据缓冲区和重置计数器
	m_displayedData.clear();
	m_transmissionCounter = 0;
	UpdateDataSourceDisplay(L"");
	
	AppendLog(L"显示数据已清空，传输计数器已重置");
}

void CPortMasterDlg::OnBnClickedLoadFile()
{
	CFileDialog dlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, L"所有文件(*.*)|*.*||");
	if (dlg.DoModal() == IDOK) {
		CString filePath = dlg.GetPathName();
		if (LoadFileForTransmission(filePath)) {
			AppendLog(L"文件加载成功: " + filePath);
		} else {
			AppendLog(L"文件加载失败: " + filePath);
		}
	}
}

void CPortMasterDlg::OnBnClickedSaveFile()
{
	// 检查是否有数据可保存
	std::lock_guard<std::mutex> lock(m_displayDataMutex);
	if (m_displayedData.empty()) {
		ShowUserMessage(L"提示", L"没有可保存的数据", MB_ICONINFORMATION);
		return;
	}
	
	// 根据显示模式确定默认文件扩展名和过滤器
	CString defaultExt, filter, defaultName;
	if (m_bHexDisplay) {
		defaultExt = L"txt";
		filter = L"文本文件(*.txt)|*.txt|所有文件(*.*)|*.*||";
		defaultName = L"received_data_hex.txt";
	} else {
		// 对于文本数据，提供多种保存选项
		defaultExt = L"txt";  
		filter = L"文本文件(*.txt)|*.txt|二进制文件(*.bin)|*.bin|所有文件(*.*)|*.*||";
		defaultName = L"received_data.txt";
	}
	
	CFileDialog dlg(FALSE, defaultExt, defaultName, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, filter);
	if (dlg.DoModal() == IDOK) {
		CString filePath = dlg.GetPathName();
		
		try {
			// 获取文件扩展名以确定保存格式
			CString ext = dlg.GetFileExt().MakeLower();
			bool saveAsText = (ext == L"txt" || ext.IsEmpty());
			
			std::ofstream file;
			if (saveAsText) {
				// 保存为文本格式
				file.open(CT2A(filePath.GetString()), std::ios::out);
				if (file.is_open()) {
					if (m_bHexDisplay) {
						// 保存格式化的16进制文本
						CString hexText = FormatHexDisplay(m_displayedData);
						file << CT2A(hexText.GetString(), CP_UTF8);
					} else {
						// 保存格式化的文本数据
						CString textData = FormatTextDisplay(m_displayedData);
						file << CT2A(textData.GetString(), CP_UTF8);
					}
					file.close();
					
					CString msg;
					msg.Format(L"数据已保存为文本格式到: %s", filePath);
					AppendLog(msg);
				} else {
					AppendLog(L"保存失败: 无法创建文件 " + filePath);
				}
			} else {
				// 保存为二进制格式
				file.open(CT2A(filePath.GetString()), std::ios::out | std::ios::binary);
				if (file.is_open()) {
					file.write(reinterpret_cast<const char*>(m_displayedData.data()), m_displayedData.size());
					file.close();
					
					CString msg;
					msg.Format(L"数据已保存为二进制格式到: %s (%zu 字节)", filePath, m_displayedData.size());
					AppendLog(msg);
				} else {
					AppendLog(L"保存失败: 无法创建文件 " + filePath);
				}
			}
		} 
		catch (const std::exception& e) {
			CString errorMsg = CA2W(e.what(), CP_UTF8);
			AppendLog(L"保存文件时发生异常: " + errorMsg);
		}
		catch (...) {
			AppendLog(L"保存文件时发生未知异常");
		}
	}
}

// ★ 修复：优化复制功能，确保格式一致性和错误处理
void CPortMasterDlg::OnBnClickedCopy()
{
	try {
		// 检查是否有数据可复制
		std::lock_guard<std::mutex> lock(m_displayDataMutex);
		if (m_displayedData.empty()) {
			AppendLog(L"没有数据可复制");
			WriteDebugLog("[COPY] 无数据可复制");
			return;
		}

		// ★ 修复：改进复制功能的字符编码处理
		CString textToCopy;
		if (m_bHexDisplay) {
			// 十六进制模式：复制十六进制格式的文本
			WriteDebugLog(("[COPY] 准备复制十六进制数据，长度: " + std::to_string(m_displayedData.size()) + " 字节").c_str());
			
			// 使用专门的简化十六进制格式
			textToCopy = FormatHexDisplaySimple(m_displayedData);
		} else {
			// 文本模式：复制智能解码后的文本
			textToCopy = FormatTextDisplay(m_displayedData);
			// 移除末尾的换行符，避免粘贴时多余的换行
			textToCopy.TrimRight(L"\r\n");
			WriteDebugLog(("[COPY] 准备复制文本数据，长度: " + std::to_string(m_displayedData.size()) + " 字节").c_str());
		}
		
		// 验证结果
		if (textToCopy.IsEmpty() && !m_displayedData.empty()) {
			AppendLog(L"复制失败：数据转换后为空");
			WriteDebugLog("[COPY] 数据转换结果为空");
			return;
		}

		// 复制到剪切板
		if (OpenClipboard()) {
			EmptyClipboard();
			
			// 计算所需内存大小（Unicode字符 * 2字节 + 终止符）
			size_t textLength = static_cast<size_t>(textToCopy.GetLength());
			size_t dataSize = (textLength + 1) * sizeof(WCHAR);
			HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, dataSize);
			
			if (hMem != nullptr) {
				WCHAR* pMem = static_cast<WCHAR*>(GlobalLock(hMem));
				if (pMem != nullptr) {
					// 安全复制字符串
					wcscpy_s(pMem, textLength + 1, textToCopy.GetString());
					GlobalUnlock(hMem);
					
					// 设置剪切板数据
					if (SetClipboardData(CF_UNICODETEXT, hMem) != nullptr) {
						// 成功
						if (m_bHexDisplay) {
							AppendLog(L"十六进制数据已复制到剪切板");
							WriteDebugLog(("[COPY] 十六进制数据复制成功，字节长度: " + std::to_string(m_displayedData.size()) + ", 字符长度: " + std::to_string(textLength)).c_str());
						} else {
							AppendLog(L"文本数据已复制到剪切板（已智能识别中文编码）"); 
							WriteDebugLog(("[COPY] 智能解码文本复制成功，格式化长度: " + std::to_string(textLength) + " 字符").c_str());
						}
					} else {
						// 失败时释放内存
						GlobalFree(hMem);
						AppendLog(L"复制到剪切板失败");
						WriteDebugLog("[COPY] SetClipboardData 失败");
					}
				} else {
					GlobalFree(hMem);
					AppendLog(L"复制失败：内存锁定错误");
					WriteDebugLog("[COPY] GlobalLock 失败");
				}
			} else {
				AppendLog(L"复制失败：内存分配错误");
				WriteDebugLog("[COPY] GlobalAlloc 失败");
			}
			
			CloseClipboard();
		} else {
			AppendLog(L"复制失败：无法打开剪切板");
			WriteDebugLog("[COPY] OpenClipboard 失败");
		}
		
	} catch (const std::exception& e) {
		WriteDebugLog(("[COPY] 复制操作异常: " + std::string(e.what())).c_str());
		AppendLog(L"复制失败：发生异常");
	} catch (...) {
		WriteDebugLog("[COPY] 复制操作未知异常");
		AppendLog(L"复制失败：发生未知异常");
	}
}

void CPortMasterDlg::OnBnClickedHexDisplay()
{
	// 获取复选框状态
	bool newHexDisplayState = (m_ctrlHexDisplayCheck.GetCheck() == BST_CHECKED);
	
	// 检测状态是否真的发生了变化
	if (newHexDisplayState != m_bHexDisplay) {
		m_bHexDisplay = newHexDisplayState;
		
		// 更新显示格式
		RefreshDataDisplay();
		
		// 记录详细的切换信息
		if (m_bHexDisplay) {
			AppendLog(L"切换到十六进制显示模式 - 将显示原始二进制数据");
			WriteDebugLog("[UI] 十六进制显示模式已启用");
		} else {
			AppendLog(L"切换到文本显示模式 - 非打印字符将被过滤");
			WriteDebugLog("[UI] 文本显示模式已启用");
		}
	} else {
		// 状态未变化，记录调试信息
		WriteDebugLog("[UI] 显示模式状态未发生变化");
	}
}

void CPortMasterDlg::OnEnChangeInputHex()
{
	// 输入框内容变化时，实时更新按钮状态
	UpdateButtonStates();
}

void CPortMasterDlg::OnTimer(UINT_PTR nIDEvent)
{
	if (nIDEvent == m_transmissionTimer && ::IsWindow(GetSafeHwnd())) {
		// 传输定时器处理
		OnTransmissionTimer();
	}
	// 删除Timer 2001逻辑，直接传输现在使用立即显示机制
	else if (nIDEvent == AppConstants::TRANSMISSION_TIMER_ID + 1 && ::IsWindow(GetSafeHwnd())) {
		// 分片传输模拟定时器
		OnChunkTransmissionTimer();
	}
	else if (nIDEvent == 3001 && ::IsWindow(GetSafeHwnd())) {
		// 延迟重绘定时器，避免布局调整时的闪烁
		KillTimer(3001);
		Invalidate(FALSE);
		UpdateWindow();
	}
	CDialogEx::OnTimer(nIDEvent);
}

// 数据处理函数实现
bool CPortMasterDlg::ValidateHexInput(const CString& hexText)
{
	if (hexText.IsEmpty()) return false;
	
	for (int i = 0; i < hexText.GetLength(); i++) {
		wchar_t ch = hexText.GetAt(i);
		if (!((ch >= L'0' && ch <= L'9') || 
			  (ch >= L'A' && ch <= L'F') || 
			  (ch >= L'a' && ch <= L'f') ||
			  ch == L' ' || ch == L'\t' || ch == L'\r' || ch == L'\n')) {
			return false;
		}
	}
	return true;
}

std::vector<uint8_t> CPortMasterDlg::GetInputData()
{
	std::vector<uint8_t> data;
	
	// 优先级1: 文件拖放数据
	if (!m_transmissionData.empty()) {
		data = m_transmissionData;
		UpdateDataSourceDisplay(L"文件: " + m_currentFileName);
		return data;
	}
	
	// 优先级2: 统一输入框的手动输入
	CString inputText;
	if (::IsWindow(m_ctrlInputHex.m_hWnd)) {
		m_ctrlInputHex.GetWindowText(inputText);
		inputText.Trim();
		
		if (!inputText.IsEmpty()) {
			// 根据用户的十六进制显示设置处理输入
			if (m_bHexDisplay) {
				// 用户选择了十六进制模式
				if (IsHexFormatInput(inputText)) {
					data = ProcessHexInput(inputText);
					UpdateDataSourceDisplay(L"十六进制输入");
				} else {
					// 十六进制模式但输入格式无效
					ShowUserMessage(L"输入错误", L"十六进制模式下请输入有效的十六进制数据（如：12 34 56 或 123456）", MB_ICONWARNING);
					return data; // 返回空数据
				}
			} else {
				// 用户选择文本模式，一律按文本处理
				data = ProcessTextInput(inputText);
				UpdateDataSourceDisplay(L"文本输入");
			}
		}
	}
	
	return data;
}

// 检测输入是否为十六进制格式
bool CPortMasterDlg::IsHexFormatInput(const CString& input)
{
	CString cleanInput = input;
	cleanInput.Remove(L' ');
	cleanInput.Remove(L'\t');
	cleanInput.Remove(L'\r');
	cleanInput.Remove(L'\n');
	cleanInput.Remove(L'-');
	cleanInput.Remove(L':');
	
	// 如果长度为偶数且全部为十六进制字符，则认为是十六进制
	if (cleanInput.GetLength() % 2 == 0 && cleanInput.GetLength() > 0) {
		for (int i = 0; i < cleanInput.GetLength(); i++) {
			wchar_t c = cleanInput.GetAt(i);
			if (!((c >= L'0' && c <= L'9') || 
				  (c >= L'A' && c <= L'F') || 
				  (c >= L'a' && c <= L'f'))) {
				return false;
			}
		}
		return true;
	}
	return false;
}

// 处理十六进制输入
std::vector<uint8_t> CPortMasterDlg::ProcessHexInput(const CString& hexInput)
{
	std::vector<uint8_t> data;
	CString cleanHex = hexInput;
	
	// 清理格式字符
	cleanHex.Remove(L' ');
	cleanHex.Remove(L'\t');
	cleanHex.Remove(L'\r');
	cleanHex.Remove(L'\n');
	cleanHex.Remove(L'-');
	cleanHex.Remove(L':');
	cleanHex.MakeUpper();
	
	// 转换为字节数组
	for (int i = 0; i < cleanHex.GetLength(); i += 2) {
		if (i + 1 < cleanHex.GetLength()) {
			CString hexByte = cleanHex.Mid(i, 2);
			data.push_back((uint8_t)wcstoul(hexByte, NULL, 16));
		}
	}
	
	return data;
}

// 处理文本输入
std::vector<uint8_t> CPortMasterDlg::ProcessTextInput(const CString& textInput)
{
	std::vector<uint8_t> data;
	
	// 转换为UTF-8字节数组
	CStringA utf8Text = CW2A(textInput, CP_UTF8);
	data.reserve(utf8Text.GetLength());
	
	for (int i = 0; i < utf8Text.GetLength(); i++) {
		data.push_back((uint8_t)utf8Text.GetAt(i));
	}
	
	return data;
}

void CPortMasterDlg::DisplayReceivedData(const std::vector<uint8_t>& data)
{
	if (data.empty() || !::IsWindow(m_ctrlDataView.m_hWnd)) {
		return;
	}
	
	// ★ 修复：统一使用原始数据，让FormatTextDisplay智能处理字符编码
	// 无论是十六进制还是文本模式，都保持原始数据完整性
	std::vector<uint8_t> processedData = data;
	
	if (m_bHexDisplay) {
		WriteDebugLog(("[DEBUG] DisplayReceivedData: 十六进制模式，保持原始数据，大小: " + std::to_string(data.size())).c_str());
	} else {
		WriteDebugLog(("[DEBUG] DisplayReceivedData: 文本模式，使用智能编码检测处理原始数据，大小: " + std::to_string(data.size())).c_str());
	}
	
	// 线程安全：在UI线程中执行
	if (GetCurrentThreadId() != GetWindowThreadProcessId(m_hWnd, nullptr)) {
		// 从非UI线程调用，需要切换到UI线程，传递处理后的数据
		// ★ 修复：避免在非UI线程进行数据累积，由OnDisplayReceivedData统一处理
		PostMessage(WM_USER + 1001, reinterpret_cast<WPARAM>(new std::vector<uint8_t>(processedData)), 0);
		WriteDebugLog("[DEBUG] DisplayReceivedData: 跨线程调用，转发到UI线程处理");
		return;
	}
	
	try {
		// ★ 修复：只在UI线程中进行数据累积，避免双重累积
		// 更新累积数据（线程安全，使用处理后的数据）
		{
			std::lock_guard<std::mutex> lock(m_displayDataMutex);
			size_t oldSize = m_displayedData.size();
			m_displayedData.reserve(oldSize + processedData.size());
			m_displayedData.insert(m_displayedData.end(), processedData.begin(), processedData.end());
			WriteDebugLog(("[DEBUG] DisplayReceivedData: UI线程数据累积，原大小: " + std::to_string(oldSize) + ", 新增: " + std::to_string(processedData.size())).c_str());
		}
		
		// 使用高效的追加模式显示（使用处理后数据）
		DisplayDataAppendMode(processedData);
		
		// 记录显示信息（简化版）
		WriteDebugLog(("[DATA] 数据显示完成，处理后数据长度: " + std::to_string(processedData.size())).c_str());
		
		// 更新按钮状态，使复制和保存按钮可用
		UpdateButtonStates();
		
	} catch (const std::exception& e) {
		WriteDebugLog(("[ERROR] DisplayReceivedData 异常: " + std::string(e.what())).c_str());
	} catch (...) {
		WriteDebugLog("[ERROR] DisplayReceivedData 未知异常");
	}
}

// 新增：高效的追加模式显示
void CPortMasterDlg::DisplayDataAppendMode(const std::vector<uint8_t>& data) {
	// 增加传输计数器
	m_transmissionCounter++;
	
	// 创建分隔符
	CString separator;
	separator.Format(L"\r\n--- 接收数据 #%d (%zu 字节) ---\r\n", 
					m_transmissionCounter, data.size());
	
	// 格式化数据内容
	CString formattedData;
	if (m_bHexDisplay) {
		formattedData = FormatHexDisplay(data);
	} else {
		formattedData = FormatTextDisplay(data);
	}
	
	// 一次性追加所有内容（避免多次GetWindowText调用）
	int textLength = m_ctrlDataView.GetWindowTextLength();
	m_ctrlDataView.SetSel(textLength, textLength); // 移动到末尾
	m_ctrlDataView.ReplaceSel(separator + formattedData);
	
	// 滚动到底部
	ScrollToBottom();
}

// 新增：线程安全的数据显示消息处理
// ★ 修复：跨线程数据显示处理器 - 负责处理来自非UI线程的数据累积和显示
LRESULT CPortMasterDlg::OnDisplayReceivedData(WPARAM wParam, LPARAM lParam) {
	std::vector<uint8_t>* pData = reinterpret_cast<std::vector<uint8_t>*>(wParam);
	if (pData) {
		try {
			// ★ 修复：在UI线程中进行唯一的数据累积，避免双重累积
			{
				std::lock_guard<std::mutex> lock(m_displayDataMutex);
				size_t oldSize = m_displayedData.size();
				m_displayedData.reserve(oldSize + pData->size());
				m_displayedData.insert(m_displayedData.end(), pData->begin(), pData->end());
				WriteDebugLog(("[DEBUG] OnDisplayReceivedData: 跨线程数据累积，原大小: " + std::to_string(oldSize) + ", 新增: " + std::to_string(pData->size())).c_str());
			}
			
			// 显示数据（不再进行累积）
			DisplayDataAppendMode(*pData);
			
			// 更新按钮状态
			UpdateButtonStates();
			WriteDebugLog("[THREAD] 跨线程数据显示完成，按钮状态已更新");
		} catch (const std::exception& e) {
			WriteDebugLog(("[ERROR] 跨线程数据显示异常: " + std::string(e.what())).c_str());
		} catch (...) {
			WriteDebugLog("[ERROR] 跨线程数据显示未知异常");
		}
		delete pData; // 清理内存
	}
	return 0;
}

bool CPortMasterDlg::LoadFileForTransmission(const CString& filePath)
{
	try {
		CFile file(filePath, CFile::modeRead | CFile::typeBinary);
		ULONGLONG fileSize = file.GetLength();
		
		if (fileSize > AppConstants::MAX_FILE_SIZE) {
			ShowUserMessage(L"错误", L"文件过大，请选择小于1MB的文件", MB_ICONERROR);
			return false;
		}
		
		m_transmissionData.resize((size_t)fileSize);
		file.Read(m_transmissionData.data(), (UINT)fileSize);
		file.Close();
		
		// 更新文件名
		int pos = filePath.ReverseFind(L'\\');
		if (pos >= 0) {
			m_currentFileName = filePath.Mid(pos + 1);
		} else {
			m_currentFileName = filePath;
		}
		
		UpdateDataSourceDisplay(L"文件: " + m_currentFileName);
		
		// ★ 修复：根据当前显示模式在输入框显示文件内容，智能处理中文字符
		if (::IsWindow(m_ctrlInputHex.m_hWnd)) {
			CString finalDisplayText;
			
			if (m_bHexDisplay) {
				// 十六进制模式：显示为格式化的十六进制
				CStringA hexContent;
				for (size_t i = 0; i < m_transmissionData.size() && i < 4096; ++i) {
					CStringA hex;
					hex.Format("%02X ", m_transmissionData[i]);
					hexContent += hex;
					
					// 每16个字节换行，提高可读性
					if ((i + 1) % 16 == 0) {
						hexContent += "\r\n";
					}
				}
				
				// 如果文件大于4KB，添加提示信息
				if (m_transmissionData.size() > 4096) {
					CStringA truncMsg;
					truncMsg.Format("\r\n[... 文件总共 %zu 字节，仅显示前4096字节 ...]", m_transmissionData.size());
					hexContent += truncMsg;
				}
				
				// 转换为Unicode字符串
				finalDisplayText = CA2W(hexContent, CP_ACP);
				
			} else {
				// 文本模式：智能处理中文字符
				// 创建原始数据的子集（前4KB）
				size_t displaySize = std::min(m_transmissionData.size(), static_cast<size_t>(4096));
				CStringA rawText(reinterpret_cast<const char*>(m_transmissionData.data()), static_cast<int>(displaySize));
				
				// 尝试UTF-8解码
				finalDisplayText = CA2W(rawText, CP_UTF8);
				
				// 检查UTF-8转换是否成功（查找替换字符或空结果）
				bool utf8Success = !finalDisplayText.IsEmpty() && 
					finalDisplayText.Find(L'\xFFFD') == -1;  // Unicode替换字符
					
				// 如果UTF-8失败，尝试系统默认编码（通常是GBK）
				if (!utf8Success) {
					finalDisplayText = CA2W(rawText, CP_ACP);
					
					// 如果系统编码也失败，使用逐字节智能处理
					if (finalDisplayText.IsEmpty() || finalDisplayText.Find(L'?') != -1) {
						finalDisplayText.Empty();
						for (size_t i = 0; i < displaySize; ++i) {
							uint8_t byte = m_transmissionData[i];
							if (byte >= 32 && byte <= 126) {
								// ASCII可打印字符
								finalDisplayText += static_cast<wchar_t>(byte);
							} else if (byte == '\r' || byte == '\n' || byte == '\t') {
								// 保留常见控制字符
								finalDisplayText += static_cast<wchar_t>(byte);
							} else if (byte >= 0x80 && i + 1 < displaySize) {
								// 尝试双字节字符（GBK）
								uint8_t nextByte = m_transmissionData[i + 1];
								char mbBytes[3] = { static_cast<char>(byte), static_cast<char>(nextByte), 0 };
								CString mbChar = CA2W(mbBytes, CP_ACP);
								if (!mbChar.IsEmpty() && mbChar != L"?" && mbChar.GetLength() == 1) {
									finalDisplayText += mbChar;
									i++; // 跳过下一个字节
								} else {
									// 无效字符，显示为转义序列
									finalDisplayText.AppendFormat(L"\\x%02X", byte);
								}
							} else {
								// 其他控制字符，显示为转义序列
								finalDisplayText.AppendFormat(L"\\x%02X", byte);
							}
						}
					}
				}
				
				// 如果文件大于4KB，添加提示信息
				if (m_transmissionData.size() > 4096) {
					finalDisplayText.AppendFormat(L"\r\n[... 文件总共 %zu 字节，仅显示前4096字节 ...]", m_transmissionData.size());
				}
			}
			
			// 统一设置显示内容
			m_ctrlInputHex.SetWindowText(finalDisplayText);
		}
		
		// 更新按钮状态以反映可发送状态
		UpdateButtonStates();
		
		return true;
	}
	catch (CFileException* e) {
		e->Delete();
		ShowUserMessage(L"错误", L"文件读取失败", MB_ICONERROR);
		return false;
	}
}

// 数据传输函数实现
void CPortMasterDlg::StartDataTransmission(const std::vector<uint8_t>& data)
{
	if (data.empty()) {
		ShowUserMessage(L"错误", L"没有要传输的数据", MB_ICONWARNING);
		return;
	}
	
	if (!m_bConnected) {
		ShowUserMessage(L"错误", L"请先连接端口", MB_ICONWARNING);
		return;
	}
	
	// 简单的传输实现
	m_bTransmitting.store(true);
	m_transmissionProgress = 0;
	m_transmissionStartTime = GetTickCount();
	m_totalBytesTransmitted = 0;
	
	AppendLogWithDetails(L"开始数据传输", data.size());
	UpdateButtonStates();
	
	// 启动传输定时器
	m_transmissionTimer = SetTimer(AppConstants::TRANSMISSION_TIMER_ID, AppConstants::TRANSMISSION_TIMER_INTERVAL, NULL);
}

void CPortMasterDlg::OnTransmissionTimer()
{
	if (!m_bTransmitting.load() || m_transmissionTimer == 0) {
		return;
	}
	
	// 模拟传输进度
	m_transmissionProgress += 1024; // 每次1KB
	m_totalBytesTransmitted = m_transmissionProgress;
	
	// 计算传输速度
	DWORD currentTime = GetTickCount();
	if (currentTime > m_transmissionStartTime) {
		DWORD elapsedTime = currentTime - m_transmissionStartTime;
		size_t speed = (m_totalBytesTransmitted * 1000) / elapsedTime; // 字节/秒
		
		CString speedText;
		if (speed >= 1024) {
			speedText.Format(L"%.1f KB/s", (double)speed / 1024.0);
		} else {
			speedText.Format(L"%zu B/s", speed);
		}
		
		if (::IsWindow(m_ctrlTransferSpeed.m_hWnd)) {
			m_ctrlTransferSpeed.SetWindowText(speedText);
		}
	}
	
	// 检查是否传输完成
	if (m_transmissionProgress >= m_transmissionData.size()) {
		// 传输完成
		m_bTransmitting.store(false);
		KillTimer(m_transmissionTimer);
		m_transmissionTimer = 0;
		
		AppendLog(L"数据传输完成");
		UpdateButtonStates();
		
		// 重置传输状态
		m_transmissionProgress = 0;
		if (::IsWindow(m_ctrlTransferSpeed.m_hWnd)) {
			m_ctrlTransferSpeed.SetWindowText(L"0 B/s");
		}
	}
}

// ★ 全新设计：简化的显示格式控制
void CPortMasterDlg::RefreshDataDisplay()
{
	// ★ 新策略：切换显示模式时不重新处理历史数据
	// 只影响后续新接收的数据的显示格式
	
	CString currentText;
	m_ctrlDataView.GetWindowText(currentText);
	
	if (currentText.IsEmpty()) {
		return; // 没有显示内容，直接返回
	}
	
	// 在状态栏显示切换提示和用户选项
	if (m_bHexDisplay) {
		AppendLog(L"已切换到十六进制显示 - 新数据将以十六进制格式显示");
		AppendLog(L"提示：如需重新格式化历史数据，请点击'清除'按钮清空显示区域");
		WriteDebugLog("[UI] 切换到十六进制模式，保留现有显示内容");
	} else {
		AppendLog(L"已切换到文本显示 - 新数据将以文本格式显示"); 
		AppendLog(L"提示：如需重新格式化历史数据，请点击'清除'按钮清空显示区域");
		WriteDebugLog("[UI] 切换到文本模式，保留现有显示内容");
	}
}

void CPortMasterDlg::SetDataDisplayFormat(bool hexMode)
{
	m_bHexDisplay = hexMode;
	m_ctrlHexDisplayCheck.SetCheck(hexMode ? BST_CHECKED : BST_UNCHECKED);
	RefreshDataDisplay();
}

// 用户反馈机制
void CPortMasterDlg::ShowUserMessage(const CString& title, const CString& message, UINT type)
{
	MessageBox(message, title, type);
	
	// 同时记录到日志
	CString logMsg;
	logMsg.Format(L"[用户提示] %s: %s", title, message);
	AppendLog(logMsg);
}

// ===== 响应式布局实现 =====

// OnSize 函数已移除 - 使用固定窗口大小，无需响应式布局

void CPortMasterDlg::OnGetMinMaxInfo(MINMAXINFO* lpMMI)
{
	CDialogEx::OnGetMinMaxInfo(lpMMI);
	// 固定窗口大小 - 无需设置最小/最大尺寸限制
}

void CPortMasterDlg::ResizeControls(int cx, int cy)
{
	// 安全性检查：确保窗口已完全初始化
	if (!::IsWindow(GetSafeHwnd()) || cx <= 0 || cy <= 0) {
		WriteDebugLog("[WARNING] ResizeControls: 窗口未初始化或尺寸无效，跳过布局调整");
		return;
	}

	// 按designUI.txt设计方案的布局参数
	const int MARGIN = 8;
	const int LEFT_WIDTH = 142;      // 左侧连接控制面板固定宽度
	const int RIGHT_WIDTH = 176;     // 右侧操作+显示控制面板固定宽度
	const int MIN_CENTER_WIDTH = 300; // 中央区域最小宽度
	const int CENTER_WIDTH = std::max(MIN_CENTER_WIDTH, cx - LEFT_WIDTH - RIGHT_WIDTH - MARGIN * 4);
	
	// 高度分配（按设计方案）
	const int INPUT_HEIGHT = 152;    // 数据发送区域高度
	const int DISPLAY_HEIGHT = 132;  // 数据接收区域高度
	const int STATUS_HEIGHT = 52;    // 系统状态区域高度
	
	// 验证窗口尺寸是否足够容纳所有控件
	const int MIN_REQUIRED_WIDTH = LEFT_WIDTH + MIN_CENTER_WIDTH + RIGHT_WIDTH + MARGIN * 4;
	const int MIN_REQUIRED_HEIGHT = INPUT_HEIGHT + DISPLAY_HEIGHT + STATUS_HEIGHT + MARGIN * 4;
	
	if (cx < MIN_REQUIRED_WIDTH || cy < MIN_REQUIRED_HEIGHT) {
		WriteDebugLog("[WARNING] ResizeControls: 窗口尺寸小于最小要求，可能导致布局问题");
	}

	// 收集需要调整的控件列表并验证句柄有效性
	struct ControlInfo {
		int id;
		CWnd* pWnd;
		CRect rect;
		bool valid;
	};
	
	std::vector<ControlInfo> controls;
	int centerLeft = LEFT_WIDTH + MARGIN * 2;
	int rightLeft = centerLeft + CENTER_WIDTH + MARGIN;
	int displayTop = INPUT_HEIGHT + MARGIN * 2;
	int displayWidth = cx - RIGHT_WIDTH - MARGIN * 3;
	int statusTop = displayTop + DISPLAY_HEIGHT + MARGIN;

	// 准备控件调整信息
	// 中央发送区域
	controls.push_back({IDC_SEND_DATA_GROUP, GetDlgItem(IDC_SEND_DATA_GROUP), CRect(centerLeft, MARGIN, centerLeft + CENTER_WIDTH, MARGIN + INPUT_HEIGHT), false});
	controls.push_back({IDC_INPUT_HEX, GetDlgItem(IDC_INPUT_HEX), CRect(centerLeft + 10, 40, centerLeft + CENTER_WIDTH - 10, 120), false});
	
	// 右侧操作区域和按钮
	controls.push_back({IDC_OPERATE_GROUP, GetDlgItem(IDC_OPERATE_GROUP), CRect(rightLeft, MARGIN, rightLeft + RIGHT_WIDTH, MARGIN + INPUT_HEIGHT), false});
	controls.push_back({IDC_SEND_BUTTON, GetDlgItem(IDC_SEND_BUTTON), CRect(rightLeft + 15, 30, rightLeft + 100, 55), false});
	controls.push_back({IDC_CLEAR_INPUT_BUTTON, GetDlgItem(IDC_CLEAR_INPUT_BUTTON), CRect(rightLeft + 15, 65, rightLeft + 100, 90), false});
	controls.push_back({IDC_LOAD_FILE_BUTTON, GetDlgItem(IDC_LOAD_FILE_BUTTON), CRect(rightLeft + 15, 100, rightLeft + 100, 125), false});
	
	// 数据接收区域
	controls.push_back({IDC_DATA_RECEIVE_GROUP, GetDlgItem(IDC_DATA_RECEIVE_GROUP), CRect(MARGIN, displayTop, MARGIN + displayWidth, displayTop + DISPLAY_HEIGHT), false});
	controls.push_back({IDC_DATA_VIEW, GetDlgItem(IDC_DATA_VIEW), CRect(18, displayTop + 32, 18 + displayWidth - 20, displayTop + 127), false});
	
	// 右侧显示控制区域和按钮
	controls.push_back({IDC_DISPLAY_CONTROL_GROUP, GetDlgItem(IDC_DISPLAY_CONTROL_GROUP), CRect(rightLeft, displayTop, rightLeft + RIGHT_WIDTH, displayTop + DISPLAY_HEIGHT), false});
	controls.push_back({IDC_HEX_DISPLAY_CHECK, GetDlgItem(IDC_HEX_DISPLAY_CHECK), CRect(rightLeft + 15, displayTop + 20, rightLeft + 160, displayTop + 40), false});
	controls.push_back({IDC_CLEAR_DISPLAY_BUTTON, GetDlgItem(IDC_CLEAR_DISPLAY_BUTTON), CRect(rightLeft + 15, displayTop + 50, rightLeft + 100, displayTop + 75), false});
	controls.push_back({IDC_COPY_BUTTON, GetDlgItem(IDC_COPY_BUTTON), CRect(rightLeft + 15, displayTop + 80, rightLeft + 100, displayTop + 105), false});
	controls.push_back({IDC_SAVE_FILE_BUTTON, GetDlgItem(IDC_SAVE_FILE_BUTTON), CRect(rightLeft + 15, displayTop + 110, rightLeft + 100, displayTop + 135), false});
	
	// 系统状态区域
	controls.push_back({IDC_SYSTEM_STATUS_GROUP, GetDlgItem(IDC_SYSTEM_STATUS_GROUP), CRect(MARGIN, statusTop, cx - MARGIN, statusTop + STATUS_HEIGHT), false});
	controls.push_back({IDC_LOG, GetDlgItem(IDC_LOG), CRect(45, statusTop + 16, 345, statusTop + 24), false});
	controls.push_back({IDC_PROGRESS, GetDlgItem(IDC_PROGRESS), CRect(560, statusTop + 15, 680, statusTop + 25), false});

	// 验证控件句柄并统计有效控件数量
	int validControlCount = 0;
	for (auto& ctrl : controls) {
		if (ctrl.pWnd && ::IsWindow(ctrl.pWnd->GetSafeHwnd())) {
			ctrl.valid = true;
			validControlCount++;
		} else {
			WriteDebugLog(("[WARNING] ResizeControls: 控件ID " + std::to_string(ctrl.id) + " 句柄无效").c_str());
		}
	}

	if (validControlCount == 0) {
		WriteDebugLog("[ERROR] ResizeControls: 没有有效的控件句柄，跳过布局调整");
		return;
	}

	// 使用批量控件操作提高性能，动态分配HDWP数量
	HDWP hDWP = BeginDeferWindowPos(validControlCount);
	if (!hDWP) {
		WriteDebugLog("[ERROR] ResizeControls: BeginDeferWindowPos失败");
		return;
	}
	
	try {
		// 批量调整控件位置
		for (const auto& ctrl : controls) {
			if (ctrl.valid && hDWP) {
				HDWP newHDWP = DeferWindowPos(hDWP, ctrl.pWnd->GetSafeHwnd(), NULL,
					ctrl.rect.left, ctrl.rect.top, 
					ctrl.rect.Width(), ctrl.rect.Height(), 
					SWP_NOZORDER | SWP_NOACTIVATE);
				if (newHDWP) {
					hDWP = newHDWP;
				} else {
					WriteDebugLog(("[WARNING] ResizeControls: DeferWindowPos失败，控件ID " + std::to_string(ctrl.id)).c_str());
				}
			}
		}
		
		// 批量应用所有控件位置调整
		if (hDWP) {
			BOOL result = EndDeferWindowPos(hDWP);
			if (!result) {
				WriteDebugLog("[WARNING] ResizeControls: EndDeferWindowPos失败，部分控件可能未正确调整");
			}
			hDWP = NULL; // 防止重复释放
		}
		
		CString debugMsg;
		debugMsg.Format(L"[DEBUG] ResizeControls: 窗口调整为 %dx%d，中央区域宽度=%d，有效控件数=%d", 
			cx, cy, CENTER_WIDTH, validControlCount);
		WriteDebugLog(CT2A(debugMsg));
	}
	catch (...) {
		WriteDebugLog("[ERROR] ResizeControls: 响应式布局调整时发生异常");
		
		// 异常情况下的资源清理
		if (hDWP) {
			try {
				EndDeferWindowPos(hDWP);
			} catch (...) {
				WriteDebugLog("[ERROR] ResizeControls: 异常清理期间EndDeferWindowPos也失败");
			}
		}
		return; // 异常时不进行重绘
	}
	
	// 延迟重绘以避免闪烁
	SetTimer(3001, 50, NULL); // 50ms后触发重绘
}

void CPortMasterDlg::InitializeLayoutConstants()
{
	// 布局常量已在头文件中定义为静态常量
	// 此方法保留用于未来可能的动态调整需求
}

CRect CPortMasterDlg::CalculateControlRect(int left, int top, int width, int height, int cx, int cy)
{
	// 辅助方法：计算控件在给定窗口尺寸下的矩形位置
	// 支持百分比和像素混合计算
	return CRect(left, top, left + width, top + height);
}