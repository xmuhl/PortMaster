#include "pch.h"
#include "IOWorker.h"

IOWorker::IOWorker()
    : m_running(false)
    , m_completionPort(NULL)
    , m_threadCount(2)
    , m_timeoutMs(INFINITE)
{
}

IOWorker::~IOWorker()
{
    Stop();
}

bool IOWorker::Start()
{
    if (m_running.load())
        return true;
    
    // 鍒涘缓瀹屾垚绔彛
    m_completionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, m_threadCount);
    if (m_completionPort == NULL)
        return false;
    
    // 鍚姩宸ヤ綔绾跨▼
    m_running = true;
    m_workerThreads.reserve(m_threadCount);
    
    for (int i = 0; i < m_threadCount; i++)
    {
        m_workerThreads.emplace_back(&IOWorker::WorkerThreadFunc, this);
    }
    
    return true;
}

void IOWorker::Stop()
{
    if (!m_running.load())
        return;
    
    m_running = false;
    
    // 閫氱煡宸ヤ綔绾跨▼閫€鍑?    for (int i = 0; i < m_threadCount; i++)
    {
        PostQueuedCompletionStatus(m_completionPort, 0, 0, NULL);
    }
    
    // 绛夊緟绾跨▼缁撴潫
    for (auto& thread : m_workerThreads)
    {
        if (thread.joinable())
            thread.join();
    }
    m_workerThreads.clear();
    
    // 鍏抽棴瀹屾垚绔彛
    if (m_completionPort != NULL)
    {
        CloseHandle(m_completionPort);
        m_completionPort = NULL;
    }
    
    // 娓呯悊涓婁笅鏂囨睜
    std::lock_guard<std::mutex> lock(m_contextMutex);
    while (!m_contextPool.empty())
        m_contextPool.pop();
}

bool IOWorker::IsRunning() const
{
    return m_running.load();
}

bool IOWorker::AsyncRead(HANDLE handle, std::vector<uint8_t>& buffer, IOCompletionCallback callback)
{
    // TODO: 瀹炵幇寮傛璇诲彇
    return true;
}

bool IOWorker::AsyncWrite(HANDLE handle, const std::vector<uint8_t>& data, IOCompletionCallback callback)
{
    // TODO: 瀹炵幇寮傛鍐欏叆
    return true;
}

void IOWorker::SetGlobalCallback(IOCompletionCallback callback)
{
    m_globalCallback = callback;
}

void IOWorker::SetThreadCount(int count)
{
    if (!m_running.load() && count > 0)
        m_threadCount = count;
}

void IOWorker::SetTimeout(DWORD timeoutMs)
{
    m_timeoutMs = timeoutMs;
}

void IOWorker::WorkerThreadFunc()
{
    // TODO: 瀹炵幇宸ヤ綔绾跨▼閫昏緫
    while (m_running.load())
    {
        DWORD bytesTransferred = 0;
        ULONG_PTR completionKey = 0;
        LPOVERLAPPED overlapped = NULL;
        
        BOOL result = GetQueuedCompletionStatus(
            m_completionPort,
            &bytesTransferred,
            &completionKey,
            &overlapped,
            m_timeoutMs
        );
        
        if (!m_running.load())
            break;
        
        if (overlapped == NULL)
            continue;
        
        // 澶勭悊I/O瀹屾垚
        IOContext* context = CONTAINING_RECORD(overlapped, IOContext, overlapped);
        DWORD errorCode = result ? ERROR_SUCCESS : GetLastError();
        
        HandleIOCompletion(context, bytesTransferred, errorCode);
    }
}

std::unique_ptr<IOWorker::IOContext> IOWorker::GetContext()
{
    std::lock_guard<std::mutex> lock(m_contextMutex);
    if (!m_contextPool.empty())
    {
        auto context = std::move(m_contextPool.front());
        m_contextPool.pop();
        return context;
    }
    
    return std::make_unique<IOContext>();
}

void IOWorker::ReturnContext(std::unique_ptr<IOContext> context)
{
    if (!context)
        return;
    
    // 閲嶇疆涓婁笅鏂?    ZeroMemory(&context->overlapped, sizeof(context->overlapped));
    context->operation = IOOperation::Read;
    context->handle = INVALID_HANDLE_VALUE;
    context->buffer.clear();
    context->callback = nullptr;
    context->worker = nullptr;
    
    std::lock_guard<std::mutex> lock(m_contextMutex);
    m_contextPool.push(std::move(context));
}

void IOWorker::HandleIOCompletion(IOContext* context, DWORD bytesTransferred, DWORD errorCode)
{
    if (!context)
        return;
    
    IOResult result;
    result.operation = context->operation;
    result.success = (errorCode == ERROR_SUCCESS);
    result.bytesTransferred = bytesTransferred;
    result.errorCode = errorCode;
    result.data = std::move(context->buffer);
    
    // 璋冪敤鍥炶皟
    if (context->callback)
        context->callback(result);
    else if (m_globalCallback)
        m_globalCallback(result);
    
    // 杩斿洖涓婁笅鏂囧埌姹犱腑
    ReturnContext(std::unique_ptr<IOContext>(context));
}