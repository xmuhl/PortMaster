#include "pch.h"
#include "ConfigManager.h"
#include <fstream>
#include <sstream>
#include <shlobj.h>

ConfigManager::ConfigManager()
{
    SetDefaultValues();
    
    // 灏濊瘯鍔犺浇閰嶇疆鏂囦欢
    std::string configPath = GetDefaultConfigPath();
    if (!LoadConfig(configPath))
    {
        // 濡傛灉榛樿璺緞澶辫触锛屽皾璇曠敤鎴疯矾寰?        configPath = GetUserConfigPath();
        LoadConfig(configPath);
    }
}

ConfigManager::~ConfigManager()
{
    // 鑷姩淇濆瓨閰嶇疆
    SaveConfig();
}

bool ConfigManager::LoadConfig(const std::string& filePath)
{
    if (filePath.empty())
    {
        m_configFilePath = GetDefaultConfigPath();
    }
    else
    {
        m_configFilePath = filePath;
    }
    
    // TODO: 瀹炵幇JSON閰嶇疆鏂囦欢鍔犺浇
    return ParseJsonFile(m_configFilePath);
}

bool ConfigManager::SaveConfig(const std::string& filePath) const
{
    std::string savePath = filePath.empty() ? m_configFilePath : filePath;
    return WriteJsonFile(savePath);
}

bool ConfigManager::ResetToDefaults()
{
    m_config.clear();
    SetDefaultValues();
    return SaveConfig();
}

bool ConfigManager::SaveTransportConfig(const std::string& transportType, const TransportConfig& config)
{
    std::string section = "Transport_" + transportType;
    
    SetValue(section, "baudRate", config.baudRate);
    SetValue(section, "dataBits", config.dataBits);
    SetValue(section, "parity", config.parity);
    SetValue(section, "stopBits", config.stopBits);
    SetValue(section, "ipAddress", config.ipAddress);
    SetValue(section, "port", config.port);
    SetValue(section, "isServer", config.isServer);
    SetValue(section, "connectTimeoutMs", config.connectTimeoutMs);
    SetValue(section, "readTimeoutMs", config.readTimeoutMs);
    SetValue(section, "writeTimeoutMs", config.writeTimeoutMs);
    SetValue(section, "rxBufferSize", static_cast<int>(config.rxBufferSize));
    SetValue(section, "txBufferSize", static_cast<int>(config.txBufferSize));
    
    return true;
}

TransportConfig ConfigManager::LoadTransportConfig(const std::string& transportType) const
{
    std::string section = "Transport_" + transportType;
    TransportConfig config = GetDefaultTransportConfig(transportType);
    
    config.baudRate = GetInt(section, "baudRate", config.baudRate);
    config.dataBits = GetInt(section, "dataBits", config.dataBits);
    config.parity = GetInt(section, "parity", config.parity);
    config.stopBits = GetInt(section, "stopBits", config.stopBits);
    config.ipAddress = GetString(section, "ipAddress", config.ipAddress);
    config.port = GetInt(section, "port", config.port);
    config.isServer = GetBool(section, "isServer", config.isServer);
    config.connectTimeoutMs = GetInt(section, "connectTimeoutMs", config.connectTimeoutMs);
    config.readTimeoutMs = GetInt(section, "readTimeoutMs", config.readTimeoutMs);
    config.writeTimeoutMs = GetInt(section, "writeTimeoutMs", config.writeTimeoutMs);
    config.rxBufferSize = GetInt(section, "rxBufferSize", static_cast<int>(config.rxBufferSize));
    config.txBufferSize = GetInt(section, "txBufferSize", static_cast<int>(config.txBufferSize));
    
    return config;
}

std::vector<std::string> ConfigManager::GetSavedTransportTypes() const
{
    std::vector<std::string> types;
    
    for (const auto& section : m_config)
    {
        if (section.first.substr(0, 10) == "Transport_")
        {
            types.push_back(section.first.substr(10));
        }
    }
    
    return types;
}

void ConfigManager::SetValue(const std::string& section, const std::string& key, const std::string& value)
{
    m_config[section][key] = value;
}

void ConfigManager::SetValue(const std::string& section, const std::string& key, int value)
{
    SetValue(section, key, std::to_string(value));
}

void ConfigManager::SetValue(const std::string& section, const std::string& key, bool value)
{
    SetValue(section, key, value ? "true" : "false");
}

void ConfigManager::SetValue(const std::string& section, const std::string& key, double value)
{
    SetValue(section, key, std::to_string(value));
}

std::string ConfigManager::GetString(const std::string& section, const std::string& key, const std::string& defaultValue) const
{
    auto sectionIt = m_config.find(section);
    if (sectionIt != m_config.end())
    {
        auto keyIt = sectionIt->second.find(key);
        if (keyIt != sectionIt->second.end())
            return keyIt->second;
    }
    return defaultValue;
}

int ConfigManager::GetInt(const std::string& section, const std::string& key, int defaultValue) const
{
    std::string value = GetString(section, key);
    if (value.empty())
        return defaultValue;
    
    try {
        return std::stoi(value);
    } catch (...) {
        return defaultValue;
    }
}

bool ConfigManager::GetBool(const std::string& section, const std::string& key, bool defaultValue) const
{
    std::string value = GetString(section, key);
    if (value.empty())
        return defaultValue;
    
    return (value == "true" || value == "1" || value == "yes");
}

double ConfigManager::GetDouble(const std::string& section, const std::string& key, double defaultValue) const
{
    std::string value = GetString(section, key);
    if (value.empty())
        return defaultValue;
    
    try {
        return std::stod(value);
    } catch (...) {
        return defaultValue;
    }
}

ConfigManager::AppConfig ConfigManager::GetAppConfig() const
{
    AppConfig config;
    
    config.windowX = GetInt("Window", "x", config.windowX);
    config.windowY = GetInt("Window", "y", config.windowY);
    config.windowWidth = GetInt("Window", "width", config.windowWidth);
    config.windowHeight = GetInt("Window", "height", config.windowHeight);
    config.windowMaximized = GetBool("Window", "maximized", config.windowMaximized);
    
    config.ackTimeoutMs = GetInt("Protocol", "ackTimeoutMs", config.ackTimeoutMs);
    config.maxRetries = GetInt("Protocol", "maxRetries", config.maxRetries);
    config.maxPayloadSize = GetInt("Protocol", "maxPayloadSize", static_cast<int>(config.maxPayloadSize));
    config.receiveDirectory = GetString("Protocol", "receiveDirectory", config.receiveDirectory);
    
    config.hexViewEnabled = GetBool("UI", "hexViewEnabled", config.hexViewEnabled);
    config.textViewEnabled = GetBool("UI", "textViewEnabled", config.textViewEnabled);
    config.showTimestamp = GetBool("UI", "showTimestamp", config.showTimestamp);
    
    config.enableLogging = GetBool("Log", "enableLogging", config.enableLogging);
    config.logDirectory = GetString("Log", "logDirectory", config.logDirectory);
    config.maxLogFiles = GetInt("Log", "maxLogFiles", config.maxLogFiles);
    
    config.autoTest = GetBool("Test", "autoTest", config.autoTest);
    config.testDataFile = GetString("Test", "testDataFile", config.testDataFile);
    
    return config;
}

void ConfigManager::SetAppConfig(const AppConfig& config)
{
    SetValue("Window", "x", config.windowX);
    SetValue("Window", "y", config.windowY);
    SetValue("Window", "width", config.windowWidth);
    SetValue("Window", "height", config.windowHeight);
    SetValue("Window", "maximized", config.windowMaximized);
    
    SetValue("Protocol", "ackTimeoutMs", config.ackTimeoutMs);
    SetValue("Protocol", "maxRetries", config.maxRetries);
    SetValue("Protocol", "maxPayloadSize", static_cast<int>(config.maxPayloadSize));
    SetValue("Protocol", "receiveDirectory", config.receiveDirectory);
    
    SetValue("UI", "hexViewEnabled", config.hexViewEnabled);
    SetValue("UI", "textViewEnabled", config.textViewEnabled);
    SetValue("UI", "showTimestamp", config.showTimestamp);
    
    SetValue("Log", "enableLogging", config.enableLogging);
    SetValue("Log", "logDirectory", config.logDirectory);
    SetValue("Log", "maxLogFiles", config.maxLogFiles);
    
    SetValue("Test", "autoTest", config.autoTest);
    SetValue("Test", "testDataFile", config.testDataFile);
}

std::string ConfigManager::GetDefaultConfigPath()
{
    char exePath[MAX_PATH];
    GetModuleFileNameA(NULL, exePath, MAX_PATH);
    
    std::string path = exePath;
    size_t pos = path.find_last_of("\\/");
    if (pos != std::string::npos)
        path = path.substr(0, pos);
    
    return path + "\\PortMaster.config";
}

std::string ConfigManager::GetUserConfigPath()
{
    char appDataPath[MAX_PATH];
    if (SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_LOCAL_APPDATA, NULL, 0, appDataPath)))
    {
        std::string path = appDataPath;
        path += "\\PortMaster";
        
        // 鍒涘缓鐩綍
        CreateDirectoryA(path.c_str(), NULL);
        
        return path + "\\PortMaster.config";
    }
    
    return GetDefaultConfigPath();
}

bool ConfigManager::ParseJsonFile(const std::string& filePath)
{
    // TODO: 瀹炵幇绠€鍗曠殑JSON瑙ｆ瀽
    std::ifstream file(filePath);
    if (!file.is_open())
        return false;
    
    // 绠€鍗曠殑閿€煎瑙ｆ瀽锛堥潪瀹屾暣JSON瑙ｆ瀽鍣級
    std::string line;
    std::string currentSection;
    
    while (std::getline(file, line))
    {
        // 鍘婚櫎绌烘牸
        line.erase(0, line.find_first_not_of(" \t"));
        line.erase(line.find_last_not_of(" \t") + 1);
        
        if (line.empty() || line[0] == '#' || line[0] == ';')
            continue;
        
        // 绠€鍗曞鐞?[section] 鏍煎紡
        if (line[0] == '[' && line.back() == ']')
        {
            currentSection = line.substr(1, line.length() - 2);
            continue;
        }
        
        // 澶勭悊 key=value 鏍煎紡
        size_t eqPos = line.find('=');
        if (eqPos != std::string::npos)
        {
            std::string key = line.substr(0, eqPos);
            std::string value = line.substr(eqPos + 1);
            
            // 鍘婚櫎绌烘牸
            key.erase(0, key.find_first_not_of(" \t"));
            key.erase(key.find_last_not_of(" \t") + 1);
            value.erase(0, value.find_first_not_of(" \t"));
            value.erase(value.find_last_not_of(" \t") + 1);
            
            m_config[currentSection][key] = value;
        }
    }
    
    return true;
}

bool ConfigManager::WriteJsonFile(const std::string& filePath) const
{
    if (!EnsureDirectoryExists(filePath))
        return false;
    
    std::ofstream file(filePath);
    if (!file.is_open())
        return false;
    
    // 绠€鍗曠殑閿€煎鍐欏叆锛堥潪瀹屾暣JSON鏍煎紡锛?    file << "# PortMaster Configuration File\n";
    file << "# Generated automatically - do not edit manually\n\n";
    
    for (const auto& section : m_config)
    {
        file << "[" << section.first << "]\n";
        for (const auto& kv : section.second)
        {
            file << kv.first << "=" << kv.second << "\n";
        }
        file << "\n";
    }
    
    return true;
}

std::string ConfigManager::EscapeJsonString(const std::string& str) const
{
    // TODO: 瀹炵幇JSON瀛楃涓茶浆涔?    return str;
}

std::string ConfigManager::UnescapeJsonString(const std::string& str) const
{
    // TODO: 瀹炵幇JSON瀛楃涓插弽杞箟
    return str;
}

bool ConfigManager::EnsureDirectoryExists(const std::string& filePath) const
{
    size_t pos = filePath.find_last_of("\\/");
    if (pos == std::string::npos)
        return true;
    
    std::string directory = filePath.substr(0, pos);
    return CreateDirectoryA(directory.c_str(), NULL) || GetLastError() == ERROR_ALREADY_EXISTS;
}

std::string ConfigManager::GetSectionKey(const std::string& section, const std::string& key) const
{
    return section + "." + key;
}

void ConfigManager::SetDefaultValues()
{
    // 璁剧疆榛樿閰嶇疆鍊?    SetValue("General", "version", "1.0.0");
    SetValue("General", "firstRun", true);
    
    // 绐楀彛榛樿璁剧疆
    SetValue("Window", "x", 100);
    SetValue("Window", "y", 100);
    SetValue("Window", "width", 800);
    SetValue("Window", "height", 600);
    SetValue("Window", "maximized", false);
    
    // 鍗忚榛樿璁剧疆
    SetValue("Protocol", "ackTimeoutMs", 1000);
    SetValue("Protocol", "maxRetries", 3);
    SetValue("Protocol", "maxPayloadSize", 1024);
    
    // UI榛樿璁剧疆
    SetValue("UI", "hexViewEnabled", true);
    SetValue("UI", "textViewEnabled", true);
    SetValue("UI", "showTimestamp", true);
    
    // 鏃ュ織榛樿璁剧疆
    SetValue("Log", "enableLogging", true);
    SetValue("Log", "maxLogFiles", 10);
}

TransportConfig ConfigManager::GetDefaultTransportConfig(const std::string& transportType) const
{
    TransportConfig config;
    
    if (transportType == "Serial")
    {
        config.baudRate = 9600;
        config.dataBits = 8;
        config.parity = 0;
        config.stopBits = 1;
    }
    else if (transportType == "TCP" || transportType == "UDP")
    {
        config.ipAddress = "127.0.0.1";
        config.port = 8080;
        config.isServer = false;
    }
    
    return config;
}