#include "pch.h"
#include "UdpTransport.h"

bool UdpTransport::s_wsaInitialized = false;
int UdpTransport::s_wsaRefCount = 0;

UdpTransport::UdpTransport()
    : m_socket(INVALID_SOCKET)
    , m_hasRemoteAddr(false)
    , m_stopRead(false)
{
    m_state = TRANSPORT_CLOSED;
    ZeroMemory(&m_localAddr, sizeof(m_localAddr));
    ZeroMemory(&m_remoteAddr, sizeof(m_remoteAddr));
}

UdpTransport::~UdpTransport()
{
    Close();
}

bool UdpTransport::Open(const TransportConfig& config)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    if (m_state == TRANSPORT_OPEN)
    {
        SetLastError("连接已存在");
        return false;
    }
    
    m_config = config;
    NotifyStateChanged(TRANSPORT_OPENING, "正在初始化UDP...");
    
    // 初始化WinSock
    if (!InitializeWinsock())
    {
        NotifyStateChanged(TRANSPORT_ERROR, m_lastError);
        return false;
    }
    
    // 创建套接字
    m_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (m_socket == INVALID_SOCKET)
    {
        int error = WSAGetLastError();
        SetLastError("创建 UDP 套接字失败: " + GetSocketErrorString(error));
        CleanupWinsock();
        NotifyStateChanged(TRANSPORT_ERROR, m_lastError);
        return false;
    }
    
    // 设置本地地址
    m_localAddr.sin_family = AF_INET;
    m_localAddr.sin_port = htons(static_cast<u_short>(config.port));
    m_localAddr.sin_addr.s_addr = INADDR_ANY;
    
    // 绑定本地地址
    if (bind(m_socket, (sockaddr*)&m_localAddr, sizeof(m_localAddr)) == SOCKET_ERROR)
    {
        int error = WSAGetLastError();
        SetLastError("绑定 UDP 端口失败: " + GetSocketErrorString(error));
        closesocket(m_socket);
        m_socket = INVALID_SOCKET;
        CleanupWinsock();
        NotifyStateChanged(TRANSPORT_ERROR, m_lastError);
        return false;
    }
    
    // 设置超时
    DWORD timeout = m_config.readTimeoutMs;
    setsockopt(m_socket, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout));
    
    timeout = m_config.writeTimeoutMs;
    setsockopt(m_socket, SOL_SOCKET, SO_SNDTIMEO, (char*)&timeout, sizeof(timeout));
    
    // 设置远程地址（如果提供）
    if (!config.ipAddress.empty())
    {
        SetRemoteEndpoint(config.ipAddress, config.port);
    }
    
    // 启动读取线程
    m_stopRead = false;
    m_readThread = std::thread(&UdpTransport::ReadThreadFunc, this);
    
    NotifyStateChanged(TRANSPORT_OPEN, "UDP 已打开 端口:" + std::to_string(config.port));
    return true;
}

void UdpTransport::Close()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    if (m_state == TRANSPORT_CLOSED)
        return;
    
    NotifyStateChanged(TRANSPORT_CLOSING, "正在关闭UDP...");
    
    // 停止读取线程
    m_stopRead = true;
    
    // 关闭套接字
    if (m_socket != INVALID_SOCKET)
    {
        closesocket(m_socket);
        m_socket = INVALID_SOCKET;
    }
    
    // 等待线程结束
    if (m_readThread.joinable())
        m_readThread.join();
    
    // 清理地址信息
    ZeroMemory(&m_localAddr, sizeof(m_localAddr));
    ZeroMemory(&m_remoteAddr, sizeof(m_remoteAddr));
    m_hasRemoteAddr = false;
    
    CleanupWinsock();
    
    NotifyStateChanged(TRANSPORT_CLOSED, "UDP 已关闭");
}

bool UdpTransport::IsOpen() const
{
    return m_state == TRANSPORT_OPEN;
}

TransportState UdpTransport::GetState() const
{
    return m_state;
}

bool UdpTransport::Configure(const TransportConfig& config)
{
    m_config = config;
    return true;
}

TransportConfig UdpTransport::GetConfiguration() const
{
    return m_config;
}

size_t UdpTransport::Write(const std::vector<uint8_t>& data)
{
    return Write(data.data(), data.size());
}

size_t UdpTransport::Write(const uint8_t* data, size_t length)
{
    if (!IsOpen() || m_socket == INVALID_SOCKET || !data || length == 0)
        return 0;
    
    std::lock_guard<std::mutex> lock(m_mutex);
    
    // 如果没有设置远程地址，尝试使用配置中的地址
    if (!m_hasRemoteAddr && !m_config.ipAddress.empty())
    {
        SetRemoteEndpoint(m_config.ipAddress, m_config.port);
    }
    
    if (!m_hasRemoteAddr)
    {
        SetLastError("未设置远程端点地址");
        return 0;
    }
    
    int bytesSent = sendto(m_socket, (const char*)data, static_cast<int>(length), 0,
                          (sockaddr*)&m_remoteAddr, sizeof(m_remoteAddr));
    
    if (bytesSent == SOCKET_ERROR)
    {
        int error = WSAGetLastError();
        SetLastError("UDP发送失败: " + GetSocketErrorString(error));
        return 0;
    }
    
    return static_cast<size_t>(bytesSent);
}

size_t UdpTransport::Read(std::vector<uint8_t>& data, size_t maxLength)
{
    data.clear();
    
    if (!IsOpen() || m_socket == INVALID_SOCKET)
        return 0;
    
    if (maxLength == 0)
        maxLength = 4096;
    
    data.resize(maxLength);
    
    sockaddr_in senderAddr = {};
    int addrLen = sizeof(senderAddr);
    
    int bytesReceived = recvfrom(m_socket, (char*)data.data(), static_cast<int>(maxLength), 0,
                                (sockaddr*)&senderAddr, &addrLen);
    
    if (bytesReceived > 0)
    {
        data.resize(bytesReceived);
        
        // 更新远程地址信息（如果还未设置）
        if (!m_hasRemoteAddr)
        {
            m_remoteAddr = senderAddr;
            m_hasRemoteAddr = true;
        }
        
        return static_cast<size_t>(bytesReceived);
    }
    else if (bytesReceived == 0)
    {
        // UDP通常不会返回0，但处理一下
        data.clear();
        return 0;
    }
    else
    {
        int error = WSAGetLastError();
        if (error != WSAETIMEDOUT && error != WSAEWOULDBLOCK)
        {
            SetLastError("UDP接收失败: " + GetSocketErrorString(error));
        }
        data.clear();
        return 0;
    }
}

size_t UdpTransport::Available() const
{
    return 0;
}

std::string UdpTransport::GetLastError() const
{
    return m_lastError;
}

std::string UdpTransport::GetPortName() const
{
    return "UDP:" + std::to_string(m_config.port);
}

std::string UdpTransport::GetTransportType() const
{
    return "UDP";
}

void UdpTransport::SetDataReceivedCallback(DataReceivedCallback callback)
{
    m_dataCallback = callback;
}

void UdpTransport::SetStateChangedCallback(StateChangedCallback callback)
{
    m_stateCallback = callback;
}

bool UdpTransport::Flush()
{
    return true;
}

bool UdpTransport::ClearBuffers()
{
    return true;
}

bool UdpTransport::SetRemoteEndpoint(const std::string& address, int port)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    // 验证端口范围
    if (port <= 0 || port > 65535)
    {
        SetLastError("端口号超出有效范围: " + std::to_string(port));
        return false;
    }
    
    // 解析IPv4地址
    m_remoteAddr.sin_family = AF_INET;
    m_remoteAddr.sin_port = htons(static_cast<u_short>(port));
    
    // 使用inet_pton解析IP地址
    int result = inet_pton(AF_INET, address.c_str(), &m_remoteAddr.sin_addr);
    if (result == 1)
    {
        m_hasRemoteAddr = true;
        return true;
    }
    else if (result == 0)
    {
        SetLastError("无效的IP地址格式: " + address);
        m_hasRemoteAddr = false;
        return false;
    }
    else
    {
        int error = WSAGetLastError();
        SetLastError("IP地址解析失败: " + GetSocketErrorString(error));
        m_hasRemoteAddr = false;
        return false;
    }
}

std::string UdpTransport::GetRemoteEndpoint() const
{
    if (!m_hasRemoteAddr)
        return "未设置";
    
    char ipStr[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &m_remoteAddr.sin_addr, ipStr, INET_ADDRSTRLEN);
    return std::string(ipStr) + ":" + std::to_string(ntohs(m_remoteAddr.sin_port));
}

std::string UdpTransport::GetLocalEndpoint() const
{
    return "127.0.0.1:" + std::to_string(m_config.port);
}

bool UdpTransport::InitializeWinsock()
{
    if (s_wsaInitialized)
    {
        s_wsaRefCount++;
        return true;
    }
    
    WSADATA wsaData;
    int result = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (result != 0)
    {
        SetLastError("初始化WinSock失败: 错误代码 " + std::to_string(result));
        return false;
    }
    
    s_wsaInitialized = true;
    s_wsaRefCount = 1;
    return true;
}

void UdpTransport::CleanupWinsock()
{
    if (!s_wsaInitialized)
        return;
    
    s_wsaRefCount--;
    if (s_wsaRefCount <= 0)
    {
        WSACleanup();
        s_wsaInitialized = false;
        s_wsaRefCount = 0;
    }
}


void UdpTransport::ReadThreadFunc()
{
    std::vector<uint8_t> buffer(4096);
    
    while (!m_stopRead && m_socket != INVALID_SOCKET)
    {
        sockaddr_in senderAddr = {};
        int addrLen = sizeof(senderAddr);
        
        int bytesReceived = recvfrom(m_socket, (char*)buffer.data(), static_cast<int>(buffer.size()), 0,
                                    (sockaddr*)&senderAddr, &addrLen);
        
        if (bytesReceived > 0)
        {
            // 数据接收成功
            std::vector<uint8_t> data(buffer.begin(), buffer.begin() + bytesReceived);
            
            // 更新远程地址信息（如果还未设置）
            if (!m_hasRemoteAddr)
            {
                std::lock_guard<std::mutex> lock(m_mutex);
                if (!m_hasRemoteAddr) // 双检查锁定
                {
                    m_remoteAddr = senderAddr;
                    m_hasRemoteAddr = true;
                }
            }
            
            NotifyDataReceived(data);
        }
        else if (bytesReceived == 0)
        {
            // UDP通常不会返回0，继续
            continue;
        }
        else
        {
            int error = WSAGetLastError();
            if (error == WSAETIMEDOUT)
            {
                // 超时是正常的，继续
                continue;
            }
            else if (!m_stopRead)
            {
                // 其他错误
                SetLastError("UDP接收错误: " + GetSocketErrorString(error));
                NotifyStateChanged(TRANSPORT_ERROR, m_lastError);
                break;
            }
        }
    }
}

std::string UdpTransport::GetSocketErrorString(int error) const
{
    switch (error)
    {
    case WSAECONNREFUSED:
        return "连接被拒绝";
    case WSAETIMEDOUT:
        return "超时";
    case WSAENETUNREACH:
        return "网络不可达";
    case WSAEHOSTUNREACH:
        return "主机不可达";
    case WSAEADDRINUSE:
        return "地址已被使用";
    case WSAEADDRNOTAVAIL:
        return "地址不可用";
    case WSAEMSGSIZE:
        return "数据包过大";
    default:
        return "UDP错误 " + std::to_string(error);
    }
}

// SOLID-L: 里氏替换原则 - 实现ITransport抽象方法
void UdpTransport::NotifyDataReceived(const std::vector<uint8_t>& data)
{
    if (m_dataCallback)
        m_dataCallback(data);
}

void UdpTransport::NotifyStateChanged(TransportState state, const std::string& message)
{
    m_state = state;
    if (m_stateCallback)
        m_stateCallback(state, message);
}

void UdpTransport::SetLastError(const std::string& error)
{
    m_lastError = error;
}