#include "pch.h"
#include "DataFormatter.h"
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <cctype>

const char* DataFormatter::HEX_CHARS = "0123456789ABCDEF";

std::string DataFormatter::BytesToHex(const std::vector<uint8_t>& data, bool addSpaces)
{
    return BytesToHex(data.data(), data.size(), addSpaces);
}

std::string DataFormatter::BytesToHex(const uint8_t* data, size_t length, bool addSpaces)
{
    if (!data || length == 0)
        return "";
    
    std::string result;
    result.reserve(length * (addSpaces ? 3 : 2));
    
    for (size_t i = 0; i < length; i++)
    {
        if (i > 0 && addSpaces)
            result += ' ';
        
        result += HEX_CHARS[(data[i] >> 4) & 0x0F];
        result += HEX_CHARS[data[i] & 0x0F];
    }
    
    return result;
}

std::vector<uint8_t> DataFormatter::HexToBytes(const std::string& hex)
{
    std::vector<uint8_t> result;
    std::string cleanHex = CleanHexInput(hex);
    
    if (cleanHex.empty() || cleanHex.length() % 2 != 0)
        return result;
    
    result.reserve(cleanHex.length() / 2);
    
    for (size_t i = 0; i < cleanHex.length(); i += 2)
    {
        int high = HexCharToValue(cleanHex[i]);
        int low = HexCharToValue(cleanHex[i + 1]);
        
        if (high == -1 || low == -1)
            return std::vector<uint8_t>(); // 无效字符
        
        result.push_back(static_cast<uint8_t>((high << 4) | low));
    }
    
    return result;
}

std::string DataFormatter::BytesToText(const std::vector<uint8_t>& data)
{
    return BytesToText(data.data(), data.size());
}

std::string DataFormatter::BytesToText(const uint8_t* data, size_t length)
{
    if (!data || length == 0)
        return "";
    
    std::string result;
    result.reserve(length);
    
    for (size_t i = 0; i < length; i++)
    {
        if (IsPrintable(data[i]))
            result += static_cast<char>(data[i]);
        else
            result += '.';
    }
    
    return result;
}

std::vector<uint8_t> DataFormatter::TextToBytes(const std::string& text)
{
    std::vector<uint8_t> result;
    result.reserve(text.length());
    
    for (char c : text)
    {
        result.push_back(static_cast<uint8_t>(c));
    }
    
    return result;
}

bool DataFormatter::IsValidHex(const std::string& hex)
{
    std::string cleanHex = CleanHexInput(hex);
    
    if (cleanHex.empty() || cleanHex.length() % 2 != 0)
        return false;
    
    for (char c : cleanHex)
    {
        if (HexCharToValue(c) == -1)
            return false;
    }
    
    return true;
}

std::string DataFormatter::FormatHexDump(const std::vector<uint8_t>& data, int bytesPerLine)
{
    if (data.empty())
        return "";
    
    std::ostringstream oss;
    
    // 设置字体为等宽字体以确保对齐
    for (size_t i = 0; i < data.size(); i += bytesPerLine)
    {
        // 地址列 - 使用8位16进制地址（与专业编辑器一致）
        oss << std::hex << std::uppercase << std::setw(8) << std::setfill('0') << i << "  ";
        
        // 十六进制列 - 每行16字节，专业分组格式
        for (int j = 0; j < bytesPerLine; j++)
        {
            if (i + j < data.size())
            {
                oss << std::hex << std::uppercase << std::setw(2) << std::setfill('0') 
                    << static_cast<int>(data[i + j]);
            }
            else
            {
                oss << "  ";  // 占位符保持对齐
            }
            
            // 专业分组格式：每8字节一组，中间用双空格分隔，每字节间单空格
            if (j == 7) {
                oss << "  ";  // 8字节分组间隔
            } else if (j < bytesPerLine - 1) {
                oss << " ";   // 字节间分隔
            }
        }
        
        // ASCII预览列分隔符
        oss << "  ";
        
        // ASCII列 - 显示可打印字符，16字符一行
        for (int j = 0; j < bytesPerLine; j++)
        {
            if (i + j < data.size())
            {
                uint8_t byte = data[i + j];
                if (IsPrintable(byte) && byte >= 0x20 && byte < 0x7F)
                    oss << static_cast<char>(byte);
                else if (byte == 0x00)
                    oss << '.';   // NULL字节用点号
                else if (byte == 0x09)
                    oss << '>';  // TAB字符用右箭头
                else if (byte == 0x0A || byte == 0x0D)
                    oss << '|';  // 换行符用竖线
                else
                    oss << '.';  // 其他不可见字符用点号
            }
            else
            {
                oss << " ";   // 占位符保持ASCII列对齐
            }
            
            // ASCII列也按8字符分组
            if (j == 7 && j < bytesPerLine - 1)
                oss << " ";
        }
        
        oss << "\r\n";
    }
    
    return oss.str();
}

std::string DataFormatter::CreateHexEditorHeader()
{
    std::ostringstream oss;
    
    // 创建标准的十六进制编辑器头部，类似 HxD
    oss << "偏移(H)   00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F   文本编码\r\n";
    oss << "--------  -------- -------- --------  -------- -------- --------   ----------------\r\n";
    
    return oss.str();
}

std::string DataFormatter::CleanHexInput(const std::string& input)
{
    std::string result;
    result.reserve(input.length());
    
    for (char c : input)
    {
        if (std::isxdigit(c))
        {
            result += std::toupper(c);
        }
    }
    
    return result;
}

bool DataFormatter::IsPrintable(uint8_t c)
{
    return (c >= 32 && c <= 126) || c == '\t';
}

int DataFormatter::HexCharToValue(char c)
{
    if (c >= '0' && c <= '9')
        return c - '0';
    else if (c >= 'A' && c <= 'F')
        return c - 'A' + 10;
    else if (c >= 'a' && c <= 'f')
        return c - 'a' + 10;
    else
        return -1;
}

char DataFormatter::ValueToHexChar(int value)
{
    if (value >= 0 && value <= 15)
        return HEX_CHARS[value];
    else
        return '?';
}

bool DataFormatter::IsBinaryData(const std::vector<uint8_t>& data)
{
    return IsBinaryData(data.data(), data.size());
}

bool DataFormatter::IsBinaryData(const uint8_t* data, size_t length)
{
    if (!data || length == 0)
        return false;
    
    // 检查前256字节或全部数据（取较小值）
    size_t checkLength = std::min(length, static_cast<size_t>(256));
    size_t nonPrintableCount = 0;
    size_t nullByteCount = 0;
    
    for (size_t i = 0; i < checkLength; i++)
    {
        uint8_t byte = data[i];
        
        // 统计空字节
        if (byte == 0x00)
        {
            nullByteCount++;
            // 如果在前半部分发现多个连续空字节，可能是二进制
            if (i > 10 && nullByteCount > 3)
                return true;
        }
        
        // 检查是否为非打印字符（排除常见空白字符和UTF-8字符）
        if (!IsPrintable(byte) && byte != '\r' && byte != '\n' && byte != '\0' && byte != '\t')
        {
            // 改进UTF-8字符判断逻辑
            // UTF-8多字节序列：首字节 0xC0-0xFD，后续字节 0x80-0xBF
            bool isUtf8Byte = false;
            if (byte >= 0x80) {
                // 可能是UTF-8的后续字节或首字节
                if ((byte >= 0x80 && byte <= 0xBF) ||  // UTF-8后续字节
                    (byte >= 0xC0 && byte <= 0xFD)) {  // UTF-8首字节
                    isUtf8Byte = true;
                }
            }
            
            if (!isUtf8Byte) {
                nonPrintableCount++;
            }
        }
        
        // 如果检测到明显的二进制标识符
        if ((i == 0 && (byte == 0xFF || byte == 0xFE)) || // BOM标识
            (i < 4 && byte > 0x7F && byte < 0x20))        // 早期控制字符
        {
            return true;
        }
    }
    
    // 提高阈值：如果非打印字符超过50%，认为是二进制数据
    double nonPrintableRatio = static_cast<double>(nonPrintableCount) / checkLength;
    
    // 对于短数据，更宽松的判断
    if (length < 32)
        return nonPrintableRatio > 0.6;
    else
        return nonPrintableRatio > 0.5;
}

std::string DataFormatter::SmartTextDisplay(const std::vector<uint8_t>& data)
{
    return SmartTextDisplay(data.data(), data.size());
}

std::string DataFormatter::SmartTextDisplay(const uint8_t* data, size_t length)
{
    if (!data || length == 0)
        return "";
    
    if (IsBinaryData(data, length))
    {
        // 对于二进制数据，显示十六进制摘要
        std::ostringstream oss;
        oss << "[二进制数据 " << length << " 字节] ";
        
        // 显示前16个字节的十六进制
        size_t previewLength = std::min(length, static_cast<size_t>(16));
        for (size_t i = 0; i < previewLength; i++)
        {
            oss << std::hex << std::uppercase << std::setw(2) << std::setfill('0') 
                << static_cast<int>(data[i]);
            if (i < previewLength - 1) oss << " ";
        }
        
        if (length > 16)
            oss << "...";
        
        return oss.str();
    }
    else
    {
        // 对于文本数据，直接转换为字符串并保持原始格式
        std::string result;
        result.reserve(length);
        
        for (size_t i = 0; i < length; i++)
        {
            uint8_t byte = data[i];
            
            // 保留所有可打印字符，包括UTF-8编码
            if (byte >= 32 && byte <= 126)  // ASCII可打印字符
            {
                result += static_cast<char>(byte);
            }
            else if (byte == '\t')  // 制表符
            {
                result += '\t';
            }
            else if (byte == '\r' || byte == '\n')  // 换行符
            {
                result += static_cast<char>(byte);
            }
            else if (byte >= 0x80)  // UTF-8多字节字符处理
            {
                // 直接添加UTF-8字节，让系统处理多字节序列
                // 注意：这里假设输入数据是有效的UTF-8序列
                result += static_cast<char>(byte);
            }
            else if (byte == 0x00)  // 空字节，在文本中可能存在
            {
                // 跳过空字节或用特殊字符表示
                continue;
            }
            else  // 其他控制字符
            {
                // 用点号替代不可见字符
                result += '.';
            }
        }
        
        return result;
    }
}

// 验证UTF-8字符序列的有效性（辅助函数）
bool DataFormatter::IsValidUtf8Sequence(const uint8_t* data, size_t maxLength)
{
    if (!data || maxLength == 0)
        return false;
        
    uint8_t firstByte = data[0];
    
    if (firstByte < 0x80)
        return true;  // ASCII字符
        
    // 确定UTF-8字符的字节数
    size_t byteCount = 0;
    if ((firstByte & 0xE0) == 0xC0)      // 110xxxxx - 2字节字符
        byteCount = 2;
    else if ((firstByte & 0xF0) == 0xE0) // 1110xxxx - 3字节字符
        byteCount = 3;
    else if ((firstByte & 0xF8) == 0xF0) // 11110xxx - 4字节字符
        byteCount = 4;
    else if ((firstByte & 0xC0) == 0x80) // 10xxxxxx - 后续字节
        return true;  // 假设这是一个有效的后续字节
    else
        return false;  // 无效的首字节
        
    // 检查是否有足够的字节
    if (maxLength < byteCount)
        return false;
        
    // 验证后续字节是否符合 10xxxxxx 格式
    for (size_t i = 1; i < byteCount; ++i)
    {
        if ((data[i] & 0xC0) != 0x80)
            return false;
    }
    
    return true;
}