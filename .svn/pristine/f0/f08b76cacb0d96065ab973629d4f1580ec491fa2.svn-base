#include "pch.h"
#include "ReliableChannel.h"
#include <fstream>
#include <sstream>
#include <filesystem>

ReliableChannel::ReliableChannel(std::shared_ptr<ITransport> transport)
    : m_transport(transport)
    , m_frameCodec()
    , m_state(RELIABLE_IDLE)
    , m_active(false)
    , m_receivingEnabled(true)
    , m_sendOffset(0)
    , m_sendSequence(1)
    , m_retryCount(0)
    , m_expectedSequence(1)
    , m_stopThread(false)
{
    // 设置传输层回调
    if (m_transport)
    {
        m_transport->SetDataReceivedCallback([this](const std::vector<uint8_t>& data) {
            OnDataReceived(data);
        });
    }
}

ReliableChannel::~ReliableChannel()
{
    Stop();
}

bool ReliableChannel::Start()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    if (m_active)
        return true;
    
    if (!m_transport)
    {
        SetError("传输层未初始化");
        return false;
    }
    
    // 启动传输层
    TransportConfig config; // 使用默认配置
    if (!m_transport->Open(config))
    {
        SetError("传输层启动失败");
        return false;
    }
    
    // 重置状态
    m_state = RELIABLE_IDLE;
    m_active = true;
    m_stopThread = false;
    m_lastAckedSequence = 0;
    
    // 启动协议处理线程
    m_protocolThread = std::thread(&ReliableChannel::ProtocolThreadFunc, this);
    
    return true;
}

void ReliableChannel::Stop()
{
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        if (!m_active)
            return;
        
        m_active = false;
        m_stopThread = true;
    }
    
    // 唤醒协议线程
    m_protocolCV.notify_all();
    
    // 等待协议线程结束
    if (m_protocolThread.joinable())
    {
        m_protocolThread.join();
    }
    
    // 关闭传输层
    if (m_transport)
    {
        m_transport->Close();
    }
    
    // 重置状态
    std::lock_guard<std::mutex> lock(m_mutex);
    m_state = RELIABLE_IDLE;
}

bool ReliableChannel::IsActive() const
{
    return m_active;
}

bool ReliableChannel::SendData(const std::vector<uint8_t>& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    if (!m_active || m_state != RELIABLE_IDLE)
    {
        SetError("通道未就绪或正在传输中");
        return false;
    }
    
    // 设置发送数据
    m_sendData = data;
    m_sendFilename = "[数据传输]"; // 标识为数据传输而非文件传输
    m_sendOffset = 0;
    m_sendSequence = 1;
    m_retryCount = 0;
    
    // 初始化统计信息
    m_stats = TransferStats();
    m_stats.totalBytes = data.size();
    m_stats.totalFrames = (data.size() + m_frameCodec.GetMaxPayloadSize() - 1) / m_frameCodec.GetMaxPayloadSize() + 2; // +2 for START and END
    
    // 开始发送
    SetState(RELIABLE_STARTING);
    m_protocolCV.notify_one();
    
    return true;
}

bool ReliableChannel::SendFile(const std::string& filePath)
{
    try
    {
        // 读取文件
        std::ifstream file(filePath, std::ios::binary | std::ios::ate);
        if (!file.is_open())
        {
            SetError("无法打开文件: " + filePath);
            return false;
        }
        
        auto fileSize = file.tellg();
        file.seekg(0, std::ios::beg);
        
        std::vector<uint8_t> fileData(static_cast<size_t>(fileSize));
        if (!file.read(reinterpret_cast<char*>(fileData.data()), fileSize))
        {
            SetError("文件读取失败");
            return false;
        }
        
        // 提取文件名
        std::string filename = std::filesystem::path(filePath).filename().string();
        
        return SendFile(filename, fileData);
    }
    catch (const std::exception& e)
    {
        SetError("文件操作异常: " + std::string(e.what()));
        return false;
    }
}

bool ReliableChannel::SendFile(const std::string& filename, const std::vector<uint8_t>& fileData)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    if (!m_active || m_state != RELIABLE_IDLE)
    {
        SetError("通道未就绪或正在传输中");
        return false;
    }
    
    // 设置发送数据
    m_sendData = fileData;
    m_sendFilename = filename;
    m_sendOffset = 0;
    m_sendSequence = 1;
    m_retryCount = 0;
    
    // 初始化统计信息
    m_stats = TransferStats();
    m_stats.totalBytes = fileData.size();
    m_stats.totalFrames = (fileData.size() + m_frameCodec.GetMaxPayloadSize() - 1) / m_frameCodec.GetMaxPayloadSize() + 2; // +2 for START and END
    
    // 开始发送
    SetState(RELIABLE_STARTING);
    m_protocolCV.notify_one();
    
    return true;
}

void ReliableChannel::EnableReceiving(bool enable)
{
    m_receivingEnabled = enable;
}

bool ReliableChannel::IsReceivingEnabled() const
{
    return m_receivingEnabled;
}

ReliableState ReliableChannel::GetState() const
{
    return m_state;
}

TransferStats ReliableChannel::GetStats() const
{
    std::lock_guard<std::mutex> lock(m_mutex);
    return m_stats;
}

std::string ReliableChannel::GetLastError() const
{
    std::lock_guard<std::mutex> lock(m_mutex);
    return m_lastError;
}

void ReliableChannel::ProtocolThreadFunc()
{
    while (!m_stopThread)
    {
        try
        {
            // 处理接收到的数据
            ProcessReceivedData();
            
            // 处理发送状态机
            if (m_state == RELIABLE_STARTING || m_state == RELIABLE_SENDING || m_state == RELIABLE_ENDING)
            {
                HandleSending();
            }
            
            // 处理接收状态机
            if (m_state == RELIABLE_READY || m_state == RELIABLE_RECEIVING)
            {
                HandleReceiving();
            }
            
            // 等待下一次处理
            std::unique_lock<std::mutex> lock(m_mutex);
            m_protocolCV.wait_for(lock, std::chrono::milliseconds(10));
        }
        catch (const std::exception& e)
        {
            SetError("协议线程异常: " + std::string(e.what()));
            SetState(RELIABLE_FAILED);
        }
    }
}

void ReliableChannel::OnDataReceived(const std::vector<uint8_t>& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    // 将接收到的数据添加到缓冲区
    m_receiveBuffer.insert(m_receiveBuffer.end(), data.begin(), data.end());
    
    // 唤醒协议线程处理数据
    m_protocolCV.notify_one();
}

void ReliableChannel::ProcessReceivedData()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    while (m_receiveBuffer.size() >= FrameCodec::MIN_FRAME_SIZE)
    {
        Frame frame;
        size_t consumedBytes;
        
        auto result = m_frameCodec.DecodeFrame(m_receiveBuffer, consumedBytes, frame);
        
        if (result == FrameCodec::DecodeResult::Success)
        {
            // 移除已处理的数据
            m_receiveBuffer.erase(m_receiveBuffer.begin(), m_receiveBuffer.begin() + consumedBytes);
            
            // 处理接收到的帧
            ProcessReceivedFrame(frame);
        }
        else if (result == FrameCodec::DecodeResult::Incomplete)
        {
            // 数据不完整，等待更多数据
            break;
        }
        else
        {
            // 帧无效，移除部分数据并继续
            if (consumedBytes > 0)
            {
                m_receiveBuffer.erase(m_receiveBuffer.begin(), m_receiveBuffer.begin() + consumedBytes);
                m_stats.crcErrors++;
            }
            else
            {
                // 如果没有消费任何数据，移除第一个字节避免死循环
                m_receiveBuffer.erase(m_receiveBuffer.begin());
            }
        }
    }
}

void ReliableChannel::ProcessReceivedFrame(const Frame& frame)
{
    switch (frame.type)
    {
    case FRAME_START:
        if (m_receivingEnabled && (m_state == RELIABLE_IDLE || 
            m_state == RELIABLE_STARTING || m_state == RELIABLE_SENDING || m_state == RELIABLE_ENDING))
        {
            // 解析START帧元数据
            if (m_receiveMetadata.Deserialize(frame.payload))
            {
                m_receivedFilename = m_receiveMetadata.filename;
                m_receivedData.clear();
                m_receivedData.reserve(static_cast<size_t>(m_receiveMetadata.fileSize));
                m_expectedSequence = 2; // 下一个期望的DATA帧序号
                
                // 在本地回环模式下，不覆盖发送状态，只在真正空闲时设置接收状态
                if (m_state == RELIABLE_IDLE)
                {
                    // 初始化接收统计
                    m_stats = TransferStats();
                    m_stats.totalBytes = static_cast<size_t>(m_receiveMetadata.fileSize);
                    SetState(RELIABLE_RECEIVING);
                }
                
                SendAck(frame.sequence);
            }
            else
            {
                SendNak(frame.sequence);
            }
        }
        break;
        
    case FRAME_DATA:
        if (m_state == RELIABLE_RECEIVING || 
            (m_receivingEnabled && m_expectedSequence > 1)) // 本地回环：已开始接收过程
        {
            if (frame.sequence == m_expectedSequence)
            {
                // 按序接收数据
                m_receivedData.insert(m_receivedData.end(), frame.payload.begin(), frame.payload.end());
                
                // 在本地回环模式下，避免覆盖发送端的统计信息
                if (m_state == RELIABLE_RECEIVING)
                {
                    m_stats.transferredBytes += frame.payload.size();
                    UpdateProgress();
                }
                
                m_expectedSequence++;
                SendAck(frame.sequence);
            }
            else if (frame.sequence < m_expectedSequence)
            {
                // 重复帧，直接ACK
                SendAck(frame.sequence);
            }
            else
            {
                // 乱序，发送NAK
                SendNak(m_expectedSequence);
            }
        }
        break;
        
    case FRAME_END:
        if (m_state == RELIABLE_RECEIVING || 
            (m_receivingEnabled && m_expectedSequence > 1)) // 本地回环：已开始接收过程
        {
            if (frame.sequence == m_expectedSequence)
            {
                SendAck(frame.sequence);
                
                // 只有在接收状态时才完成接收
                if (m_state == RELIABLE_RECEIVING)
                {
                    CompleteReceive();
                }
                else
                {
                    // 本地回环模式：直接调用文件接收回调
                    if (m_fileReceivedCallback)
                    {
                        m_fileReceivedCallback(m_receivedFilename, m_receivedData);
                    }
                    
                    // 重置接收状态
                    m_expectedSequence = 1;
                    m_receivedData.clear();
                    m_receivedFilename.clear();
                }
            }
            else
            {
                SendNak(m_expectedSequence);
            }
        }
        break;
        
    case FRAME_ACK:
        if (m_state == RELIABLE_STARTING || m_state == RELIABLE_SENDING || m_state == RELIABLE_ENDING)
        {
            if (frame.sequence == m_sendSequence)
            {
                // 收到期望的ACK，标记并继续下一步
                m_lastAckedSequence = frame.sequence;
                m_protocolCV.notify_one();
            }
        }
        break;
        
    case FRAME_NAK:
        if (m_state == RELIABLE_STARTING || m_state == RELIABLE_SENDING || m_state == RELIABLE_ENDING)
        {
            // 收到NAK，重传当前帧
            m_stats.retransmissions++;
            m_protocolCV.notify_one();
        }
        break;
    }
}

void ReliableChannel::HandleSending()
{
    switch (m_state)
    {
    case RELIABLE_STARTING:
        SendStartFrame();
        break;
    case RELIABLE_SENDING:
        SendDataFrame();
        break;
    case RELIABLE_ENDING:
        SendEndFrame();
        break;
    default:
        break;
    }
}

void ReliableChannel::SendStartFrame()
{
    // 创建START帧元数据
    StartMetadata metadata;
    metadata.version = 1;
    metadata.flags = 0;
    metadata.filename = m_sendFilename;
    metadata.fileSize = m_sendData.size();
    metadata.modifyTime = 0; // 可以设置为当前时间
    
    Frame startFrame = FrameCodec::CreateStartFrame(m_sendSequence, metadata);
    
    if (SendFrame(startFrame))
    {
        if (WaitForAck(m_sendSequence))
        {
            m_sendSequence++;
            m_stats.sentFrames++;
            SetState(RELIABLE_SENDING);
            m_retryCount = 0;
        }
        else
        {
            // 超时或重传失败
            if (++m_retryCount >= m_maxRetries)
            {
                SetError("START帧发送失败，超过最大重试次数");
                SetState(RELIABLE_FAILED);
                NotifyCompletion(false, "传输失败");
            }
            // 否则会在下次循环中重试
        }
    }
    else
    {
        SetError("START帧发送失败");
        SetState(RELIABLE_FAILED);
        NotifyCompletion(false, "传输失败");
    }
}

void ReliableChannel::SendDataFrame()
{
    size_t maxPayload = m_frameCodec.GetMaxPayloadSize();
    size_t remainingBytes = m_sendData.size() - m_sendOffset;
    
    if (remainingBytes == 0)
    {
        // 所有数据已发送，进入结束阶段
        SetState(RELIABLE_ENDING);
        return;
    }
    
    // 创建DATA帧
    size_t chunkSize = (maxPayload < remainingBytes) ? maxPayload : remainingBytes;
    std::vector<uint8_t> chunk(m_sendData.begin() + m_sendOffset, 
                              m_sendData.begin() + m_sendOffset + chunkSize);
    
    Frame dataFrame = FrameCodec::CreateDataFrame(m_sendSequence, chunk);
    
    if (SendFrame(dataFrame))
    {
        if (WaitForAck(m_sendSequence))
        {
            m_sendOffset += chunkSize;
            m_sendSequence++;
            m_stats.sentFrames++;
            m_stats.transferredBytes += chunkSize;
            m_retryCount = 0;
            
            UpdateProgress();
        }
        else
        {
            // 超时或重传失败
            if (++m_retryCount >= m_maxRetries)
            {
                SetError("DATA帧发送失败，超过最大重试次数");
                SetState(RELIABLE_FAILED);
                NotifyCompletion(false, "传输失败");
            }
            // 否则会在下次循环中重试
        }
    }
    else
    {
        SetError("DATA帧发送失败");
        SetState(RELIABLE_FAILED);
        NotifyCompletion(false, "传输失败");
    }
}

void ReliableChannel::SendEndFrame()
{
    Frame endFrame = FrameCodec::CreateEndFrame(m_sendSequence);
    
    if (SendFrame(endFrame))
    {
        if (WaitForAck(m_sendSequence))
        {
            m_stats.sentFrames++;
            SetState(RELIABLE_DONE);
            NotifyCompletion(true, "传输完成");
            
            // 重置到空闲状态
            SetState(RELIABLE_IDLE);
        }
        else
        {
            // 超时或重传失败
            if (++m_retryCount >= m_maxRetries)
            {
                SetError("END帧发送失败，超过最大重试次数");
                SetState(RELIABLE_FAILED);
                NotifyCompletion(false, "传输失败");
            }
            // 否则会在下次循环中重试
        }
    }
    else
    {
        SetError("END帧发送失败");
        SetState(RELIABLE_FAILED);
        NotifyCompletion(false, "传输失败");
    }
}

bool ReliableChannel::WaitForAck(uint16_t sequence)
{
    std::unique_lock<std::mutex> lock(m_mutex);
    
    // 使用条件变量等待，确保及时响应ACK
    bool ackReceived = m_protocolCV.wait_for(lock, 
        std::chrono::milliseconds(m_ackTimeoutMs),
        [this, sequence] { 
            return m_lastAckedSequence == sequence || !m_active; 
        });
    
    if (!ackReceived && m_active)
    {
        m_stats.timeouts++;
        return false; // 超时
    }
    
    return m_lastAckedSequence == sequence; // 成功收到ACK或通道已关闭
}

void ReliableChannel::HandleReceiving()
{
    // 接收状态机主要在ProcessReceivedFrame中处理
    // 这里可以添加接收超时检查等逻辑
}

void ReliableChannel::SendAck(uint16_t sequence)
{
    Frame ackFrame = FrameCodec::CreateAckFrame(sequence);
    SendFrame(ackFrame);
}

void ReliableChannel::SendNak(uint16_t sequence)
{
    Frame nakFrame = FrameCodec::CreateNakFrame(sequence);
    SendFrame(nakFrame);
}

void ReliableChannel::CompleteReceive()
{
    // 验证接收到的数据大小
    if (m_receivedData.size() != static_cast<size_t>(m_receiveMetadata.fileSize))
    {
        AbortReceive("接收数据大小不匹配");
        return;
    }
    
    // 保存文件
    if (SaveReceivedFile())
    {
        SetState(RELIABLE_DONE);
        
        // 通知文件接收完成
        if (m_fileReceivedCallback)
        {
            m_fileReceivedCallback(m_receivedFilename, m_receivedData);
        }
        
        NotifyCompletion(true, "文件接收完成: " + m_receivedFilename);
    }
    else
    {
        AbortReceive("文件保存失败");
    }
    
    // 重置到空闲状态
    SetState(RELIABLE_IDLE);
}

void ReliableChannel::AbortReceive(const std::string& reason)
{
    SetError(reason);
    SetState(RELIABLE_FAILED);
    NotifyCompletion(false, "接收失败: " + reason);
    
    // 清理状态
    m_receivedData.clear();
    m_receivedFilename.clear();
    
    // 重置到空闲状态
    SetState(RELIABLE_IDLE);
}

void ReliableChannel::SetState(ReliableState state)
{
    m_state = state;
}

void ReliableChannel::SetError(const std::string& error)
{
    m_lastError = error;
}

void ReliableChannel::UpdateProgress()
{
    if (m_progressCallback)
    {
        m_progressCallback(m_stats);
    }
}

void ReliableChannel::NotifyCompletion(bool success, const std::string& message)
{
    if (m_completionCallback)
    {
        m_completionCallback(success, message);
    }
}

std::string ReliableChannel::GenerateUniqueFilename(const std::string& originalName)
{
    std::string directory = m_receiveDirectory.empty() ? "." : m_receiveDirectory;
    std::string basePath = directory + "/" + originalName;
    
    // 如果文件不存在，直接使用原名
    if (!std::filesystem::exists(basePath))
    {
        return basePath;
    }
    
    // 生成唯一文件名
    std::string name = std::filesystem::path(originalName).stem().string();
    std::string ext = std::filesystem::path(originalName).extension().string();
    
    for (int i = 1; i < 1000; ++i)
    {
        std::string newName = name + "(" + std::to_string(i) + ")" + ext;
        std::string newPath = directory + "/" + newName;
        
        if (!std::filesystem::exists(newPath))
        {
            return newPath;
        }
    }
    
    // 如果仍然冲突，使用时间戳
    auto now = std::chrono::system_clock::now();
    auto timestamp = std::chrono::duration_cast<std::chrono::seconds>(now.time_since_epoch()).count();
    return directory + "/" + name + "_" + std::to_string(timestamp) + ext;
}

bool ReliableChannel::SaveReceivedFile()
{
    try
    {
        std::string filePath = GenerateUniqueFilename(m_receivedFilename);
        
        // 确保目录存在
        std::filesystem::path parentDir = std::filesystem::path(filePath).parent_path();
        if (!parentDir.empty() && !std::filesystem::exists(parentDir))
        {
            std::filesystem::create_directories(parentDir);
        }
        
        // 写入文件
        std::ofstream file(filePath, std::ios::binary);
        if (!file.is_open())
        {
            SetError("无法创建文件: " + filePath);
            return false;
        }
        
        file.write(reinterpret_cast<const char*>(m_receivedData.data()), m_receivedData.size());
        file.close();
        
        if (file.fail())
        {
            SetError("文件写入失败: " + filePath);
            return false;
        }
        
        return true;
    }
    catch (const std::exception& e)
    {
        SetError("文件保存异常: " + std::string(e.what()));
        return false;
    }
}

bool ReliableChannel::SendFrame(const Frame& frame)
{
    if (!m_transport || !m_transport->IsOpen())
    {
        return false;
    }
    
    try
    {
        std::vector<uint8_t> frameData = m_frameCodec.EncodeFrame(frame);
        size_t bytesWritten = m_transport->Write(frameData.data(), frameData.size());
        return bytesWritten == frameData.size();
    }
    catch (const std::exception& e)
    {
        SetError("帧发送异常: " + std::string(e.what()));
        return false;
    }
}