#include "pch.h"
#include "DataFormatter.h"
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <cctype>

const char* DataFormatter::HEX_CHARS = "0123456789ABCDEF";

std::string DataFormatter::BytesToHex(const std::vector<uint8_t>& data, bool addSpaces)
{
    return BytesToHex(data.data(), data.size(), addSpaces);
}

std::string DataFormatter::BytesToHex(const uint8_t* data, size_t length, bool addSpaces)
{
    if (!data || length == 0)
        return "";
    
    std::string result;
    result.reserve(length * (addSpaces ? 3 : 2));
    
    for (size_t i = 0; i < length; i++)
    {
        if (i > 0 && addSpaces)
            result += ' ';
        
        result += HEX_CHARS[(data[i] >> 4) & 0x0F];
        result += HEX_CHARS[data[i] & 0x0F];
    }
    
    return result;
}

std::vector<uint8_t> DataFormatter::HexToBytes(const std::string& hex)
{
    std::vector<uint8_t> result;
    std::string cleanHex = CleanHexInput(hex);
    
    if (cleanHex.empty() || cleanHex.length() % 2 != 0)
        return result;
    
    result.reserve(cleanHex.length() / 2);
    
    for (size_t i = 0; i < cleanHex.length(); i += 2)
    {
        int high = HexCharToValue(cleanHex[i]);
        int low = HexCharToValue(cleanHex[i + 1]);
        
        if (high == -1 || low == -1)
            return std::vector<uint8_t>(); // 无效字符
        
        result.push_back(static_cast<uint8_t>((high << 4) | low));
    }
    
    return result;
}

std::string DataFormatter::BytesToText(const std::vector<uint8_t>& data)
{
    return BytesToText(data.data(), data.size());
}

std::string DataFormatter::BytesToText(const uint8_t* data, size_t length)
{
    if (!data || length == 0)
        return "";
    
    std::string result;
    result.reserve(length);
    
    for (size_t i = 0; i < length; i++)
    {
        if (IsPrintable(data[i]))
            result += static_cast<char>(data[i]);
        else
            result += '.';
    }
    
    return result;
}

std::vector<uint8_t> DataFormatter::TextToBytes(const std::string& text)
{
    std::vector<uint8_t> result;
    result.reserve(text.length());
    
    for (char c : text)
    {
        result.push_back(static_cast<uint8_t>(c));
    }
    
    return result;
}

bool DataFormatter::IsValidHex(const std::string& hex)
{
    std::string cleanHex = CleanHexInput(hex);
    
    if (cleanHex.empty() || cleanHex.length() % 2 != 0)
        return false;
    
    for (char c : cleanHex)
    {
        if (HexCharToValue(c) == -1)
            return false;
    }
    
    return true;
}

std::string DataFormatter::FormatHexDump(const std::vector<uint8_t>& data, int bytesPerLine)
{
    if (data.empty())
        return "";
    
    std::ostringstream oss;
    
    for (size_t i = 0; i < data.size(); i += bytesPerLine)
    {
        // 地址列 - 使用8位16进制地址
        oss << std::hex << std::uppercase << std::setw(8) << std::setfill('0') << i << ":  ";
        
        // 十六进制列 - 每行16字节，中间分隔
        for (int j = 0; j < bytesPerLine; j++)
        {
            if (i + j < data.size())
            {
                oss << std::hex << std::uppercase << std::setw(2) << std::setfill('0') 
                    << static_cast<int>(data[i + j]);
            }
            else
            {
                oss << "  ";
            }
            
            // 添加适当的分隔符
            if (j == 7) {
                oss << "  ";  // 中间8字节分隔
            } else if (j < bytesPerLine - 1) {
                oss << " ";   // 字节间分隔
            }
        }
        
        // ASCII列前的分隔符
        oss << "  |";
        
        // ASCII列
        for (int j = 0; j < bytesPerLine && i + j < data.size(); j++)
        {
            uint8_t byte = data[i + j];
            oss << (IsPrintable(byte) ? static_cast<char>(byte) : '.');
        }
        oss << "|\r\n";
    }
    
    return oss.str();
}

std::string DataFormatter::CleanHexInput(const std::string& input)
{
    std::string result;
    result.reserve(input.length());
    
    for (char c : input)
    {
        if (std::isxdigit(c))
        {
            result += std::toupper(c);
        }
    }
    
    return result;
}

bool DataFormatter::IsPrintable(uint8_t c)
{
    return (c >= 32 && c <= 126) || c == '\t';
}

int DataFormatter::HexCharToValue(char c)
{
    if (c >= '0' && c <= '9')
        return c - '0';
    else if (c >= 'A' && c <= 'F')
        return c - 'A' + 10;
    else if (c >= 'a' && c <= 'f')
        return c - 'a' + 10;
    else
        return -1;
}

char DataFormatter::ValueToHexChar(int value)
{
    if (value >= 0 && value <= 15)
        return HEX_CHARS[value];
    else
        return '?';
}