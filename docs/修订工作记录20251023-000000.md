# 修订工作记录 - 本地回路传输按钮交互与崩溃修复

## 修订概述
- **开始时间**: 2025-10-23 00:00:00
- **修订目标**: 解决本地回路模式下大文件发送时的按钮交互异常和程序关闭导致的崩溃/假死问题
- **预期成果**: 实现完整的传输状态机，支持运行/暂停/继续/停止的完整交互流程，确保无阻塞取消和优雅关闭

## 问题详细分析

### 问题描述
根据 `PortMaster_本地回路测试问题分析报告20251022-183547.md` 的诊断：

1. **"发送/中断"按钮无法响应**
   - 源文件：`src/PortMasterDlg.cpp:699-704` 和 `src/DialogUiController.cpp:204-220`
   - 现象：虽然按钮文本被改为"中断"或"继续"，但按钮保持禁用状态
   - 原因：`UpdateTransmissionButtons` 仅以 `transmitting` 为禁用条件，忽略 `paused` 参数
   - 影响：用户无法暂停/恢复传输，只能依赖"停止"按钮

2. **停止/关闭时程序被阻塞直至崩溃**
   - 源文件：`src/TransmissionCoordinator.cpp:84-90` 和 `src/TransmissionTask.cpp:107-131`
   - 现象：点击停止或关闭窗口后，UI 线程长时间无响应，最终导致程序崩溃或被强制结束
   - 原因：`TransmissionTask::Stop()` 在 UI 线程同步调用 `join()` 等待工作线程，但 Loopback 工作线程因队列数据未完全处理而未立即终止
   - 影响：UI 线程被阻塞，所有操作无响应，关闭应用导致进程被强制结束

### 根本原因分析
1. **UI 状态驱动缺陷**：UI 状态转换由多个入口点独立管理（`StartTransmission`、`PauseTransmission`、`ResumeTransmission` 等），每个入口都直接调用 `UpdateTransmissionButtons()`，导致状态不一致
2. **同步阻塞取消**：`TransmissionCoordinator::Cancel()` 同步执行 `m_currentTask->Cancel()` 和 `m_currentTask.reset()`，其中 `Stop()` 在 UI 线程同步 `join()` 工作线程，代价过高
3. **生命周期管理混乱**：资源回收（reset）与线程退出不同步，导致回调在资源释放后继续执行

### 解决方案设计
基于分析报告的最优方案，采用**三层改造**：

1. **第一层：状态机设计**
   - 新增枚举 `TransmissionUiState { Idle = 0, Running = 1, Paused = 2, Cancelling = 3 }`
   - 由单一函数 `ApplyTransmissionState(TransmissionUiState state)` 统一驱动所有 UI 更新
   - 每次状态变化都经由此函数，确保 UI 一致性

2. **第二层：UI 按钮逻辑**
   - Running 状态：发送按钮**启用**，文本"中断"；停止按钮启用；文件按钮禁用
   - Paused 状态：发送按钮**启用**，文本"继续"；停止按钮启用；文件按钮禁用
   - Cancelling 状态：发送按钮禁用，停止按钮禁用；状态栏提示"正在停止…"
   - Idle 状态：发送按钮启用，文本"发送"；停止按钮禁用；文件按钮启用

3. **第三层：异步取消流程**
   - `TransmissionCoordinator::Cancel()` 改为非阻塞：仅置 `cancelRequested = true`，调用 `m_currentTask->Cancel()`，**不立即 reset**
   - 资源回收延迟至后台线程完全退出后执行
   - `TransmissionTask::Stop()` 改为发送 PostMessage 而非同步 join，UI 线程立即返回

## 修订计划安排

### 阶段一：状态机定义与头文件修改
- [ ] 任务1：在 `DialogUiController.h` 中新增 `TransmissionUiState` 枚举
- [ ] 任务2：在 `DialogUiController.h` 中新增 `ApplyTransmissionState(state)` 方法声明
- [ ] 任务3：在 `DialogUiController.h` 中保留原 `UpdateTransmissionButtons()` 方法但标记为内部使用

### 阶段二：DialogUiController 实现改造
- [ ] 任务1：实现 `ApplyTransmissionState()` 方法，完整处理所有四种状态下的按钮启禁和文本更新
- [ ] 任务2：修改原 `UpdateTransmissionButtons()` 方法，调整为由 `ApplyTransmissionState()` 内部调用，不再接收 `transmitting`/`paused` 参数
- [ ] 任务3：验证所有按钮启禁逻辑符合分析报告第6部分的要求

### 阶段三：PortMasterDlg 状态驱动改造
- [ ] 任务1：在 `CPortMasterDlg` 中添加成员变量 `TransmissionUiState m_currentTransmissionState = Idle`
- [ ] 任务2：修改 `StartTransmission()` 仅调用 `m_uiController->ApplyTransmissionState(Running)`
- [ ] 任务3：修改 `PauseTransmission()` 仅调用 `m_uiController->ApplyTransmissionState(Paused)`
- [ ] 任务4：修改 `ResumeTransmission()` 仅调用 `m_uiController->ApplyTransmissionState(Running)`
- [ ] 任务5：修改 `HandleStop()` 改为调用 `m_uiController->ApplyTransmissionState(Cancelling)`

### 阶段四：TransmissionCoordinator 异步取消改造
- [ ] 任务1：修改 `Cancel()` 方法，仅置 `cancelRequested = true`，调用 `m_currentTask->Cancel()`，**不执行** `m_currentTask.reset()`
- [ ] 任务2：新增 `CleanupTransmissionTask()` 方法，在此方法中执行 `m_currentTask.reset()`
- [ ] 任务3：验证异步流程不会导致二次调用或资源泄漏

### 阶段五：TransmissionTask 异步停止改造
- [ ] 任务1：修改 `Stop()` 方法，改为向主线程 PostMessage（不再同步 join）
- [ ] 任务2：确保工作线程自身检查 `m_cancelled` 标志并正常退出，不依赖 UI 线程的强制 join
- [ ] 任务3：验证工作线程退出日志正常输出："传输任务已停止"

### 阶段六：关闭流程兼容改造
- [ ] 任务1：修改 `ShutdownActiveTransmission()` 的关闭逻辑
- [ ] 任务2：若状态为 Cancelling，等待完成信号；若状态为 Idle 则直接继续
- [ ] 任务3：避免 UI 线程长时间阻塞，设置超时提示

### 阶段七：完整回路测试验证
- [ ] 测试场景1：回路大文件（>1MB）发送完整流程：发送→中断→继续→停止，验证所有按钮保持可操作
- [ ] 测试场景2：发送过程中关闭窗口，应弹出"正在停止"提示后正常退出，无卡死
- [ ] 测试场景3：验证日志输出完整，包含"传输任务完成"和"后台传输线程结束"
- [ ] 回归测试：普通串口/网络模式发送，确认状态机不误禁用按钮

## 修订执行记录

### 环境信息
- 工作目录：`/mnt/c/Users/huangl/Desktop/PortMaster`
- 当前分支：`fix/reliable-transfer-progress`
- 编译命令：`autobuild_x86_debug.bat`（跨环境支持）
- 测试方式：本地回路模式大文件传输

### 逐阶段执行记录

#### 阶段一：状态机定义与头文件修改
- ✅ **11:00**: 阶段一完成 - 添加 TransmissionUiState 枚举和 ApplyTransmissionState() 方法

**修改内容：**
1. `src/DialogUiController.h`：
   - 新增 `TransmissionUiState` 枚举 (Idle, Running, Paused, Cancelling)
   - 新增 `ApplyTransmissionState(TransmissionUiState state)` 方法声明
   - 添加成员变量 `TransmissionUiState m_currentTransmissionState`

2. `src/DialogUiController.cpp`：
   - 实现 `ApplyTransmissionState()` 方法，完整处理四种状态：
     - **Idle**：发送按钮启用+文本"发送"，停止禁用，文件启用
     - **Running**：发送按钮启用+文本"中断"，停止启用，文件禁用
     - **Paused**：发送按钮启用+文本"继续"，停止启用，文件禁用
     - **Cancelling**：发送/停止/文件全禁用，状态栏提示"正在停止…"

**验证检查点（对应分析报告 4.1）：**
- [x] 新增状态机枚举，四种状态完整
- [x] Running/Paused 状态下，发送按钮均为启用
- [x] Cancelling 状态下，两个按钮均禁用
- [x] 各状态按钮文本设置正确

#### 阶段二：DialogUiController 实现改造
- ⏳ **待开始**

#### 阶段三：PortMasterDlg 状态驱动改造
- ⏳ **待开始**

#### 阶段四：TransmissionCoordinator 异步取消改造
- ⏳ **待开始**

#### 阶段五：TransmissionTask 异步停止改造
- ⏳ **待开始**

#### 阶段六：关闭流程兼容改造
- ⏳ **待开始**

#### 阶段四/五/六：异步取消流程改造（核心改造）
- ✅ **11:30**: 完成异步取消流程改造 - 实现非阻塞取消和延迟清理

**修改内容：**
1. `src/TransmissionTask.cpp`：
   - 修改 `Stop()` 方法，移除同步 `join()` 调用
   - 工作线程自行检查 Cancelled 状态并安全退出
   - 不再在 UI 线程中阻塞等待

2. `src/TransmissionCoordinator.h/cpp`：
   - 修改 `Cancel()` 改为非阻塞，不立即 reset
   - 新增 `CleanupTransmissionTask()` 方法，延迟清理资源

3. `src/PortMasterDlg.cpp`：
   - 修改 `OnTransmissionComplete()` 末尾调用 `CleanupTransmissionTask()`
   - 修改 `ShutdownActiveTransmission()` 为超时轮询而非阻塞等待
   - 改进关闭流程，避免窗口卡顿

4. `src/PortMasterDialogEvents.cpp`：
   - 修改 `HandleStop()` 设置 `Cancelling` 状态

**验证检查点（对应分析报告 4.2）：**
- [x] TransmissionCoordinator::Cancel() 改为非阻塞
- [x] TransmissionTask::Stop() 不再同步 join
- [x] 工作线程自行退出，通过完成回调通知 UI
- [x] 延迟 reset 至完成消息处理后执行
- [x] 关闭流程改为超时轮询，避免阻塞

#### 阶段七：完整回路测试验证
- ⏳ **待验证**

## 验证检查点

### 按钮交互验证清单（对应分析报告 4.1）
- [ ] UpdateTransmissionButtons 中 Running 状态发送按钮为启用
- [ ] UpdateTransmissionButtons 中 Paused 状态发送按钮为启用
- [ ] HandleSend() 能正确识别 Paused 状态并调用 Resume()
- [ ] StartTransmission 后立即调用 ApplyTransmissionState(Running)

### 取消流程验证清单（对应分析报告 4.2）
- [ ] TransmissionCoordinator::Cancel() 不再执行 reset
- [ ] TransmissionTask::Stop() 不再在 UI 线程同步 join
- [ ] 工作线程自身检查 m_cancelled 标志并正常退出
- [ ] 日志中出现"传输任务已停止"和"后台传输线程结束"

### 完整流程验证清单（对应分析报告 7）
- [ ] 回路大文件：发送→中断→继续→停止，所有按钮保持可操作
- [ ] 关闭窗口：在传输过程中点击关闭，弹出"正在停止"提示后正常退出
- [ ] 构建日志：无任何编译 warning 或 error
- [ ] 进程监控：无假死、无卡顿、无强制结束

## 技术总结

（待修订完成后填写）

