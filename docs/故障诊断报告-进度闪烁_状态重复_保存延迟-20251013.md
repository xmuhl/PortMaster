# 回路测试可靠模式故障诊断报告（进度条闪烁、状态重复、保存延迟）

**报告日期**: 2025-10-13  
**适用场景**: 本地回路测试端口（可靠模式）进行大文件传输与保存的手动测试  
**相关文件**: `build/Debug/PortMaster_debug.log`

---

## 1. 问题现象

- 进度条显示异常：主进度条能正常前进，但似乎存在一个覆盖在上方的闪烁进度条。
- 状态提示信息重复：出现类似“正在传输：875520/1113432字节（78%）：875520/1113432字节（78%）”的文本。
- 保存功能延迟异常：传输结束后延迟数秒才显示可点击的“保存”按钮，但点击后提示“没有数据可保存”。

---

## 2. 可能原因分析

### 2.1 进度条闪烁与“覆盖”现象

- 双路进度更新导致重入与覆盖：
  - 传输任务路径通过消息队列更新进度（UI线程安全）：
    - `OnTransmissionProgress()` → `PostMessage(WM_USER + 11, 进度百分比)` → `OnTransmissionProgressUpdate()` → `m_progress.SetPos(...)`。
  - 协议路径直接在回调中更新进度（可能来自非UI线程）：
    - `ReliableChannel::SetProgressCallback(OnReliableProgress)` → `OnReliableProgress()` → 直接调用 `m_progress.SetPos(percent)`（`src/PortMasterDlg.cpp:3673-3699`）。
  - 两条路径同时作用于同一个控件 `m_progress`，且一条可能不在UI线程，造成绘制竞争与重入刷新，表现为进度条“闪烁”或被“覆盖”。
- 进度值来源不同步：
  - 发送侧 ACK 驱动与接收侧窗口推进在不同节奏报告进度，可能进度短时间内来回跳变，进一步加剧闪烁。

### 2.2 状态提示信息重复

- 传输任务在后台已构造完整的状态字符串：
  - `TransmissionTask::ExecuteTransmission()` 在调用 `UpdateProgress(...)` 时已生成“正在传输: X/Y 字节 (P%)”（`src/TransmissionTask.cpp:295-336`）。
- UI层再次拼接相同信息：
  - `OnTransmissionProgress()` 将 `progress.statusText` 作为前缀，再次附加“X/Y 字节 (P%)”，导致重复（`src/PortMasterDlg.cpp:700-723`）。

### 2.3 保存延迟与“没有数据可保存”

- 保存按钮延迟：
  - 传输完成后，`OnReliableComplete()` 设置若干重试定时器（100/200/300ms）以跨越状态同步窗口，再调用 `UpdateSaveButtonStatus()` 启用按钮，存在预期的短延迟（`src/PortMasterDlg.cpp:3700-3738`）。
- 点击保存提示“没有数据可保存”的可能触发条件：
  - 临时缓存不可用判定过于严格：`tempFileAvailable = PathFileExists(m_tempCacheFilePath) && (m_totalReceivedBytes > 0)`（`src/PortMasterDlg.cpp:2740-2760`），若 `m_totalReceivedBytes` 在某路径被重置或未及时更新，即使临时文件非空也会判为不可用。
  - 清空接收或停止操作会重置统计：`ClearTempCacheFile()` 会将临时文件截断并将 `m_totalReceivedBytes = 0`（`src/PortMasterDlg.cpp:4682-4710`），导致后续保存路径判定“无数据”。
  - 仅依赖内存缓存：若 `m_receiveDataCache` 未及时累积或被清理，且显示编辑框为空，则 `isBinaryMode=false && saveData.IsEmpty()` → 进入“没有数据可保存”分支（`src/PortMasterDlg.cpp:2943-2951`）。
  - 等待稳定流程仍存在：保存流程仍调用 `WaitForReceiveDataStability()`（`src/PortMasterDlg.cpp:2799-2819`），在某些时序下可能延迟读取或判定源不可用。

---

## 3. 相关代码段定位

- 进度条双路更新：
  - 消息队列路径（UI线程安全）
    - `OnTransmissionProgress()` → `PostMessage(WM_USER + 11, ...)`（`src/PortMasterDlg.cpp:706-713`）。
    - `OnTransmissionProgressUpdate()` → `m_progress.SetPos(...)`（`src/PortMasterDlg.cpp:3899-3907`）。
  - 直接回调路径（可能非UI线程）
    - `OnReliableProgress()` → `m_progress.SetPos(percent)`（`src/PortMasterDlg.cpp:3673-3699`）。

- 状态重复文本构造：
  - 后台已生成“正在传输: X/Y 字节 (P%)”：`src/TransmissionTask.cpp:295-336`。
  - UI层再次拼接相同信息：`src/PortMasterDlg.cpp:714-723`。

- 保存按钮状态与延迟：
  - 传输完成后设置定时器并刷新保存按钮：`src/PortMasterDlg.cpp:3700-3738`。
  - 保存入口的数据源判定与稳定性检查：`src/PortMasterDlg.cpp:2703-2819`、`src/PortMasterDlg.cpp:4745-4815`。
  - 清除/停止对临时缓存与统计的影响：
    - 清空接收按钮 → `ClearTempCacheFile()`（`src/PortMasterDlg.cpp:2469-2490`）。
    - 停止传输 → `ClearAllCacheData()` → `ClearTempCacheFile()`（`src/PortMasterDlg.cpp:2378-2430`）。
    - 清理函数重置 `m_totalReceivedBytes`：`src/PortMasterDlg.cpp:4682-4710`。

---

## 4. 解决方案建议（本次仅建议，未改代码）

### 4.1 统一进度更新路径
- 只允许 UI 线程通过消息队列更新 `m_progress`：
  - 将 `OnReliableProgress()` 的 `m_progress.SetPos(percent)` 改为 `PostMessage(WM_USER + 11, 0, percent)`，与传输任务路径保持一致，避免非UI线程直接触控控件。
  - 或者集中由 `ThreadSafeProgressManager` 触发 UI 消息进行更新，严禁直接控件调用。

### 4.2 规范状态文本拼接
- 保持单一来源：
  - 选择其一：
    - UI层仅显示 `progress.statusText`（后台已含“正在传输: ...”），不再追加“X/Y 字节 (P%)”。
    - 或后台只传递原始数值，UI层统一构造状态文本，避免重复。

### 4.3 提升保存判断的鲁棒性与交互体验
- 数据源判定优先使用文件大小：
  - 将 `tempFileAvailable` 的判定改为 `PathFileExists && GetTempCacheFileSize() > 0`，不要依赖 `m_totalReceivedBytes`，避免误判不可用。
- 降低保存延迟：
  - 当 `m_hasCompletedFile || (!m_isTransmitting && GetTempCacheFileSize()>0)` 时立即启用保存按钮，减少对重试定时器的依赖。
- 防止误清空导致“无数据可保存”：
  - 明确“清空接收”“停止传输”后保存不可用的行为提示，或在对话框中提示数据已被清空。
  - 保存前的稳定性检查可缩短或由用户选择跳过（提供“立即保存/等待稳定后保存”选项）。

### 4.4 日志与进度来源的协调
- 仅以接收侧实际落盘字节为“保存数据量”的依据，发送侧 ACK 驱动的进度不影响保存判定。
- 在 `OnReliableComplete()` 后增加一次“数据源快照”检测（内存缓存大小、临时文件大小），记录到日志并用于按钮启用逻辑。

---

## 5. 结论

- 进度条闪烁主要由“非UI线程直接设置进度控件”与“双路进度来源竞争”导致，需统一到消息队列的UI更新路径。
- 状态文本重复由“后台已带前缀+UI再度拼接”造成，规范拼接策略即可消除。
- 保存延迟与“没有数据可保存”由“启用逻辑的定时器窗口”和“数据源判定依赖统计值/被清空”共同触发，建议以文件大小为主要依据并优化交互提示。

（本次报告仅进行分析与建议，未修改源码。）