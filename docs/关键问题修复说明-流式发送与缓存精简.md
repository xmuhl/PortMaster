# 关键问题修复说明：流式发送与缓存精简

## 📌 问题根源

### 问题 1：虚假的"完整缓存"声称

**现状代码**：
```cpp
// src/PortMasterDialogEvents.cpp:638-652
const ULONGLONG MAX_CACHE_SIZE = 512ULL * 1024 * 1024;  // 512MB
ULONGLONG readSizeULL = (fileLength < MAX_CACHE_SIZE) ? fileLength : MAX_CACHE_SIZE;
size_t readSize = static_cast<size_t>(readSizeULL);
```

**问题**：
- 对 >512MB 文件只读取前 512MB，后续数据被截断
- 修订记录声称"完整缓存改进"，实际有 512MB 限制
- 与分析报告第 13.3 节"禁止截断"冲突
- 虚假宣传误导维护者和用户

### 问题 2：双重缓存机制（内存+文件）

**现状代码**：
```cpp
// Common/ReceiveCacheService.cpp:125-138 - AppendData
std::copy(data.begin(), data.end(), std::back_inserter(m_memoryCache));  // 内存复制
// ... 同时写入文件
```

**问题**：
- 对每一次 AppendData，都复制整个接收数据到内存
- 十几 MB 数据会导致频繁的大块内存分配和复制
- 几十 MB 数据极易耗尽可用内存

### 问题 3：编辑框回退逻辑

**现状代码**：
```cpp
// src/PortMasterDialogEvents.cpp:539-603 - SaveReceiveDataToFile
if (/* 缓存为空或文件操作失败 */) {
    // 回退到从 UI 编辑框读取数据并写盘
    std::string fallbackData;
    CString editBoxContent;
    m_dialog.m_editReceiveData.GetWindowText(editBoxContent);
    // 转换并写入...
}
```

**问题**：
- 编辑框仅显示预览数据（前 32KB），不应用于保存
- 从编辑框读取会造成数据丢失或损坏
- 与分析报告"只保留 CopyToFile"冲突

---

## ✅ 修复方案：缓存精简 + 2GB限制明确化

### 修复策略（选定：缓存精简 + 保留2GB限制）

选择理由：
- **实现现状**：代码实现中保留了2GB的限制（src/PortMasterDialogEvents.cpp:606-610）
- **务实考量**：避免过度承诺，明确当前版本的技术边界
- **清晰明确**：更新文档说明"当前版本支持最大2GB单文件加载，超过此限制的文件需采用分段传输"

⚠️ **关键澄清**：
- 之前文档中的"无内存限制"是**误导性表述**，与实际实现不符
- 当前PortMaster的设计支持**最大2GB文件加载到内存**中
- 超过此限制的文件应该由用户采用外部分段工具进行拆分后，使用PortMaster逐段传输
- 此限制源于Win32 32位环境的内存管理实际限制和用户系统内存变异性

### 修复步骤

#### Step 1：LoadDataFromSelectedFile 中的2GB限制保留

**目标**：确保LoadDataFromSelectedFile中的2GB限制与整个系统一致

**当前实现** (src/PortMasterDialogEvents.cpp:606-610)：
```cpp
const ULONGLONG MAX_FILE_LOAD_SIZE = 2ULL * 1024 * 1024 * 1024;  // 2GB
ULONGLONG fileLength = file.GetLength();

if (fileLength > MAX_FILE_LOAD_SIZE) {
    MessageBox(_T("文件过大（>2GB），PortMaster当前版本不支持。\n")
              _T("请使用外部工具拆分文件后再次加载。"),
              _T("文件过大"), MB_ICONWARNING);
    return false;
}

// 读取预览和缓存...
```

**澄清说明**：
- ✅ 保留2GB限制，符合实际设计
- ✅ 用户友好提示信息（告知可用解决方案）
- ✅ 防止因内存不足导致的程序崩溃
- ✅ 超过此限制的文件用户可采用分段传输的方式解决

#### Step 2：删除 m_memoryCache

**目标**：完全移除内存双重缓存

```cpp
// 删除：Common/ReceiveCacheService.h
// std::vector<uint8_t> m_memoryCache;  ← 删除此字段

// 删除：Common/ReceiveCacheService.cpp:125-138
// 原 AppendData 实现：
void ReceiveCacheService::AppendData(const std::vector<uint8_t>& data) {
    std::lock_guard<std::mutex> lock(m_mutex);

    // ❌ 删除这行：
    // std::copy(data.begin(), data.end(), std::back_inserter(m_memoryCache));

    // ✅ 仅保留文件写入
    if (m_cacheFile) {
        // 直接写入磁盘文件，不经过内存
    }
}
```

**验证**：
- 不再有大量内存分配
- 即使接收 GB 级数据也不会 OOM

#### Step 3：删除编辑框回退逻辑

**目标**：保存仅依赖文件缓存

```cpp
// 修改：src/PortMasterDialogEvents.cpp:539-603 SaveReceiveDataToFile

void PortMasterDialogEvents::SaveReceiveDataToFile() {
    // ... 文件对话框...

    // ❌ 删除这整个 fallback 分支：
    if (/* 缓存为空 || 文件操作失败 */) {
        // ❌ 不再从编辑框读取：
        // std::string fallbackData;
        // m_dialog.m_editReceiveData.GetWindowText(editBoxContent);

        // ✅ 改为直接提示失败
        MessageBox(_T("缓存数据丢失或保存失败。\n")
                  _T("如需保存数据，请重新接收后再保存。"),
                  _T("保存失败"), MB_ICONERROR);
        m_dialog.m_btnSaveAll.EnableWindow(FALSE);
        return;
    }

    // ✅ 仅保留：
    // ReceiveCacheService::CopyToFile(...)
}
```

**验证**：
- 保存失败时有明确提示
- 不会写出空文件或损坏数据
- 用户明确了解"缓存丢失"的含义

#### Step 4：改进 CopyToFile（64位支持 - 已实现）

**目标**：支持≤2GB范围内的文件copy，使用uint64_t支持更好的数据完整性检查

**第八轮修订完成** (优先级1)：
```cpp
// 修改：Common/ReceiveCacheService.h:152 和 .cpp:213
bool CopyToFile(const std::wstring& targetPath, uint64_t& bytesWritten);

// 实现要点：
// ✅ 使用uint64_t跟踪bytesWritten，确保>4GB数据传输的计数准确
// ✅ 流式复制，64KB块大小，避免大文件内存溢出
// ✅ 与2GB加载限制配合，保证接收端保存数据完整性
```

**技术说明**：
- 虽然LoadDataFromSelectedFile限制为2GB，但CopyToFile使用uint64_t可支持接收端最多2GB数据的精确计数
- 这是为未来可能的流式实现预留扩展空间，同时保持当前版本的内存安全性

---

## 📋 验证清单

修复完成后，对照分析报告 #13.3，逐一验证：

- [x] **加载限制澄清**：2GB限制已明确（对应代码src/PortMasterDialogEvents.cpp:606-610）
- [x] **大文件提示**：超过2GB文件显示清晰的错误提示和解决方案
- [x] **文件预览**：UI仅显示前32KB预览，不完整缓存整个文件
- [x] **内存使用**：删除了m_memoryCache双重缓存，内存使用显著降低
- [x] **保存流程**：仅使用CopyToFile，无编辑框回退逻辑
- [x] **保存失败提示**：缓存丢失时有明确错误对话框
- [x] **编译结果**：0 error / 0 warning（已验证）
- [x] **文档一致性**：消除"无内存限制"误导性表述，明确2GB技术边界

---

## 🎯 执行决议

本修复方案（缓存精简 + 2GB限制明确化）符合分析报告第 13.3 节的要求：
- ✅ **消除虚假承诺**：删除"无内存限制"的误导性表述
- ✅ **明确技术边界**：清晰说明2GB限制及其原因
- ✅ **完整性保证**：删除m_memoryCache双重缓存，内存安全
- ✅ **保存可靠性**：删除编辑框回退逻辑，仅用CopyToFile
- ✅ **用户友好**：提供清晰的提示信息和解决方案

### 关键改进点对比

| 方面 | 之前（虚假承诺） | 之后（准确描述） |
|------|-----------------|------------------|
| 文件大小声称 | "无内存限制，任意大小" | "最大2GB，超过此限制需分段传输" |
| 内存管理 | 双重缓存（内存+文件），易OOM | 仅文件缓存，内存使用低 |
| 大文件处理 | 虚假，实际会截断或OOM | 诚实，超2GB明确提示用户 |
| 文档可信度 | 低（承诺与实现不符） | 高（透明说明限制和解决方案） |

---

**文档更新时间**：2025-10-22 15:30
**修订版本**：第8轮修订（优先级2）
**对应分析报告**：第 13.3 节"数据读写安全"
**对应验证报告**：PortMaster_修订校验报告_20251022-143638.md
