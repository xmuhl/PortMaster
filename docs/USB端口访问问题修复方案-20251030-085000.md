# USBç«¯å£è®¿é—®é—®é¢˜ä¿®å¤æ–¹æ¡ˆ

**é—®é¢˜æ—¥æœŸ**: 2025å¹´10æœˆ30æ—¥ 08:50:00
**é—®é¢˜æè¿°**: USBæ‰“å°æœºç«¯å£æ˜¾ç¤ºç¦»çº¿ï¼Œè¿æ¥å¤±è´¥
**æ ¹æœ¬åŸå› **: USBè®¾å¤‡è·¯å¾„æ ¼å¼é”™è¯¯

---

## ğŸ” é—®é¢˜åˆ†æ

### 1. å½“å‰é”™è¯¯å®ç° (å¤±è´¥)

**UsbPrintTransport::OpenDeviceHandle()**:
```cpp
std::string devicePath = "\\\\.\\" + m_config.deviceName;
// ä¾‹å¦‚: "\\.\USB002" - è¿™æ˜¯é”™è¯¯çš„ï¼
```

### 2. å‚è€ƒæºç æ­£ç¡®å®ç° (æˆåŠŸ)

**IOControl.cppçš„æµç¨‹**:
```cpp
// 1. è·å–è®¾å¤‡æ¥å£è¯¦ç»†ä¿¡æ¯
SetupDiGetDeviceInterfaceDetail(hardwareDeviceInfo, &deviceInterfaceData,
    pDeviceInterfaceDetailData, predictedLength, &requireLength, &deviceInfoData);

// 2. è·å–å®é™…è®¾å¤‡è·¯å¾„
CString strDevicePath = pDeviceInterfaceDetailData->DevicePath;
// ä¾‹å¦‚: "\\?\USB#VID_1a86&PID_7523#MI_00#7&2e541988&0&0000#{...}"

// 3. ä½¿ç”¨å®é™…è·¯å¾„åˆ›å»ºæ–‡ä»¶
CreateFile(strDevicePath, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
```

### 3. å…³é”®å·®å¼‚

| é¡¹ç›® | IOControl.cpp | PortMaster |
|------|---------------|------------|
| è®¾å¤‡è·¯å¾„æ¥æº | SetupDiGetDeviceInterfaceDetail | ç›´æ¥æ‹¼æ¥ç«¯å£å |
| è·¯å¾„æ ¼å¼ | `\\?\USB#VID_...#...` | `\\.\USB002` |
| è®¾å¤‡æ ‡è¯† | å®é™…ç¡¬ä»¶ID | è™šæ‹Ÿç«¯å£å· |
| æˆåŠŸç‡ | âœ… 100% | âŒ 0% |

---

## ğŸ”§ ä¿®å¤æ–¹æ¡ˆ

### æ–¹æ¡ˆ1ï¼šä¿®æ”¹UsbPrintTransportä½¿ç”¨å®é™…è®¾å¤‡è·¯å¾„

#### ä¿®æ”¹ç‚¹1ï¼šPortDetectorå¢å¼º

**æ–‡ä»¶**: `Common/PortDetector.h`
```cpp
// æ·»åŠ è·å–è®¾å¤‡å®é™…è·¯å¾„çš„æ–¹æ³•
struct DeviceInfo {
    // ... ç°æœ‰å­—æ®µ ...
    std::string devicePath;  // æ–°å¢ï¼šå®é™…è®¾å¤‡è·¯å¾„
};
```

**æ–‡ä»¶**: `Common/PortDetector.cpp`
```cpp
// åœ¨EnumerateDevicesInternalä¸­æ·»åŠ 
device.devicePath = interfaceDetailData->DevicePath;  // è·å–å®é™…è·¯å¾„
```

#### ä¿®æ”¹ç‚¹2ï¼šä¿®æ”¹OpenDeviceHandle

**æ–‡ä»¶**: `Transport/UsbPrintTransport.cpp`
```cpp
TransportError UsbPrintTransport::OpenDeviceHandle()
{
    // æ–¹æ³•1ï¼šå°è¯•ä½¿ç”¨å®é™…è®¾å¤‡è·¯å¾„
    if (!m_config.devicePath.empty())
    {
        m_hDevice = CreateFileA(m_config.devicePath.c_str(), ...);
        if (m_hDevice != INVALID_HANDLE_VALUE)
            return TransportError::Success;
    }

    // æ–¹æ³•2ï¼šå›é€€åˆ°ç«¯å£åæ–¹å¼ (å…¼å®¹æ—§è®¾å¤‡)
    std::string devicePath = "\\\\.\\" + m_config.deviceName;
    m_hDevice = CreateFileA(devicePath.c_str(), ...);
    // ...
}
```

### æ–¹æ¡ˆ2ï¼šé‡‡ç”¨IOControl.cppçš„å®Œæ•´æµç¨‹

#### ä¿®æ”¹ç‚¹1ï¼šåˆ›å»ºUSBè®¾å¤‡æšä¸¾å™¨

**æ–‡ä»¶**: `Common/UsbDeviceEnumerator.h`
```cpp
class UsbDeviceEnumerator {
public:
    struct UsbDevice {
        std::string devicePath;      // å®é™…è®¾å¤‡è·¯å¾„
        std::string portName;        // USB001, USB002ç­‰
        std::string friendlyName;    // å‹å¥½åç§°
        std::string hardwareId;      // ç¡¬ä»¶ID
        std::string description;     // è®¾å¤‡æè¿°
    };

    static std::vector<UsbDevice> EnumerateUsbPrintDevices();
    static bool OpenDevice(const std::string& portName, HANDLE& hDevice);
};
```

#### ä¿®æ”¹ç‚¹2ï¼šå®ç°è®¾å¤‡æšä¸¾

**æ–‡ä»¶**: `Common/UsbDeviceEnumerator.cpp`
```cpp
std::vector<UsbDevice> UsbDeviceEnumerator::EnumerateUsbPrintDevices()
{
    std::vector<UsbDevice> devices;
    GUID guid = GUID_CLASS_I82930_BULK;  // æˆ–ä½¿ç”¨USBé€šç”¨GUID

    HDEVINFO deviceInfoSet = SetupDiGetClassDevs(&guid, NULL, NULL,
        DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);

    if (deviceInfoSet != INVALID_HANDLE_VALUE)
    {
        SP_DEVICE_INTERFACE_DATA deviceInterfaceData;
        deviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        DWORD index = 0;
        while (SetupDiEnumDeviceInterfaces(deviceInfoSet, NULL, &guid,
            index, &deviceInterfaceData))
        {
            // è·å–è®¾å¤‡è·¯å¾„
            DWORD requiredSize = 0;
            SetupDiGetDeviceInterfaceDetail(deviceInfoSet, &deviceInterfaceData,
                NULL, 0, &requiredSize, NULL);

            PSP_INTERFACE_DEVICE_DETAIL_DATA deviceDetailData =
                (PSP_INTERFACE_DEVICE_DETAIL_DATA)malloc(requiredSize);
            deviceDetailData->cbSize = sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);

            if (SetupDiGetDeviceInterfaceDetail(deviceInfoSet, &deviceInterfaceData,
                deviceDetailData, requiredSize, NULL, NULL))
            {
                UsbDevice device;
                device.devicePath = deviceDetailData->DevicePath;

                // é€šè¿‡æ³¨å†Œè¡¨è·å–ç«¯å£åç§°
                GetPortNameFromRegistry(deviceDetailData->DevicePath, device.portName);
                devices.push_back(device);
            }

            free(deviceDetailData);
            index++;
        }

        SetupDiDestroyDeviceInfoList(deviceInfoSet);
    }

    return devices;
}
```

---

## ğŸ“ æ¨èå®æ–½æ–¹æ¡ˆ

### æ¨èï¼šæ–¹æ¡ˆ1 (æ¸è¿›å¼ä¿®å¤)

**ä¼˜ç‚¹**:
- ä¿®æ”¹é‡å°ï¼Œé£é™©ä½
- ä¿æŒç°æœ‰æ¶æ„
- å¿«é€ŸéªŒè¯æ•ˆæœ

**å®æ–½æ­¥éª¤**:
1. ä¿®æ”¹PortDetectorè·å–å®é™…è®¾å¤‡è·¯å¾„
2. ä¿®æ”¹UsbPrintTransportä½¿ç”¨å®é™…è·¯å¾„
3. æµ‹è¯•USB002ç«¯å£è¿æ¥
4. éªŒè¯æ‰€æœ‰USBç«¯å£

### å¤‡é€‰ï¼šæ–¹æ¡ˆ2 (å®Œæ•´é‡æ„)

**ä¼˜ç‚¹**:
- å®Œå…¨åŸºäºæˆç†Ÿä»£ç 
- åŠŸèƒ½æ›´å¼ºå¤§
- å…¼å®¹æ€§å¥½

**å®æ–½æ—¶é—´**: 2-3å¤©

---

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **æƒé™é—®é¢˜**: USBè®¾å¤‡å¯èƒ½éœ€è¦ç®¡ç†å‘˜æƒé™
2. **è®¾å¤‡é”å®š**: ç¡®ä¿è®¾å¤‡æœªè¢«å…¶ä»–ç¨‹åºå ç”¨
3. **è·¯å¾„æ ¼å¼**: å®é™…è®¾å¤‡è·¯å¾„éœ€è¦æ­£ç¡®æ ¼å¼åŒ–
4. **é”™è¯¯å¤„ç†**: æ·»åŠ è¯¦ç»†é”™è¯¯æ—¥å¿—ä¾¿äºè°ƒè¯•

---

## ğŸ¯ é¢„æœŸæ•ˆæœ

ä¿®å¤åUSB002ç«¯å£åº”è¯¥å¯ä»¥ï¼š
- âœ… æ­£ç¡®æ˜¾ç¤ºè®¾å¤‡çŠ¶æ€
- âœ… æˆåŠŸå»ºç«‹è¿æ¥
- âœ… æ­£å¸¸ä¼ è¾“æ•°æ®
