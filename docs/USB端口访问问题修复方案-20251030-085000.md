# USB端口访问问题修复方案

**问题日期**: 2025年10月30日 08:50:00
**问题描述**: USB打印机端口显示离线，连接失败
**根本原因**: USB设备路径格式错误

---

## 🔍 问题分析

### 1. 当前错误实现 (失败)

**UsbPrintTransport::OpenDeviceHandle()**:
```cpp
std::string devicePath = "\\\\.\\" + m_config.deviceName;
// 例如: "\\.\USB002" - 这是错误的！
```

### 2. 参考源码正确实现 (成功)

**IOControl.cpp的流程**:
```cpp
// 1. 获取设备接口详细信息
SetupDiGetDeviceInterfaceDetail(hardwareDeviceInfo, &deviceInterfaceData,
    pDeviceInterfaceDetailData, predictedLength, &requireLength, &deviceInfoData);

// 2. 获取实际设备路径
CString strDevicePath = pDeviceInterfaceDetailData->DevicePath;
// 例如: "\\?\USB#VID_1a86&PID_7523#MI_00#7&2e541988&0&0000#{...}"

// 3. 使用实际路径创建文件
CreateFile(strDevicePath, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
```

### 3. 关键差异

| 项目 | IOControl.cpp | PortMaster |
|------|---------------|------------|
| 设备路径来源 | SetupDiGetDeviceInterfaceDetail | 直接拼接端口名 |
| 路径格式 | `\\?\USB#VID_...#...` | `\\.\USB002` |
| 设备标识 | 实际硬件ID | 虚拟端口号 |
| 成功率 | ✅ 100% | ❌ 0% |

---

## 🔧 修复方案

### 方案1：修改UsbPrintTransport使用实际设备路径

#### 修改点1：PortDetector增强

**文件**: `Common/PortDetector.h`
```cpp
// 添加获取设备实际路径的方法
struct DeviceInfo {
    // ... 现有字段 ...
    std::string devicePath;  // 新增：实际设备路径
};
```

**文件**: `Common/PortDetector.cpp`
```cpp
// 在EnumerateDevicesInternal中添加
device.devicePath = interfaceDetailData->DevicePath;  // 获取实际路径
```

#### 修改点2：修改OpenDeviceHandle

**文件**: `Transport/UsbPrintTransport.cpp`
```cpp
TransportError UsbPrintTransport::OpenDeviceHandle()
{
    // 方法1：尝试使用实际设备路径
    if (!m_config.devicePath.empty())
    {
        m_hDevice = CreateFileA(m_config.devicePath.c_str(), ...);
        if (m_hDevice != INVALID_HANDLE_VALUE)
            return TransportError::Success;
    }

    // 方法2：回退到端口名方式 (兼容旧设备)
    std::string devicePath = "\\\\.\\" + m_config.deviceName;
    m_hDevice = CreateFileA(devicePath.c_str(), ...);
    // ...
}
```

### 方案2：采用IOControl.cpp的完整流程

#### 修改点1：创建USB设备枚举器

**文件**: `Common/UsbDeviceEnumerator.h`
```cpp
class UsbDeviceEnumerator {
public:
    struct UsbDevice {
        std::string devicePath;      // 实际设备路径
        std::string portName;        // USB001, USB002等
        std::string friendlyName;    // 友好名称
        std::string hardwareId;      // 硬件ID
        std::string description;     // 设备描述
    };

    static std::vector<UsbDevice> EnumerateUsbPrintDevices();
    static bool OpenDevice(const std::string& portName, HANDLE& hDevice);
};
```

#### 修改点2：实现设备枚举

**文件**: `Common/UsbDeviceEnumerator.cpp`
```cpp
std::vector<UsbDevice> UsbDeviceEnumerator::EnumerateUsbPrintDevices()
{
    std::vector<UsbDevice> devices;
    GUID guid = GUID_CLASS_I82930_BULK;  // 或使用USB通用GUID

    HDEVINFO deviceInfoSet = SetupDiGetClassDevs(&guid, NULL, NULL,
        DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);

    if (deviceInfoSet != INVALID_HANDLE_VALUE)
    {
        SP_DEVICE_INTERFACE_DATA deviceInterfaceData;
        deviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        DWORD index = 0;
        while (SetupDiEnumDeviceInterfaces(deviceInfoSet, NULL, &guid,
            index, &deviceInterfaceData))
        {
            // 获取设备路径
            DWORD requiredSize = 0;
            SetupDiGetDeviceInterfaceDetail(deviceInfoSet, &deviceInterfaceData,
                NULL, 0, &requiredSize, NULL);

            PSP_INTERFACE_DEVICE_DETAIL_DATA deviceDetailData =
                (PSP_INTERFACE_DEVICE_DETAIL_DATA)malloc(requiredSize);
            deviceDetailData->cbSize = sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);

            if (SetupDiGetDeviceInterfaceDetail(deviceInfoSet, &deviceInterfaceData,
                deviceDetailData, requiredSize, NULL, NULL))
            {
                UsbDevice device;
                device.devicePath = deviceDetailData->DevicePath;

                // 通过注册表获取端口名称
                GetPortNameFromRegistry(deviceDetailData->DevicePath, device.portName);
                devices.push_back(device);
            }

            free(deviceDetailData);
            index++;
        }

        SetupDiDestroyDeviceInfoList(deviceInfoSet);
    }

    return devices;
}
```

---

## 📝 推荐实施方案

### 推荐：方案1 (渐进式修复)

**优点**:
- 修改量小，风险低
- 保持现有架构
- 快速验证效果

**实施步骤**:
1. 修改PortDetector获取实际设备路径
2. 修改UsbPrintTransport使用实际路径
3. 测试USB002端口连接
4. 验证所有USB端口

### 备选：方案2 (完整重构)

**优点**:
- 完全基于成熟代码
- 功能更强大
- 兼容性好

**实施时间**: 2-3天

---

## ⚠️ 注意事项

1. **权限问题**: USB设备可能需要管理员权限
2. **设备锁定**: 确保设备未被其他程序占用
3. **路径格式**: 实际设备路径需要正确格式化
4. **错误处理**: 添加详细错误日志便于调试

---

## 🎯 预期效果

修复后USB002端口应该可以：
- ✅ 正确显示设备状态
- ✅ 成功建立连接
- ✅ 正常传输数据
