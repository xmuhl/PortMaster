# PortMaster 近期检查报告（遗留问题）

生成时间：2025-09-26 13:15:01

## 1. 可靠传输链路

1. **握手仍未真正闭环**（Protocol/ReliableChannel.cpp:354-404）
   - 发送 START 帧后仅等待固定时长便默认成功，缺少对接收端 ACK 的实时确认，可靠模式依旧存在漏判风险。
2. **会话标识缺失**（Protocol/ReliableChannel.cpp:1464）
   - metadata.sessionId 始终写死为 0，无法区分不同会话或用于双方状态匹配。
3. **控制帧未纳入窗口管理**（Protocol/ReliableChannel.cpp:1478-1503）
   - START 等控制帧未写入发送窗口，后续无法对 ACK 进行对应校验，重试策略仍不完整。

## 2. 并口实现

- **宏重复定义风险**（Transport/ParallelTransport.cpp:639-646）
  - 函数体内重新 #define CTL_CODE / METHOD_BUFFERED 等宏，易与 <winioctl.h> 的标准定义冲突，可能产生编译警告或错误。

## 3. 传输工厂

- **TransportFactory 仍缺落地文件**
  - Transport/ITransport.h:135 只声明工厂接口，SimpleTransportTest.cpp、TestTransportModules.cpp 依旧引用 Transport/TransportFactory.h，目前无法通过相关测试或示例编译。

## 4. 自动化验证体系

1. **自动脚本尚未编写**
   - 可靠协议、配置读写等模块的自动化验证流程仍停留在规划阶段，尚无可直接运行的脚本/小程序。
2. **联机场景缺少配套说明**
   - 并口、USB、网络等需要实机配合的测试尚未提供脚本骨架与操作说明（接线步骤、命令示例、预期输出、人工判定点等）。

## 5. 调试输出与排障

- 虽已新增大量日志，但仍缺少“握手成功/失败、ACK 匹配状态”等明确信息，排查时需要人工从长日志中筛查关键点。

---
整改建议可参考 docs/PortMaster_代码全量分析报告.md 第三、第四节，优先闭合可靠协议握手与自动化验证链路，再逐步解决其他问题。

## 6. 手工测试新增问题

1. **大文件传输完成后接收窗口持续闪烁**（src/PortMasterDlg.cpp:2995、3116、1738）
   - 接收线程在每个 4KB 分片到达时都会 PostMessage(WM_USER+1, ...) 触发整窗重绘，UpdateReceiveDisplayFromCache() 又会重建最后 100 行文本。大文件场景下消息队列积压，传输完成弹框关闭后仍继续处理剩余消息，造成接收框闪烁。
   - **建议**：引入节流或批量处理机制、在弹框前等待消息队列完成，或改为增量追加显示内容，避免整块重绘。

2. **发送完成后再次点击“发送”却提示“没有可发送的数据”**（src/PortMasterDlg.cpp:3310、478、2252）
   - 传输完成回调清空了 m_sendDataCache 并把 m_sendCacheValid 置为 false，但发送编辑框文本仍保留。StartTransmission() 只依据发送缓存判断，从未重新同步编辑框内容，用户立即再次点击发送时就被判定为“无数据”。
   - **建议**：只有当用户点击清空输入框按钮时才允许执行清除输入数据窗口内容和发送缓存，其他操作不能代替执行这部分操作。
## 7. 新发现：保存文件尺寸与原始数据不一致

- **现象**：在可靠模式与直通模式下测试大文件（例如 1,113,432 字节的 PDF）时，界面提示已接收的字节数与原始文件一致，但通过“保存”功能生成的新文件分别只有 1,015,808 字节（可靠模式）和 868,352 字节（直通模式）。
- **原因分析**：
  1. ReadDataFromTempCache() 为读取临时文件，会临时 lush() 并 close() 写入流，再打开读流读取全部数据；读取结束后再以追加方式重新打开写入流。这一窗口内若后台接收线程继续写入（WriteDataToTempCache()），会因为写入流已关闭而直接返回 alse，导致某些分片未落盘。
  2. 当前实现不会在写入失败时重试或缓存补写；m_totalReceivedBytes 与 m_bytesReceived 不再一致，最终 ReadAllDataFromTempCache() 只能读取到已落盘的前 N 块数据，造成保存文件被截断。
  3. 该逻辑对可靠/直通两种模式均成立，只是不同模式的数据到达节奏不同，导致截断点不同。
- **修改建议**：
  1. 调整缓存读写策略，避免在读取过程中关闭正在使用的写入流。可考虑使用 std::fstream 以 ios::in | ios::out | ios::binary 方式共享同一个句柄，或在读取期间暂时阻塞接收线程/写操作，待复制完成后再恢复。
  2. 至少在 WriteDataToTempCache() 返回 false 时记录告警，并将该分片暂存到内存队列，待写入流恢复后补写，确保临时文件完整。
  3. 保存时可优先使用 m_receiveDataCache 内存副本作为兜底，若缓存已截断再提示用户重新接收。
