修订目标
- 修复 USB 端口发送特定十六进制数据后导致的程序闪退问题，确保输入序列 `0x31 0x32 0x33 0x0C` 发送稳定。

预期成果
- 明确闪退根因并完成修复。
- 提供稳定性复现与验证步骤，保证同类数据发送不再触发异常。
- 同步更新相关测试或文档，避免回归。

问题描述
- 当前版本在打开 USB 端口后，于输入数据窗口写入 `0x31、0x32、0x33、0x0C` 并点击发送按钮，程序立即闪退。
- 用户提供最新日志提示存在异常，需要详细分析崩溃堆栈与日志信息。

根因分析
- 最新 `build/Debug/PortMaster_debug.log` 显示传输线程刚启动即崩溃，无任何发送块日志，说明异常发生在后台线程。
- 复核 `CPortMasterDlg::WriteLog` 发现后台线程直接调用 `StatusDisplayManager::LogMessage` 更新 UI，未做线程切换；MFC 控件跨线程访问在快速发送场景下会触发访问冲突导致闪退。
- 发送 `0x31 0x32 0x33 0x0C` 时数据块极小，后台线程几乎瞬间完成并与主线程 UI 操作并发，放大了跨线程调用的竞态风险。

解决方案设计
- 在 `CPortMasterDlg::WriteLog` 中新增线程检测，后台线程通过 `PostMessage` 派发日志 UI 更新，避免直接触控控件。
- 引入新的 `WM_USER` 自定义消息承载日志文本，在主线程中统一调用 `StatusDisplayManager::LogMessage`。
- 保持文件写入逻辑不变，确保调试日志仍完整记录。

分阶段任务与测试清单
1. 收集资料：定位最新日志文件，整理崩溃现场信息。
2. 分析阶段：复现问题或通过日志定位崩溃模块与函数。
3. 修复阶段：实施代码修改并评审。
4. 验证阶段：执行构建与针对性测试，确认问题解决且无回归。

修订执行记录
- 2025-10-31 09:46:57 ⏳ 启动任务，确认问题范围为 USB 数据发送闪退，开始收集日志与环境信息。
- 2025-10-31 09:48:30 ⚠️ 执行 `git pull --rebase` 时检测到既有未暂存改动，为避免影响用户现有修改，暂保持当前工作区状态继续分析。
- 2025-10-31 09:53:12 📝 阅读 `build/Debug/PortMaster_debug.log`，确认传输线程启动后未继续输出，怀疑跨线程 UI 日志导致异常。
- 2025-10-31 09:57:43 🔧 确认 `WriteLog` 直接调用 UI 管理器存在竞态，拟通过消息派发改造确保线程安全。
- 2025-10-31 10:00:09 ✅ 完成 `autobuild_x86_debug.bat`，Win32 Debug 编译 0 error / 0 warning，待进一步验证运行。

技术总结
- 闪退根因为后台传输线程直接操作 MFC 控件，采用 `PostMessage` 将日志刷新封装到主线程可彻底规避跨线程访问。
- 日志过滤策略保持不变，但 UI 更新改为统一的消息回调，后续如需扩展可沿用该机制。
