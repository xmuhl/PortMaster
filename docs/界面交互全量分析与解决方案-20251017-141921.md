# PortMaster 界面交互全量分析与解决方案（2025-10-17 14:19:21）

## 1. 模块拆分现状综述
- **界面层 (CPortMasterDlg)**：负责窗口生命周期、消息映射与缓存管理，核心交互入口集中在 `src/PortMasterDlg.cpp:36-2100`。
- **事件分发 (PortMasterDialogEvents)**：对按钮事件进行一级封装，位于 `src/PortMasterDialogEvents.cpp:36-260`，负责转调对话框公共方法与 UI 控制器。
- **UI 控制器 (DialogUiController)**：封装控件读写、节流与状态刷新逻辑，见 `src/DialogUiController.cpp:40-520`。
- **状态展示 (StatusDisplayManager)**：统一进度条、状态栏与节流日志的呈现 (`src/StatusDisplayManager.cpp:1-320`)。
- **传输协调 (TransmissionCoordinator/TransmissionTask)**：抽象任务生命周期与回调转发 (`src/TransmissionCoordinator.cpp`, `src/TransmissionTask.cpp`)。
- **会话控制 (PortSessionController)**：管理底层 `ITransport` 与 `ReliableChannel` (`Protocol/PortSessionController.cpp:34-310`)。
- **配置存取 (DialogConfigBinder / PortConfigPresenter)**：负责 UI ↔ ConfigStore 的数据绑定与端口选项展示，但当前仅执行加载/刷新，未反写到连接流程。

> 以上模块在拆分后形成“事件调度 → UI 控制 → 会话/传输”多级交互链路，需逐一验证接口传递与逻辑完整性。

## 2. 交互流程静态分析

### 2.1 连接与断开流程
1. **按钮事件入口**：`OnBnClickedButtonConnect` → `PortMasterDialogEvents::HandleConnect` (`src/PortMasterDialogEvents.cpp:36-73`)。
2. **配置初始化**：`HandleConnect` 首行调用 `CPortMasterDlg::InitializeTransportConfig` (`src/PortMasterDlg.cpp:1388-1402`)，强制将 `m_transportConfig` 复位到串口默认值 (`COM1`, `PortType::PORT_TYPE_SERIAL`)。
3. **UI 模式判定**：通过 `DialogUiController::IsReliableModeSelected()` 判定可靠/直通模式，但**未调用** `DialogConfigBinder::SaveFromUI()`，也未读取 `PortConfigPresenter` 的最新选择。
4. **传输建立**：`PortSessionController::Connect` (`Protocol/PortSessionController.cpp:34-80`) 根据 `m_transportConfig.portType` 创建传输实例；由于配置被重置为串口，最终调用 `SerialTransport::Open`。
5. **可靠模式**：若启用可靠模式，随后创建 `ReliableChannel` 并调用 `Connect()`；基础配置来自 `m_reliableConfig`，但关键的 `Loopback` / 网络参数缺失。
6. **断开流程**：`HandleDisconnect` (`src/PortMasterDialogEvents.cpp:75-106`) 正确调用 `PortSessionController::Disconnect`，并重置 UI/缓存状态。

> **结论**：连接流程的事件传递链路完整，但 `InitializeTransportConfig` 的硬编码与缺失的 UI → TransportConfig 同步导致所有环境均按串口 `COM1` 建链，是直通与可靠模式写入失败的直接原因。

### 2.2 发送 / 暂停 / 恢复 / 中止流程
1. **发送按钮**：`HandleSend` (`src/PortMasterDialogEvents.cpp:108-128`) 根据 `m_isTransmitting` 状态调用 `StartTransmission` / `PauseTransmission` / `ResumeTransmission`。
2. **启动流程**：`StartTransmission` (`src/PortMasterDlg.cpp:566-606`) 校验缓存、复位状态，随后调用 `PerformDataTransmission`。
3. **通道判定**：`PerformDataTransmission` (`src/PortMasterDlg.cpp:653-745`) 通过 `PortSessionController::GetReliableChannel()` / `GetTransport()` 获取连接对象，并依据当前模式输出验证日志。
4. **任务启动**：`TransmissionCoordinator::Start` (`src/TransmissionCoordinator.cpp:32-87`) 优先使用“已连接的可靠通道”，否则回落到原始传输；若 ReliableChannel 因创建失败未连接，会退化为原始传输。
5. **暂停/恢复/取消**：分别封装 `TransmissionCoordinator::Pause/Resume/Cancel`，UI 状态由 `DialogUiController` 更新，状态标志 (`m_transmissionPaused` 等) 维持旧逻辑兼容。

> **结论**：发送/暂停等交互的接口传递正确，但由于连接阶段始终得到串口 Transport，`TransmissionCoordinator` 实际落地的是 `SerialTransport`，从而在无串口设备环境下 `ITransport::Write` 返回 `TransportError::WriteFailed`（日志中错误码4），表现为直通/可靠两种模式均立即失败。

### 2.3 传输进度与状态回调
1. **后台回调**：`TransmissionTask` 在 `ExecuteTransmission` 内定期调用 `UpdateProgress` 与 `ReportCompletion` (`src/TransmissionTask.cpp:230-334`)，回调由协调器包装。
2. **UI 线程交互**：`CPortMasterDlg::OnTransmissionProgress/Completed` (`src/PortMasterDlg.cpp:728-827`) 通过 `PostMessage(WM_USER + 11/13)` 将进度、状态传回 UI 线程。
3. **消息处理**：`OnTransmissionProgressUpdate/OnTransmissionComplete` (`src/PortMasterDlg.cpp:1824-1995`) 负责进度条与状态文本更新，并在失败情况下重置 UI、弹窗提示。

> **结论**：回调链路与 UI 更新逻辑正确。失败时能恢复按钮状态，但由于 `m_isTransmitting` 在 `StartTransmission` 置为 true，若传输在 `TransmissionCoordinator::Start` 即告失败，期间用户仍短暂看到“中断”按钮文本，需要在失败路径及时同步状态（后续修订可一并处理）。

### 2.4 接收数据显示与缓存更新
1. **数据回调**：`PortSessionController` 在 `ReceiveThreadProc` 内触发 `m_dataCallback`，对话框注册的回调为 `CPortMasterDlg::OnTransportDataReceived` (`src/PortMasterDlg.cpp:217-315` 初始绑定)。
2. **缓存写入与节流**：`OnTransportDataReceived` 将数据写入 `ReceiveCacheService`，并借助 `DialogUiController`/`StatusDisplayManager` 控制刷新频率。
3. **UI 刷新**：节流定时器 (`TIMER_ID_THROTTLED_DISPLAY`) 最终调用 `UpdateReceiveDisplayFromCache`，数据流保持一致。

> **结论**：接收数据流程接口连贯，与本次错误无直接关系。

### 2.5 配置同步链路缺失
1. **ConfigStore → UI**：`LoadConfigurationFromStore` 通过 `DialogConfigBinder::LoadToUI` 正常加载。
2. **UI → ConfigStore**：当前项目没有在连接前调用 `DialogConfigBinder::SaveFromUI`，导致用户在界面调整端口/模式后，`ConfigStore` 与 `m_transportConfig` 均未更新。
3. **TransportConfig 构建**：`PortConfigPresenter` 只负责 ComboBox 的可选项展示（如 `PortConfigPresenter::UpdateLoopbackPortParameters` 位于 `src/PortConfigPresenter.cpp:201-231`），却没有反写回 `CPortMasterDlg::m_transportConfig` 的接口。

> **结论**：UI 配置与连接参数初始化完全脱节，是模块拆分后新增的结构性缺陷；必须恢复“界面 → 配置 → 连接”链路。

## 3. 故障根因与影响
1. **根因A（直通模式写入失败）**  
   - `InitializeTransportConfig` 将 `m_transportConfig` 重置为串口默认值 (`src/PortMasterDlg.cpp:1388-1402`)。  
   - `PortSessionController::CreateTransportByType` 因 `config.portType == Serial` 创建 `SerialTransport` (`Protocol/PortSessionController.cpp:181-199`)。  
   - 在无物理串口的本地回路环境下，`SerialTransport::Write` 返回 `TransportError::WriteFailed`，日志记录 “数据块发送失败，错误码: 4”。
2. **根因B（可靠模式握手失败）**  
   - 可靠模式同样基于上述串口 Transport，`ReliableChannel::EnsureSessionStarted` 发送握手帧时调用 `transport->Write`，收到错误码4 (`Protocol/ReliableChannel.cpp:2536-2544`)。  
   - 可靠通道未能保持 `IsConnected()` 状态，随后 `TransmissionCoordinator::CreateTask` 降级为原始传输，再次触发写入失败。
3. **根因C（UI 配置不同步）**  
   - `PortMasterDialogEvents::HandleConnect` 未读取 `DialogUiController`/`PortConfigPresenter` 的选择结果（缺少 `BuildTransportConfig` 逻辑）。  
   - `DialogConfigBinder::SaveFromUI` 从未在连接时调用，导致配置存储与 UI 状态不一致。  
   - 用户界面上的端口类型、波特率、Loopback 参数与实际连接完全脱节，引发多处“界面显示正常 → 实际操作失败”的交互错觉。

## 4. 唯一解决方案与修订任务

> 下列阶段任务必须按顺序执行。每阶段开始前复核本节对应小节，完成后在本文件追加“处理结果”并同步 `docs/修订工作记录20251017-111429.md` 的阶段记录。

### 阶段A：恢复 UI → TransportConfig 同步
1. 新增 `CPortMasterDlg::BuildTransportConfigFromUI()`，调用 `DialogConfigBinder::SaveFromUI()` 并使用 `PortConfigPresenter` / `DialogUiController` 获取端口类型、端口名、超时等信息，填充 `m_transportConfig`。  
2. 将 `HandleConnect` 中的 `InitializeTransportConfig()` 替换为 `BuildTransportConfigFromUI()`，禁止在连接阶段复位为硬编码串口。  
3. 确保 `m_transportConfig.portType` 与 `PortConfigPresenter::GetSelectedPortType()` 对应（Loopback/Serial/Network等）。

### 阶段B：补齐 Loopback/可靠配置下发链路
1. 根据 `m_transportConfig.portType` 动态构造具体配置：  
   - Loopback 模式：填充 `LoopbackConfig`（队列大小、延迟等可从 `ConfigStore::GetLoopbackConfig()` 读取）并传递给 `PortSessionController`。  
   - 其他模式：保持现有串口/网络参数。  
2. 在可靠模式下，保证 `ReliableConfig` 的 `timeoutBase/timeoutMax/heartbeatInterval` 等参数与 UI/配置一致，并在 `SetReliableConfig` 前完成赋值。  
3. 调整 `TransmissionCoordinator::Start` 调用：可靠模式下仅在可用时传入 `reliableChannel`，直通模式传入 `transport`；避免在可靠通道未连接时错误降级。

### 阶段C：验证收敛与文档回填
1. 执行 `autobuild_x86_debug.bat`，确认输出 “0 error(s), 0 warning(s)” 并记录到修订文档。  
2. 在本地回路环境分别测试直通与可靠模式：  
   - 验证 `LoopbackTransport::Write` 不再返回 `WriteFailed`，可靠模式握手成功。  
   - 确认状态栏/日志输出与 UI 提示一致。  
3. 更新 `docs/修订工作记录20251017-111429.md` 各阶段的“处理结果”小节，归档关键日志与验证截图（如适用）。

## 5. 验证要求
1. **编译**：阶段A、B 实施后立即运行 `autobuild_x86_debug.bat`，保留含 “0 error(s), 0 warning(s)” 的日志片段。  
2. **功能**：直通模式与可靠模式各执行至少一次完整发送，日志中需出现 `PerformDataTransmission: 直通模式验证通过` / `可靠模式验证通过` 且无 `错误码: 4`。  
3. **握手**：可靠模式日志应包含 `EnsureSessionStarted: handshake completed successfully`。  
4. **文档**：本文件与修订记录完成阶段性回填后方可进入版本控制流程。

（尚未执行代码修改，待阶段任务完成后请在本文件追加各阶段“处理结果”小节。）***
