# 可靠模式大文件保存崩溃分析与解决方案（2025-10-17 17:37:30）

## 1. 复现现象
- 环境：本地回路、可靠传输模式。
- 操作步骤：
  1. 传输并保存多次小文件（≈10KB），流程正常。
  2. 不退出程序，重新加载较大文件（≈1MB），执行传输。
  3. 传输完成后点击“保存全部”即触发崩溃。
- 日志特征：`build/Debug/PortMaster_debug.log` 记录传输线程持续写入临时缓存（`ReceiveCacheService::AppendData`）至 500KB+；保存过程中无任何日志输出，随后进程异常退出。

## 2. 根因分析

### 2.1 保存实现加载全量缓存到内存
1. `PortMasterDialogEvents::SaveReceiveDataToFile` 优先调用 `ReceiveCacheService::ReadAllData()` 并将结果拷贝到新的 `std::vector<uint8_t>`（`src/PortMasterDialogEvents.cpp:458-464`）。
2. `ReceiveCacheService` 内部已维护：
   - 内存缓存 `m_memoryCache`（保存全部接收数据）。
   - 磁盘缓存临时文件。
   - 此处再次复制为 `cachedData`，形成第三份完整拷贝。
3. 向量分配与复制不在 `try/catch` 内，若 `ReadAllData` 期间发生 `std::bad_alloc`（32 位进程更易触发），异常不会被捕获，直接导致进程崩溃。

### 2.2 随数据量增加放大内存消耗
1. 对于 1MB 传输，内存中同时存在：
   - `m_receiveDataCache`（UI 快照）
   - `ReceiveCacheService::m_memoryCache`
   - `cachedData`（保存阶段生成）
   三者合计 ≈3MB。
2. 多次小文件 + 大文件混合测试会进一步放大碎片化风险，即使单次数据量只有 1MB，也足以触发 `std::bad_alloc`。

### 2.3 缺少失败处理与日志
1. 当前保存逻辑未对 `cachedData` 分配失败或 `ReadAllData()` 返回空做判定；一旦 `cachedData` 构造失败，程序直接崩溃。
2. 保存流程无关键日志，调试难以定位。

## 3. 唯一修复方案

> 调整策略为“流式复制 + 精简内存占用”，每阶段执行前复核本节对应条目，完成后在《修订工作记录20251017-174129.md》与本文补充“处理结果”。

### 阶段A：为 ReceiveCacheService 增加流式复制接口
1. 新增 `bool ReceiveCacheService::CopyToFile(const std::wstring& targetPath, size_t& bytesWritten)`：
   - 使用 `std::ifstream` + `std::ofstream` 或 `CopyFileW`，按 1MB/64KB 等块大小循环读取、写出。
   - 读取时复用 `m_fileMutex`，避免与 `AppendData` 冲突。
   - 写入过程中输出调试日志（开始/进度/完成/异常）。
2. 若临时文件不存在或尚未初始化，接口返回 `false` 并记录日志。

**处理结果（2025-10-17）：**
- ✅ 已在 `Common/ReceiveCacheService.h` 添加 `CopyToFile()` 接口声明（152行）
- ✅ 已在 `Common/ReceiveCacheService.cpp` 实现流式复制逻辑（222-396行）
  - 使用64KB块大小进行循环读取和写入
  - 复用m_fileMutex互斥锁，确保与AppendData操作互斥
  - 提供详细的进度日志（每1MB输出一次进度）
  - 实现完整的错误处理和异常捕获
  - 检测复制过程中的并发写入并给出警告
- ✅ 临时文件状态验证完整（路径检查、文件存在性检查）
- ✅ 复制完成后验证字节数一致性

### 阶段B：重写保存流程
1. 在 `PortMasterDialogEvents::SaveReceiveDataToFile` 中：
   - 优先调用 `CopyToFile`；成功后记录字节数并更新 `m_staticPortStatus`。
   - 若 `CopyToFile` 失败（无缓存或文件不存在），退回 `m_receiveDataCache`/编辑框文本保存逻辑。
   - 捕获所有异常并通过 `MessageBox` 提示。
   - 保存成功后调用 `m_dialog.UpdateSaveButtonStatus()`，保持状态一致。
2. 去除原始 `std::vector<uint8_t> cachedData` 大内存拷贝代码。

**处理结果（2025-10-17）：**
- ✅ 已重写 `PortMasterDialogEvents::SaveReceiveDataToFile()` 方法（455-581行）
- ✅ 优先调用流式复制：`m_receiveCacheService->CopyToFile()`（470-530行）
  - 流式复制成功后显示详细的文件大小信息（字节/KB/MB自适应）
  - 调用 `m_dialog.m_uiController->UpdateSaveButtonStatus()` 更新按钮状态
  - 显示成功提示对话框
- ✅ 实现备用保存逻辑：从编辑框获取文本保存（532-580行）
  - 仅在流式复制失败时使用
  - 添加空数据检查，避免保存空文件
  - 添加文件打开失败检查
- ✅ 完全移除原始的 `ReadAllData()` 大内存拷贝代码
- ✅ 所有路径都添加了完整的异常捕获（std::exception 和通用异常）
- ✅ 所有关键操作都添加了详细的日志记录

### 阶段C：日志与文档同步
1. 在关键路径加入日志：开始保存、流式复制成功/失败、回退路径、最终状态。
2. 在本文对应阶段补充"处理结果"，并于配套修订记录《修订工作记录20251017-174129.md》记录执行情况。

**处理结果（2025-10-17）：**
- ✅ 已在 `SaveReceiveDataToFile()` 中添加完整的日志记录：
  - 开始保存日志："SaveReceiveDataToFile: 开始流式保存接收数据"
  - 流式复制成功日志："SaveReceiveDataToFile: 流式保存成功，字节数: XXX"
  - 流式复制失败日志："SaveReceiveDataToFile: 流式保存失败，尝试使用备用方法"
  - 异常日志："SaveReceiveDataToFile: 流式保存异常 - XXX"
  - 备用方法启动日志："SaveReceiveDataToFile: 使用备用方法（从编辑框保存）"
  - 备用方法成功日志："SaveReceiveDataToFile: 备用方法保存成功"
- ✅ 已在 `ReceiveCacheService::CopyToFile()` 中添加详细的进度日志
- ✅ 已更新本文档阶段A、B、C的"处理结果"部分
- ✅ 待编译验证后更新修订记录文档

### 阶段D：验证
1. `autobuild_x86_debug.bat` 必须输出 "0 error(s), 0 warning(s)"。
2. 本地回路测试：
   - 多次小文件传输 → 保存；
   - 继续加载 ≥1MB 文件传输 → 保存；
   - 确认保存成功且应用无崩溃。
3. 在 `build/Debug/PortMaster_debug.log` 标记上述流程关键日志，并将验证结论写入配套修订记录与本文。

**处理结果（2025-10-17）：**
- ✅ **编译验证通过** - autobuild_x86_debug.bat成功编译
  - 编译结果：0 error 0 warning
  - 编译时间：13.45秒
  - 输出文件：build/Debug/PortMaster.exe
- ✅ **编译问题修正记录**：
  1. 修正方法名错误：UpdateSaveButtonStatus → UpdateSaveButton(bool)
  2. 修正std::min宏冲突：使用三元运算符替代
- ⏳ **功能测试待执行**（需要用户在实际环境中测试）：
  - 测试步骤1：本地回路模式，多次小文件（≈10KB）传输并保存
  - 测试步骤2：不退出程序，加载大文件（≥1MB）传输并保存
  - 验证目标：保存成功且应用不崩溃
  - 日志验证：检查build/Debug/PortMaster_debug.log中的流式复制日志

## 4. 验证要求与交付
- 阶段A/B/C/D 需严格按顺序执行，并在 `docs/修订工作记录20251017-174129.md` 对应阶段回填"执行后核对"与日志片段。
- 完成后提交代码前必须保持编译零警告、同步文档，并说明测试结果。***
