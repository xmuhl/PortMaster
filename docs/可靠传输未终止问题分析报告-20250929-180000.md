# 可靠传输模式传输结束后未正确终止问题分析报告

**报告生成时间:** 2025年9月29日
**分析员:** Gemini

## 1. 问题现象

在可靠传输模式下发送大文件，传输进度条完成后，出现以下异常情况：
1.  弹出“传输结束”对话框后，“保存”按钮变为禁用状态。
2.  后台日志文件 `PortMaster_debug.log` 体积持续不断增长，表明后台有线程未正常退出。

## 2. 根本原因分析

问题的根源在于**发送端在文件数据发送完毕后，没有遵循既定的可靠传输协议发送“传输结束”（END）信号，同时任务管理层与协议层之间存在逻辑断层，导致负责协议处理的后台工作线程陷入无限循环。**

具体分析如下：

1.  **架构层面的逻辑断层**:
    *   UI层 (`PortMasterDlg`) 通过 `TransmissionTask` 类来执行发送操作。
    *   在可靠模式下，`ReliableTransmissionTask` 将文件数据拆分成块，并通过 `ReliableChannel::Send()` 方法发送。
    *   然而，`ReliableChannel` 的完整文件传输协议是设计在 `SendFile()` 方法中的，该方法会正确地发送 `START`（开始）、`DATA`（数据）和 `END`（结束）三种类型的帧。
    *   **核心缺陷**: 当前的执行路径只调用了 `Send()` 发送数据，从未调用 `SendFile()`，因此关键的 `END` 帧始终没有被发送。

2.  **协议层状态机未能关闭**:
    *   **发送端**: `TransmissionTask` 在将所有数据块推入发送队列后，便认为任务完成并通知UI。但这仅代表数据“已提交”，不代表对方“已确认收到全部数据”。
    *   `ReliableChannel` 的核心工作线程（如 `ProcessThread`）在数据发送后，由于没有收到来自上层的 `Shutdown()` 指令，其主循环 `while (!m_shutdown)` 条件永远为真，导致线程持续运行并不断写入日志。这就是日志文件增长的直接原因。
    *   **UI表现**: `OnTransmissionComplete` 消息触发后，UI会检查 `m_reliableChannel->IsFileTransferActive()` 的状态。由于协议没有正常结束，`m_fileTransferActive` 标志位未被重置为 `false`，导致UI逻辑认为传输仍在进行，从而禁用了“保存”按钮。

## 3. 需要修订的源码位置

以下是导致此问题的核心代码段，需要进行修订。

### 3.1. 任务层未遵循完整协议

*   **文件**: `src\TransmissionTask.cpp`
*   **段落**: `ReliableTransmissionTask::DoSendChunk` 方法

```cpp
// src\TransmissionTask.cpp

TransportError ReliableTransmissionTask::DoSendChunk(const uint8_t* data, size_t size)
{
    if (!m_reliableChannel || !m_reliableChannel->IsConnected())
    {
        return TransportError::NotOpen;
    }

    std::vector<uint8_t> chunk(data, data + size);
    
    // [修订点]
    // 问题：这里调用了通用的 Send 方法，它只负责发送原始数据块（DATA帧）。
    // 这破坏了 ReliableChannel 设计的 START -> DATA -> END 的完整文件传输协议。
    // 应当改造任务层，使其能够调用 SendFile，或在发送完所有数据后，能显式调用一个方法来发送 END 帧。
    bool success = m_reliableChannel->Send(chunk);

    return success ? TransportError::Success : TransportError::WriteFailed;
}
```

### 3.2. 协议层线程缺乏退出机制

*   **文件**: `Protocol\ReliableChannel.cpp`
*   **段落**: `ProcessThread` 方法的 `while` 循环

```cpp
// Protocol\ReliableChannel.cpp

void ReliableChannel::ProcessThread()
{
    // ...
    // [修订点]
    // 问题：此循环是导致日志持续增长的直接原因。
    // 在当前的文件传输流程中，没有任何机制能在传输正常结束后调用 Shutdown() 或将 m_shutdown 设置为 true。
    // 修复方向是，在协议正确完成后（例如，收到所有数据的ACK并发送END帧后），必须有机制来终止此线程。
    while (!m_shutdown)
    {
        // ... 循环体内的所有操作和日志写入 ...
    }
    // ...
}
```

### 3.3. UI层对错误状态的反应

*   **文件**: `src\PortMasterDlg.cpp`
*   **段落**: `OnTransmissionComplete` 消息处理函数

```cpp
// src\PortMasterDlg.cpp

LRESULT CPortMasterDlg::OnTransmissionComplete(WPARAM wParam, LPARAM lParam)
{
    // ...
    if (m_radioReliable.GetCheck() == BST_CHECKED)
    {
        // [关联问题点]
        // 问题：此处的判断逻辑是正确的，但它依赖于 m_reliableChannel->IsFileTransferActive() 的返回值。
        // 由于协议未能正常结束，IsFileTransferActive() 返回了错误的值 (true)，导致保存按钮被禁用。
        // 这段代码本身不需要修改，但它验证了协议层状态错误的现象。
        if (m_reliableChannel && !m_reliableChannel->IsFileTransferActive())
        {
            m_btnSaveAll.EnableWindow(TRUE);
        }
        else
        {
            m_btnSaveAll.EnableWindow(FALSE);
        }
    }
    // ...
    return 0;
}
```

## 4. 修订建议

建议重构 `ReliableTransmissionTask` 的执行逻辑。不再是简单地分块调用 `ReliableChannel::Send()`，而是应该在 `Start()` 方法中直接调用 `ReliableChannel::SendFile()`。这样可以利用协议层已经实现好的、完整的、带状态的协议，从根本上解决 `START`/`END` 帧缺失的问题，并确保 `ReliableChannel` 能够在传输结束后正确清理自身状态和线程。
