# 《代码审查与修订计划》二次验证结论报告

**报告日期:** 2025年9月29日
**验证目标:** 对 `代码审查与修订计划_20250929.md` 报告中的核心结论，以及一份外部模型的分析结论，进行最终的代码符合度审查。

---

## 最终审查结论

经过对项目源代码的再次深入审查，最终确认：

1.  **《代码审查与修订计划_20250929.md》报告中的分析完全正确。**
2.  **外部模型对“问题2”的分析（认为“不存在忙等”）是不准确且片面的。**

以下为针对两个核心问题的详细代码审查证据与论证。

---

### 问题1：可靠模式接收窗口基准未同步

**审查结论：确认存在此问题。**

**1. 审查文件：** `Protocol/ReliableChannel.cpp`

**2. 关键代码段：** `ProcessStartFrame` 函数

```cpp
// 文件: Protocol/ReliableChannel.cpp
void ReliableChannel::ProcessStartFrame(const Frame &frame)
{
    // ... 日志和元数据解码 ...
    if (m_frameCodec->DecodeStartMetadata(frame.payload, metadata))
    {
        // ... 设置文件名、大小等信息 ...

        // 发送 ACK 响应
        if (SendAck(frame.sequence))
        {
            // 【缺陷点】此处缺少对接收窗口基准 m_receiveBase 和 m_receiveNext 的重置
            WriteLog("ProcessStartFrame: ACK sent successfully, handshake established");
        }
        // ...
    }
    // ...
}
```

**3. 代码分析：**
源代码证实，在 `ProcessStartFrame` 函数中，程序在响应握手（`START`帧）时，仅发送了`ACK`确认，但**完全没有重置接收窗口的基准序号**。这导致接收方的窗口状态与发送方不一致。当后续数据帧（从序列号1开始）到达时，接收方会因 `IsSequenceInWindow` 判断失败而将其视为无效帧，从而丢弃数据并触发“NAK风暴”，最终导致传输阻塞。

**此项验证了原始报告的正确性。**

---

### 问题2：原始路径（直通模式）忙等风险

**审查结论：确认存在此风险。** 外部模型关于“不存在忙等”的判断是**不正确**的。

**1. 审查文件：** `src/PortMasterDlg.cpp`

**2. 关键代码段：** `StartReceiveThread` 函数中的 `while` 循环

```cpp
// 文件: src/PortMasterDlg.cpp
void CPortMasterDlg::StartReceiveThread()
{
    // ...
	m_receiveThread = std::thread([this]()
	{
        // ...
        while (m_isConnected)
        {
            // ...
            else if (m_transport && m_transport->IsOpen())
            {
                // 直通模式路径
                size_t bytesRead = 0;
                auto result = m_transport->Read(buffer.data(), buffer.size(), &bytesRead, 100);
                if (result == TransportError::Success && bytesRead > 0)
                {
                    OnTransportDataReceived(data);
                }
                // 【缺陷点】当 Read 超时且 bytesRead 为 0 时，此循环会立即重复，
                // 没有任何形式的等待或线程休眠。
            }
            // ...
        } 
    });
}
```

**3. 代码分析：**
外部模型声称“有100ms超时所以不存在忙等”的说法是片面的。它混淆了“死循环”和“低效轮询”。

-   **事实情况：** 在直通模式下，当端口空闲时，`Read` 函数会等待100ms后超时，并返回0字节。由于代码中缺少 `else` 分支来处理这种情况，`while` 循环会**立即**进行下一次迭代，再次调用 `Read`。
-   **问题实质：** 这形成了一个**高频次的轮询循环**。线程被以大约10次/秒的频率反复唤醒，执行无效的读取操作。这是一种典型的、应被优化的“忙等待风险”，会造成不必要的CPU资源浪费，并可能影响UI的流畅度。
-   **问题独立性：** 此问题仅存在于**直通模式**下，与可靠模式的“NAK风暴”是两个完全不相干的问题。因此，不能用一个问题来否定另一个问题的存在。

**此项再次验证了原始报告的正确性，并指出了外部模型分析的逻辑缺陷。**

---

## 总结

本次代码审查确认，`代码审查与修订计划_20250929.md` 中对两个核心问题的分析均准确、到位，完全符合源代码的实际情况。建议按照该计划进行修复。
