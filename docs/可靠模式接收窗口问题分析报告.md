# 可靠模式接收窗口空白及保存失败问题分析报告

**日期**: 2025-09-29  
**环境**: 修订后版本，可靠传输模式，待传输文件约 21 MB

---

## 1. 现象回顾
- 传输进行过程中，接收窗口始终没有显示任何数据。
- 与旧版相比，传输速度显著下降。
- 传输完成后点击“保存全部”，弹窗提示“没有可保存数据”。

---

## 2. 日志证据
节选自 `build\\Debug\\PortMaster_debug.log`（详见 10:48~11:33 时间段）：

```
ProcessDataFrame called: sequence=20779, payload.size()=1024, receiveBase=0, windowSize=32
ProcessDataFrame: sequence in window check: 0, window range=[0,32)
ProcessDataFrame: sequence outside window, sending NAK
SendNak called: sequence=20779
```

- 每个数据帧的序列号都远大于接收端当前的 `receiveBase (0)`，导致 `IsSequenceInWindow` 判断为“窗口外”，随即发送 NAK。
- 紧接着出现大量 `SendNak` 以及 `ProcessThread: processed 1 frames` 的循环，说明发送端被迫不断重传，因此吞吐量严重下降。
- 由于没有任何帧进入窗口，接收缓存、临时文件的写入逻辑均未执行，最终保存路径上没有数据，触发 UI 提示。

---

## 3. 相关代码定位

1. **滑动窗口初始值未更新**  
   - 文件：`Protocol/ReliableChannel.cpp:1250-1281`（`ProcessStartFrame`）  
   - 该函数在握手成功后仅发送 ACK，并未更新接收侧的 `m_receiveBase` / `m_receiveNext`。握手帧的序列号保持为 0，而发送端的数据帧序列在一个长会话中会增长到 2 万左右。  
   - 由于 `m_receiveBase` 仍然是初始化值 0，`ProcessDataFrame` 中的 `IsSequenceInWindow(sequence, m_receiveBase, windowSize)` 始终返回 false。

2. **接收线程的期望序列号始终为 0**  
   - 文件：`Protocol/ReliableChannel.cpp:820-876`（`ReceiveThread`）  
   - 线程通过 `expected = m_receiveBase` 逐个查找缓冲槽。当 `m_receiveBase` 固定在 0 时，永远找不到匹配的数据包，无法推进窗口或触发 `m_receiveQueue` 入队。

3. **保存逻辑依赖接收缓存**  
   - 文件：`src/PortMasterDlg.cpp:2593-2668`（`OnBnClickedButtonSaveAll`）  
   - 保存入口首先检查临时缓存文件是否可用，以及内存缓存 `m_receiveDataCache` 是否有数据。由于所有数据帧都被 NAK 拒绝，这两个条件均为 false，从而弹出“没有可保存数据”的提示。

---

## 4. 根本原因
- 近期为补齐可靠模式握手，新增了 `EnsureSessionStarted()`（位于 `Protocol/ReliableChannel.cpp:2009` 起）。该函数会在每次发送前建立会话，但握手完成后，没有相应地“重置”接收窗口的基准值。
- 握手帧（`START`）使用的序列号为 0，而其后的数据帧因 `m_sendNext` 连续递增，很快超过窗口大小。接收端仍以旧的基准 0 进行判断，认为所有数据都在窗口之外，于是持续发送 NAK。
- 持续的 NAK 让发送端反复重传，导致传输速度极慢；由于没有任何帧被接受，接收窗口、缓存和临时文件全部为空，UI 无数据显示，保存提示“无数据”。

---

## 5. 修复建议
1. **在握手完成后同步滑动窗口基准**  
   - 在 `ProcessStartFrame` 里，将 `m_receiveBase`、`m_receiveNext` 重置为首个期望的序列号（例如 `frame.sequence + 1`），并清空 `m_receiveWindow` 中的旧状态，确保后续帧能够进入窗口。  
   - 同时在发送端（`EnsureSessionStarted` / `Send()`）适当重置 `m_sendBase` 和窗口，以保证新的会话从一致的基准开始。

2. **传输完成标志与保存按钮联动**  
   - 仅当握手后的首批数据被成功写入临时缓存时，才允许“保存全部”操作；或在保存流程中增加一次窗口状态检查，如果 `m_totalReceivedBytes == 0` 却仍在接收过程中，应提示用户等待，而非直接弹出“无数据”。

3. **增加诊断日志**  
   - 在 `ProcessStartFrame` 和 `ReceiveThread` 更新基准值时打印当前 `m_receiveBase / m_receiveNext`，方便后续排查。

---

## 6. 结论
- 日志与代码表明：握手改动后遗失了“重置接收窗口”的步骤，导致可靠模式无法接受任何数据帧，表现为 UI 空白、速度慢、保存失败。
- 修复应从 `Protocol/ReliableChannel.cpp` 的握手处理入手，补齐窗口基准设定；同时完善保存逻辑的状态判断，以避免类似回归。
