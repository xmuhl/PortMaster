# 可靠模式回路测试问题分析

## 背景
项目在串口可靠模式下，需要通过本地回路测试模拟两台主机之间的握手、应答与数据传输流程，以验证 ReliableChannel 的窗口与超时机制是否可靠。当前测试是借助 LoopbackTransport 在同一进程内回传数据，属于单进程双线程模型。

## 现象回溯
- 在 PowerShell 环境执行 utobuild_x86_debug.bat 立即失败，错误清单集中在 Protocol/ReliableChannel.cpp；编译器提示 m_currentFileName、m_currentFileSize、m_currentFileProgress、m_fileTransferActive 等成员未声明。
- 同一源文件内 ReliableChannel::SendPacket 的实现签名已经切换为 ool，但头文件保留旧版 TransportError SendPacket(...) 声明，触发 C2556/C2371 的“仅返回类型不同”的重定义错误。
- 构建失败后，可靠模式回路测试和 AutoTest 中的 ReliableChannel 场景均无法运行，串口可靠握手链路自然无法得到验证。

## 根因分析
1. **头文件与实现脱节**：ReliableChannel.cpp 在 P0/P1 修订中引入了统一的文件传输状态成员，并在构造、传输、超时检测等逻辑里广泛使用，但 ReliableChannel.h 未同步声明这些字段，编译期直接报错。该问题与运行时是否存在第二个进程无关。
2. **函数签名未统一**：实现层把 SendPacket 改为返回布尔值，但头文件与调用点仍沿用旧的 TransportError 语义，说明重构过程未完成即合入，导致接口不一致。即使手工跳过编译，它也会在链接或运行时引发未定义行为。
3. **单进程模型不是主因**：LoopbackTransport::ProcessSendQueue 会把写入的数据排队并回推到 Read，ReliableChannel::ProcessStartFrame/ProcessDataFrame 在收到 START/Data 帧后会主动发送 ACK，因此单实例即可闭环握手。只要 ReliableChannel 定义完整，单进程回路即可模拟“双端”逻辑。

## 可行的修复方案
1. **同步接口定义**：在 ReliableChannel.h 中补齐 m_currentFileName、m_currentFileSize、m_currentFileProgress、m_fileTransferActive、m_transferStartTime 等成员声明，并保证构造函数初始值列表顺序与声明一致。
2. **统一 SendPacket 语义**：确定最终想要的返回类型（建议改为 ool，因为实现已按照布尔语义写回统计和错误处理），然后同步更新头文件声明及所有调用者（发送线程、重传逻辑、发送结束帧等）。若仍需错误码，可在布尔返回的同时通过 out 参数或内部 ReportError 保留细节。
3. **编译与测试回归**：
   - 重新执行 utobuild_x86_debug.bat，确认 0 error / 0 warning。
   - 运行 AutoTest 中的 ReliableChannelTest 与相关集成测试，验证握手、窗口滑动、ACK/NAK 及文件传输流程。
   - 在 UI 或命令行工具上，启用可靠模式进行一次实际的 loopback 传输，检查日志是否有 START/ACK/DATA/END 的完整序列。
4. **附加建议**：如果未来要更贴近“双节点”场景，可在测试中实例化两个 ReliableChannel 对象，并使用一对互联的虚拟串口或内部管道；但当前阻断问题是接口不一致，处理后现有 loopback 已足够验证。

## 验证策略建议
- 构建脚本：utobuild_x86_debug.bat
- 单元/集成测试：AutoTest.exe --unit-tests、AutoTest.exe --integration
- 手工测试：在 UI 内选择 Loopback 端口 + 可靠模式，发送测试文件并观察日志中 ACK/NAK 的数量与窗口推进情况。

## 结论
当前回路测试失败的根本原因是 ReliableChannel 的头文件与实现未同步，导致构建阶段即告失败，并非因为测试仍在单进程内模拟两个端点。完成接口同步后，现有的 loopback 架构即可支撑可靠模式的握手与数据往返验证。